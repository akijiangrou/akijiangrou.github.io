<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MissSweety&#39;s Blog</title>
  <subtitle>never say never</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://misssweety.github.io/"/>
  <updated>2017-10-27T09:38:28.000Z</updated>
  <id>https://misssweety.github.io/</id>
  
  <author>
    <name>Jessica</name>
    <email>zcx900308@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redux源码相关</title>
    <link href="https://misssweety.github.io/2017/10/26/redux%E6%BA%90%E7%A0%81%E7%9B%B8%E5%85%B3/"/>
    <id>https://misssweety.github.io/2017/10/26/redux源码相关/</id>
    <published>2017-10-26T13:19:25.000Z</published>
    <updated>2017-10-27T09:38:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redux源码阅读"><a href="#redux源码阅读" class="headerlink" title="redux源码阅读"></a>redux源码阅读</h1><p>redux源码很少，重点在思想。  </p>
<h2 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h2><blockquote>
<p>function createStore(reducer, preloadedState, enhancer)</p>
</blockquote>
<p>reducer是唯一必传的参数，它很重要，因为它决定了整个state。preloadedState就是state的初始值。第三个参数不是特别常用，它是个函数，如果它存在的情况下，会执行下面的语句：</p>
<p><code>enhancer(createStore)(reducer, preloadedState)</code></p>
<p>enhancer 增强createStore。</p>
<p>createStore内部维护：  </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> currentReducer = reducer</div><div class="line"><span class="selector-tag">var</span> currentState = preloadedState</div></pre></td></tr></table></figure>
<h3 id="function-subscribe-listener"><a href="#function-subscribe-listener" class="headerlink" title="function subscribe(listener)"></a>function subscribe(listener)</h3><p>在createStore内部维护了两个数组currentListeners、nextListeners。nextListeners的存在是为了避免在listeners执行过程中，listeners发生改变，导致错误。listeners的添加或删除都是对nextListeners进行操作的。nextListeners 初始等于 currentListeners = [];</p>
<p>每次subscribe 都会判定下nextListeners === currentListeners是否相等。</p>
<p>每次执行substribe 都会返回function unsubscribe()，取消监听。  </p>
<h3 id="function-dispatch-action"><a href="#function-dispatch-action" class="headerlink" title="function dispatch(action)"></a>function dispatch(action)</h3><p>currentState = currentReducer(currentState, action)</p>
<p>有dispatch，就一定执行currentReducer。<br>以及</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var listeners = currentListeners = nextListeners</div><div class="line"><span class="keyword">for</span> (var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; listeners.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</div><div class="line">  listeners[i]()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> action</div></pre></td></tr></table></figure>
<p>调用subscribe传进来的listeners，按顺序执行它们，没有任何条件判断，也就是说只要执行dispatch，所有的listeners都会执行，不管state有没有发生改变，而且listeners执行的时候是没参数的。</p>
<p>而且，在创建store的时候，会  </p>
<h3 id="function-getState"><a href="#function-getState" class="headerlink" title="function getState()"></a>function getState()</h3><p>return currentState</p>
<p>每次都返回currentState</p>
<p><code>dispatch({ type: ActionTypes.INIT })</code></p>
<h3 id="function-replaceReducer-nextReducer"><a href="#function-replaceReducer-nextReducer" class="headerlink" title="function replaceReducer(nextReducer)"></a>function replaceReducer(nextReducer)</h3><p>currentReducer = nextReducer<br>dispatch({ type: ActionTypes.INIT })</p>
<p>直接拿nextReducer替换掉前面说很重要的currentReducer，后面再执行dispatch，action就会被nextReducer处理，处理的结果赋值给currentState。替换之后会执行一遍初始化action。</p>
<p>重点是：currentState，currentReducer，nextListeners；</p>
<h2 id="bindActionCreator"><a href="#bindActionCreator" class="headerlink" title="bindActionCreator"></a>bindActionCreator</h2><p><code>function bindActionCreators(actionCreators, dispatch)</code></p>
<p>如果actionCreators是函数，直接返回<br><code>(...args) =&gt; dispatch(actionCreator(...args))</code>；</p>
<p>如果是对象，则对每一个key，进行上面的转化，最后返回一个函数集合的对象。</p>
<h2 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h2><p><code>function combineReducers(reducers)</code></p>
<p>它接收的参数reducers是个对象，对象的value不能是undefined，必须是function。符合这个标准的reducer会被放入finalReducers中。<br>然后再对finalReducers进行校验，reducer必须有default处理，不能处理Redux内部的action type，比如@@redux/INIT。然后返回一个函数combination(state = {}, action)，它也是一个reducer，可以被再次和其他reducer combine。一般combination等同于currentReducer，它的返回结果会赋给state，combination的关键代码如下：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> hasChanged = <span class="literal">false</span></div><div class="line">    <span class="built_in">var</span> nextState = &#123;&#125;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.<span class="built_in">length</span>; i++) &#123;</div><div class="line">      <span class="built_in">var</span> <span class="built_in">key</span> = finalReducerKeys[i]</div><div class="line">      <span class="built_in">var</span> reducer = finalReducers[<span class="built_in">key</span>]</div><div class="line">      <span class="built_in">var</span> previousStateForKey = state[<span class="built_in">key</span>]</div><div class="line">      <span class="built_in">var</span> nextStateForKey = reducer(previousStateForKey, action)</div><div class="line">      <span class="keyword">if</span> (typeof nextStateForKey === 'undefined') &#123;</div><div class="line">        <span class="built_in">var</span> errorMessage = getUndefinedStateErrorMessage(<span class="built_in">key</span>, action)</div><div class="line">        <span class="built_in">throw</span> <span class="built_in">new</span> Error(errorMessage)</div><div class="line">      &#125;</div><div class="line">      nextState[<span class="built_in">key</span>] = nextStateForKey</div><div class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> hasChanged ? nextState : state</div></pre></td></tr></table></figure>
<p>reducer从state中拿到对应的state，然后把返回的数据组装到state的对应位置(nextState[key] = nextStateForKey)</p>
<h2 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span><span class="params">(<span class="rest_arg">...middlewares</span>)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123;</div><div class="line">    <span class="keyword">var</span> store = createStore(reducer, preloadedState, enhancer)</div><div class="line">    <span class="keyword">var</span> dispatch = store.dispatch</div><div class="line">    <span class="keyword">var</span> chain = []</div><div class="line"></div><div class="line">    <span class="keyword">var</span> middlewareAPI = &#123;</div><div class="line">      getState: store.getState,</div><div class="line">      dispatch: (action) =&gt; dispatch(action)</div><div class="line">    &#125;</div><div class="line">    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))</div><div class="line">    dispatch = compose(...chain)(store.dispatch)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      ...store,</div><div class="line">      dispatch</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>applyMiddleWARE, 返回的其实是createStore，来增强dispatch。常用的thunkMiddleware，强化dispatch，可以传递函数，不一定是object。</p>
<p>一般使用的时候，是如下调用的，以thunkmiddleware为例：</p>
<p>thunkMiddleware 如下： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回以 dispatch 和 getState 作为参数的action</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">thunkMiddleware</span>(<span class="params">&#123; dispatch, getState &#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> action =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</div><div class="line">      <span class="keyword">return</span> action(dispatch, getState);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> next(action);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// usage</span></div><div class="line"><span class="keyword">import</span> &#123;createStore, applyMiddleware&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"><span class="keyword">import</span> thunkMiddleware <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> store = createStore(</div><div class="line">      reducers,</div><div class="line">      state,</div><div class="line">      applyMiddleware(thunkMiddleware)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>相当于有了enhancer，<br>上面store 会按如下执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// createStore.js</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> enhancer(createStore)(reducer, initialState)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  ||<br>\/</p>
<p><code>applyMiddleware(thunkMiddleware)(createStore)(reducer, initialState)</code></p>
<p>||<br>\/</p>
<p>applyMiddleware(thunkMiddleware) 返回<code>(createStore) =&gt; (reducer, initialState, enhancer) =&gt; {}</code>的函数。</p>
<p>继续，把createStore这个函数，传给上面的函数，然后继续执行。</p>
<p>在中间件代码中的，map部分，开始执行thunkMiddleware，其实就是对dispatch的封装，因为倒数第二步是：<br>chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));<br>dispatch = compose(…chain)(store.dispatch);</p>
<p>chain = [(next) =&gt; (action) =&gt; {…}];</p>
<p>dispatch = compose((next) =&gt; (action) =&gt; {…})(store.dispatch);</p>
<p>dispatch = store.dispatch(action) =&gt; {…};</p>
<p>最终{} 内部就是监测type是function的action</p>
<p>因此，如果dispatch的action返回的是一个function，则证明是中间件，则将(dispatch, getState)作为参数代入其中，进行action 内部下一步的操作。否则的话，认为只是一个普通的action，将通过next(也就是dispatch)进一步分发。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;redux源码阅读&quot;&gt;&lt;a href=&quot;#redux源码阅读&quot; class=&quot;headerlink&quot; title=&quot;redux源码阅读&quot;&gt;&lt;/a&gt;redux源码阅读&lt;/h1&gt;&lt;p&gt;redux源码很少，重点在思想。  &lt;/p&gt;
&lt;h2 id=&quot;createStore
    
    </summary>
    
    
      <category term="js" scheme="https://misssweety.github.io/tags/js/"/>
    
      <category term="redux" scheme="https://misssweety.github.io/tags/redux/"/>
    
      <category term="源码" scheme="https://misssweety.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>child_process</title>
    <link href="https://misssweety.github.io/2017/10/25/child-process/"/>
    <id>https://misssweety.github.io/2017/10/25/child-process/</id>
    <published>2017-10-25T11:45:20.000Z</published>
    <updated>2017-10-26T10:31:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>子进程<code>child_process</code>，使node可以在进程中执行操作，应用系统命令等。nodejs创建子进程有四种方法,分别是</p>
<blockquote>
<p>spawn<br>fork<br>exec<br>execFile。</p>
</blockquote>
<p>后两个函数有回调函数。前两个没有。其中spawn 是最基本的函数，剩下三个其实都是不同程度的封装。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>child_process 会在父进程和衍生的子进程中建立stdin、stdout和stderr的管道。数据能以非阻塞的方式在管道中流通。</p>
<h2 id="四个api"><a href="#四个api" class="headerlink" title="四个api"></a>四个api</h2><p>官网里对这四个指令的解释：<br><code>spawn</code>: 异步衍生一个子进程，不阻塞node.js 事件循环。  </p>
<p><code>fork</code>: 衍生一个新的 Node.js 进程，并通过建立一个 IPC 通讯通道来调用一个指定的模块，该通道允许父进程与子进程之间相互发送信息。  </p>
<p><code>exec</code>:衍生一个 shell 并在 shell 上运行命令，当完成时会传入 stdout 和 stderr 到回调函数。  </p>
<p><code>execFile</code>: 直接衍生命令，且无需先衍生一个 shell。 </p>
<p>简单说说<code>exec</code>与<code>spawn</code>的区别：  </p>
<ul>
<li>exec可以方便的使用复杂的shell命令，而spawn需要拆分shell指令，写在数组参数里。  </li>
<li>exec是将进程输出结果放在buffer中，结果完全返回后，在一次性的将其以回调函数的形式返回给node，这个可能会因为返回过大，超过buffersize而报错。</li>
<li>相反的，spawn从子进程开始执行后，就开始不断将数据从子进程返回给主进程，它通过流的方式发数据传给主进程，从而实现了多进程之间的数据交换。  </li>
<li>总结：如果只是想看运行结果，用exec；需要执行结果的数据，最好用spawn。  </li>
</ul>
<h3 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h3><p><code>child_process.spawn(command, [args], [options])</code>  </p>
<p>command : 主命令<br>args : 其他参数，以及副命令<br>options: 见<a href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options" target="_blank" rel="external">文档</a>中的定义  </p>
<p>// hellow.js</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</div><div class="line"> <span class="comment">// 主命令ls为第一个参数，辅助命令以及路径等参数，都放在参数数组里。</span></div><div class="line"><span class="keyword">const</span> ls = spawn(<span class="string">'ls'</span>, [<span class="string">'-lh'</span>, <span class="string">'/usr'</span>]);</div><div class="line"></div><div class="line">ls.stdout.on(<span class="string">'data'</span>, (data) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`stdout: <span class="subst">$&#123;data&#125;</span>`</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ls.stderr.on(<span class="string">'data'</span>, (data) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`stderr: <span class="subst">$&#123;data&#125;</span>`</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ls.on(<span class="string">'close'</span>, (code) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`child process exited with code <span class="subst">$&#123;code&#125;</span>`</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><p>运行：<br>node hellow.js </p>
<p>等价于运行：<br>ls -lh /usr</p>
<p>输出如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">stdout: total 0</div><div class="line">drwxr-xr-x  1066 root  wheel    35K 10  8 19:37 bin  </div><div class="line">drwxr-xr-x   283 root  wheel   9.4K 10  8 19:37 lib  </div><div class="line">drwxr-xr-x   212 root  wheel   7.0K 10  8 20:27 libexec  </div><div class="line">drwxr-xr-x    23 root  wheel   782B  3 25  2017 local  </div><div class="line">drwxr-xr-x   246 root  wheel   8.2K 10  8 19:36 sbin  </div><div class="line">drwxr-xr-x    46 root  wheel   1.5K  3 25  2017 share  </div><div class="line">drwxr-xr-x     5 root  wheel   170B 12 13  2016 standalone  </div><div class="line"></div><div class="line">child process exited with code 0</div></pre></td></tr></table></figure></p>
<p>example2 模拟ps ax | grep ssh </p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</div><div class="line"><span class="keyword">const</span> ps = spawn(<span class="string">'ps'</span>, [<span class="string">'ax'</span>]);</div><div class="line"><span class="keyword">const</span> grep = spawn(<span class="string">'grep'</span>, [<span class="string">'ssh'</span>]);</div><div class="line"></div><div class="line">ps.stdout.on(<span class="string">'data'</span>, (data) =&gt; &#123;</div><div class="line">  grep.stdin.write(data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ps.stderr.on(<span class="string">'data'</span>, (data) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`ps stderr: <span class="subst">$&#123;data&#125;</span>`</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ps.on(<span class="string">'close'</span>, (code) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (code !== <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`wrong ps process exited with code <span class="subst">$&#123;code&#125;</span>`</span>);</div><div class="line">  &#125;</div><div class="line">  grep.stdin.end();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">grep.stdout.on(<span class="string">'data'</span>, (data) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(data.toString());</div><div class="line">&#125;);</div><div class="line"></div><div class="line">grep.stderr.on(<span class="string">'data'</span>, (data) =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`grep stderr: <span class="subst">$&#123;data&#125;</span>`</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">grep.on(<span class="string">'close'</span>, (code) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (code !== <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`wrong grep process exited with code <span class="subst">$&#123;code&#125;</span>`</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`ps process exited with code <span class="subst">$&#123;code&#125;</span>`</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</code></pre><p>输出<br>    <figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">1915 </span>  ??  S      <span class="number">0</span>:<span class="number">00.03</span> /<span class="keyword">usr</span>/bin/ssh-agent -l</div></pre></td></tr></table></figure></p>
<p>执行  ps ax | grep ssh  </p>
<pre><code><figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">1915 </span>  ??  S      <span class="number">0</span>:<span class="number">00.03</span> /<span class="keyword">usr</span>/bin/ssh-agent -l</div><div class="line"><span class="symbol">57189 </span>s009  S+     <span class="number">0</span>:<span class="number">00.00</span> grep --<span class="keyword">color</span>=<span class="keyword">auto</span> --exclude-dir=.bzr --exclude-dir=<span class="keyword">CVS</span> --exclude-dir=.git --exclude-</div></pre></td></tr></table></figure>
</code></pre><p>shell这个会有两条，是因为后面这个是上面寻找的这条shell的进程  </p>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p><code>child_process.exec(command[, options][, callback])</code><br>回调函数参数如下：  </p>
<ul>
<li>error  </li>
<li>stdout  </li>
<li>stderr   </li>
</ul>
<p>stdout &amp; stderr 就是shell执行后返回的内容，格式默认为utf-8编码的string，可以在options中设置编码方式<code>{encoding: &#39;utf-8&#39;}</code> 。注意<code>maxBuffer: 200 * 1024</code>, 所以如果返回的结果过大，请不要使用exec，会使语句执行错误。</p>
<p>在node v8版本中，可以使用util中的promisify对exec函数进行封装，如果出现error，则直接reject；其他两个作为promise的两个属性，如下代码：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</div><div class="line"><span class="keyword">const</span> exec = util.promisify(<span class="built_in">require</span>(<span class="string">'child_process'</span>).exec);</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">lsExample</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> &#123; stdout, stderr &#125; = <span class="keyword">await</span> exec(<span class="string">'ls'</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'stdout:'</span>, stdout);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'stderr:'</span>, stderr);</div><div class="line">&#125;</div><div class="line">lsExample();</div></pre></td></tr></table></figure>
<p>exec中写复杂的shell语句比较方便。与上面的 spawn进行ps方法的比较：  </p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">exec(<span class="string">'ps ax | grep ssh'</span>, (<span class="built_in">error</span>, <span class="built_in">stdout</span>, <span class="built_in">stderr</span>) =&gt; &#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">error</span>) &#123;</div><div class="line">    console.<span class="built_in">error</span>(<span class="string">'exec error'</span>);</div><div class="line">  &#125;</div><div class="line">  console.<span class="built_in">log</span>(`<span class="built_in">stdout</span>: $&#123;<span class="built_in">stdout</span>&#125;`);</div><div class="line">  console.<span class="built_in">log</span>(`<span class="built_in">stderr</span>: $&#123;<span class="built_in">stderr</span>&#125;`);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>但是输出结果会多一条：<br>应该是exec又新开了一个shell导致的。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">stdou<span class="variable">t:</span>  <span class="number">1915</span>   ??  S      <span class="number">0</span>:<span class="number">00.03</span> /usr/bin/ssh-agent -<span class="keyword">l</span></div><div class="line"><span class="number">69597</span> s008  S+     <span class="number">0</span>:<span class="number">00.00</span> /bin/<span class="keyword">sh</span> -<span class="keyword">c</span> <span class="keyword">ps</span> ax | <span class="keyword">grep</span> ssh</div><div class="line"><span class="number">69599</span> s008  S+     <span class="number">0</span>:<span class="number">00.00</span> <span class="keyword">grep</span> ssh</div></pre></td></tr></table></figure>
<h3 id="execFile"><a href="#execFile" class="headerlink" title="execFile"></a>execFile</h3><p><code>child_process.execFile(file[, args][, options][, callback])</code></p>
<p>options，callback与exec一样，但是输入参数，比较费劲。和spawn一样麻烦了。回调函数都是当子进程停止的时候执行。</p>
<p>execFile是对spawn的封装，多了回调函数。而exec又是对execFile的封装，可以更便利的输入shell指令。</p>
<p>exec执行的时候，可能会遇到问题，这个时候多是maxBuffer 导致的，所以可以设大这个值。</p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p><code>child_process.fork(modulePath[, args][, options])</code></p>
<p>返回的 ChildProcess 会有一个额外的内置的通信通道，它允许消息在父进程和子进程之间来回传递。可以达到启动多个node进行处理的目的。</p>
<p>fork中的options有一些不一样的地方：<br><code>silent</code>：<boolean> 默认是false，即子进程的stdio从父进程继承。如果是true，则直接pipe向子进程的child.stdin、child.stdout等。  </boolean></p>
<p><code>stdio</code>：<array> 如果声明了stdio，则会覆盖silent选项的设置。默认继承父进程的stdio，其实就是父进程所在终端。  </array></p>
<p>其中 stdio可以设置为文件，<br>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// parent.js</span></div><div class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</div><div class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> out = fs.openSync(<span class="string">'./out.log'</span>, <span class="string">'a'</span>); <span class="comment">// out.log 中可以显示child.js 的输出。</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> err = fs.openSync(<span class="string">'./err.log'</span>, <span class="string">'a'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> child = child_process.spawn(<span class="string">'node'</span>, [<span class="string">'child.js'</span>], &#123;</div><div class="line">    <span class="attr">detached</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">stdio</span>: [<span class="string">'ignore'</span>, out, err]</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// child.js</span></div><div class="line"><span class="keyword">var</span> times = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(++times * <span class="number">4</span>);</div><div class="line">  <span class="keyword">if</span> (times &gt;<span class="number">1000</span>)</div><div class="line">    &#123;clearInterval(timer)</div><div class="line">  &#125;</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>如果子进程还在进行，父进程也会一直hold着，这个时候，可以调用子进程的unref()，释放出父进程（parent.js 最后加上 <code>child.unref();</code>注意stdio中参数第一个要设置为ignore, 如上child.js）。但是子进程仍在执行。验证可以在终端执行：<code>ps aux | grep node</code>, 发现会有子进程在进行：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">zzz</span>             70478   0<span class="selector-class">.3</span>  0<span class="selector-class">.1</span>  3094324  24244   ??  <span class="selector-tag">Ss</span>    5<span class="selector-pseudo">:28</span>下午   0<span class="selector-pseudo">:00.08</span> <span class="selector-tag">node</span> <span class="selector-tag">child</span><span class="selector-class">.js</span></div></pre></td></tr></table></figure></p>
<h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><p><code>send</code>：<br>关于父子进程沟通，父进程中，可以调用子进程的send()方法，向子进程发送数据，对应的子进程程序中，调用process.send()方法向父进程发送数据。</p>
<p>code：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// parent.js</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> cp = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</div><div class="line"><span class="keyword">const</span> n = cp.fork(<span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/child.js`</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</div><div class="line"></div><div class="line">n.on(<span class="string">'message'</span>, <span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'PARENT got message:'</span>, m);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span>);</div><div class="line"></div><div class="line">n.send(&#123; hello: <span class="string">'world'</span> &#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'3'</span>);</div><div class="line"></div><div class="line"><span class="comment">// child.js</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'4'</span>);</div><div class="line">process.on(<span class="string">'message'</span>, <span class="function">(<span class="params">m</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'CHILD got message:'</span>, m);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">process.send(&#123; foo: <span class="string">'bar'</span> &#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'5'</span>);</div></pre></td></tr></table></figure>
<p>child先发送，parent收到结果，然后parent发送，child收到结果。结果如下： </p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">node p.js       </div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">5</span></div><div class="line">PARENT got message: &#123; foo: <span class="string">'bar'</span> &#125;</div><div class="line">CHILD got message: &#123; hello: <span class="string">'world'</span> &#125;</div><div class="line"></div><div class="line">```   </div><div class="line"></div><div class="line"></div><div class="line">`disconnect`：</div><div class="line">在父进程中调用 subprocess.disconnect() 或在子进程中调用 process.disconnect() 后会触发 <span class="string">'disconnect'</span> 事件。 断开后就不能再发送或接收信息，且 subprocess.connected 属性会被设为 false。  </div><div class="line"></div><div class="line"><span class="keyword">code</span>：</div></pre></td></tr></table></figure>
<p>// parent.js<br>const cp = require(‘child_process’);<br>const n = cp.fork(<code>${__dirname}/child.js</code>);</p>
<p>console.log(‘1’);</p>
<p>n.on(‘message’, (m) =&gt; {<br>    console.log(‘in Parent child is connect’, n.connected);<br>  console.log(‘PARENT got message:’, m);<br>});</p>
<p>console.log(‘2’);</p>
<p>n.send({ hello: ‘world’ });<br>n.on(‘disconnect’, () =&gt; {<br>    console.log(‘in parent, child send disconnect signal’, n.connected);<br>})<br>console.log(‘3’);</p>
<p>// child.js</p>
<p>console.log(‘4’);<br>process.on(‘message’, (m) =&gt; {<br>  console.log(‘CHILD got message:’, m);<br>  // console.log(‘in child, child send disconnect’);<br>  // process.disconnect();</p>
<p>});</p>
<p>process.send({ foo: ‘bar’ });<br>console.log(‘5’);</p>
<p>process.disconnect();</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出的是：</div></pre></td></tr></table></figure>
<p>1<br>2<br>3<br>4<br>5<br>in Parent child is connect true<br>PARENT got message: { foo: ‘bar’ }<br>in parent, child send disconnect signal false</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果把注释打开，最后的disconnect去掉，则会在parent接收到message后，先输出child这边的 `<span class="keyword">in</span> child, child send disconnect`,在输出`<span class="keyword">in</span> parent, child send disconnect signal false` ...</div><div class="line"></div><div class="line">注意如果child是一个会执行很久的函数，此时他依然是可以在执行的，只是父进程监控不到他了~~~，要注意！如果不想让子进程也执行了，调用kill既可。</div><div class="line"></div><div class="line">`kill`</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#### 事件：</span></div><div class="line">- message</div><div class="line">`on(<span class="string">'message'</span>, <span class="keyword">func</span>)` 分别用on方法来监听，对方发送的数据。</div><div class="line">- close</div><div class="line">- <span class="keyword">exit</span></div><div class="line">- disconnect  </div><div class="line"></div><div class="line">close 和<span class="keyword">exit</span> 当子进程退出的时候都会监控到，两者的结果基本相似。close，是当stdio流关闭时触发。 一般子进程退出了，stdio一定退出了。  </div><div class="line"> </div><div class="line">对于<span class="keyword">exit</span>，如果子进程是自己退出的，那么code就是退出码，否则为null；如果子进程是通过信号结束的，那么，signal就是结束进程的信号，否则为null。这两者中，一者肯定不为null。</div><div class="line"></div><div class="line">例子：</div></pre></td></tr></table></figure>
<p>// parent.js</p>
<p>const cp = require(‘child_process’);<br>const n = cp.fork(<code>${__dirname}/child.js</code>);</p>
<p>console.log(‘1’);</p>
<p>n.on(‘message’, (m) =&gt; {<br>    console.log(‘in Parent child is connect’, n.connected);<br>  console.log(‘PARENT got message:’, m);<br>});</p>
<p>console.log(‘2’);</p>
<p>n.send({ hello: ‘world’ });<br>n.on(‘exit’, (cc, signal) =&gt; {<br>    console.log(‘in parent, child send exit signal’,cc, signal);<br>})</p>
<p>n.on(‘close’, (cc, signal) =&gt; {<br>    console.log(‘in parent, child send close signal’, cc, signal);<br>})</p>
<p>console.log(‘3’);</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>// child.js</p>
<p>console.log(‘4’);<br>process.on(‘message’, (m) =&gt; {<br>  console.log(‘CHILD got message:’, m);</p>
<p>});</p>
<p>process.send({ foo: ‘bar’ });<br>console.log(‘5’);</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">终端运行：` <span class="keyword">node</span> <span class="title">parent</span>.js`</div><div class="line">输出：</div></pre></td></tr></table></figure>
<p>1<br>2<br>3<br>4<br>5<br>in Parent child is connect true<br>PARENT got message: { foo: ‘bar’ }<br>CHILD got message: { hello: ‘world’ }<br><figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="autohotkey">此时，再开一个终端，使用`ps ax | grep node` 找到child.js 的进程，执行`kill -<span class="number">9</span> pid` </span></div><div class="line"></div><div class="line">原来终端会显示</div></pre></td></tr></table></figure></p>
<p>in parent, child send exit signal null SIGKILL<br>in parent, child send close signal null SIGKILL</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果是在child<span class="selector-class">.js</span> 中故意写一些错误，会监控到<span class="selector-tag">code</span> 为<span class="number">1</span> ，输出：</div></pre></td></tr></table></figure>
<p>in parent, child send exit signal 1 null<br>in parent, child send close signal 1 null</p>
<p>```</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://nodejs.org/api/child_process.html#child_process_event_close" target="_blank" rel="external">官方文档</a>  </p>
<p><a href="https://segmentfault.com/a/1190000007735211#articleHeader18" target="_blank" rel="external">参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;子进程&lt;code&gt;child_process&lt;/code&gt;，使node可以在进程中执行操作，应用系统命令等。nodejs创建子进程有四种方法,分别是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;spawn&lt;br&gt;fork&lt;br&gt;exec&lt;br&gt;execFile。&lt;/p&gt;
&lt;/b
    
    </summary>
    
    
      <category term="nodejs" scheme="https://misssweety.github.io/tags/nodejs/"/>
    
      <category term="js" scheme="https://misssweety.github.io/tags/js/"/>
    
      <category term="shell" scheme="https://misssweety.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>d3-scale</title>
    <link href="https://misssweety.github.io/2017/09/21/d3-scale/"/>
    <id>https://misssweety.github.io/2017/09/21/d3-scale/</id>
    <published>2017-09-21T06:54:58.000Z</published>
    <updated>2017-09-22T08:59:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>scale</code>缩放也叫比例尺。是可视化的基本，使抽象的数据，转换成可视化的代表，比如宽高，位置或者颜色等。</p>
<h2 id="输入-amp-输出"><a href="#输入-amp-输出" class="headerlink" title="输入 &amp; 输出"></a>输入 &amp; 输出</h2><p><code>scale</code>缩放，其实是一种mapping。<br>将输入的数据转换成对应的想要的输出的数据形式。  </p>
<p>既然是转换，那就需要输入和输出。</p>
<p>输入是放入<code>domain</code>函数的参数。<br>输出时放入<code>range</code> 函数的参数。  </p>
<p><img src="./scale.png" width="400px">  </p>
<p><strong> 妙记 </strong> ID OR<br>其实每个scale函数返回的都是函数，需要的参数就是实际展示的数据。</p>
<p>先举几个基本例子：  </p>
<ul>
<li><p>人口范围50万-130万  对应 输出长度为 500像素范围。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> newRamp = d3.scale.linear().domain([<span class="number">500000</span>,<span class="number">13000000</span>]).range([<span class="number">0</span>, <span class="number">500</span>]);</div><div class="line"></div><div class="line">newRamp(<span class="number">1000000</span>);   <span class="comment">// return 20;说明，人数为100万时对应长度为20像素</span></div><div class="line">newRamp(<span class="number">9000000</span>);</div><div class="line">newRamp.invert(<span class="number">313</span>); <span class="comment">// 知道像素长度313px，想知道他对应的人口数。</span></div></pre></td></tr></table></figure>
</li>
<li><p>人口范围50万-130万  对应 输出颜色 蓝色-红色</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var newRamp = d3.scale.linear().domain([500000,13000000]).range(["blue",</div><div class="line">"red"]);</div><div class="line"></div><div class="line">newRamp(1000000);   // return #ad0052;说明，人数为100万时对应颜色</div><div class="line">newRamp(9000000);</div><div class="line">newRamp.invert(#ad0052); //NaNinvert适应于输出为数字的比例转换。</div></pre></td></tr></table></figure>
<ul>
<li>示意： <img src="./continue.png" width="400px"></li>
</ul>
</li>
<li><p>离散型，将一组数据分为三类</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sampleArray = [<span class="number">423</span>,<span class="number">124</span>,<span class="number">66</span>,<span class="number">424</span>,<span class="number">58</span>,<span class="number">10</span>,<span class="number">900</span>,<span class="number">44</span>,<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> qScale = d3.scale.quantile().domain(sampleArray).range([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]);</div><div class="line">qScale(<span class="number">423</span>);  <span class="comment">// 2</span></div><div class="line">qScale(<span class="number">20</span>);   <span class="comment">// 0</span></div><div class="line">qScale(<span class="number">10000</span>);  <span class="comment">//2</span></div></pre></td></tr></table></figure>
<ul>
<li>示意：<img src="./quantile.png" width="400px"></li>
</ul>
</li>
</ul>
<h2 id="scale-分类"><a href="#scale-分类" class="headerlink" title="scale 分类"></a>scale 分类</h2><p>按照我个人的偏好分类如下：</p>
<blockquote>
<p>输入输出都连续[linear, power, log]<br>输出离散[quantize scale quantile]<br>输入输出都离散[band, point, ordinal]<br>颜色相关[scaleSequential, category]<br>时间相关[scaleTime 属于连续型]</p>
</blockquote>
<h3 id="输入输出都连续"><a href="#输入输出都连续" class="headerlink" title="输入输出都连续"></a>输入输出都连续</h3><ul>
<li>scaleLinear</li>
<li>scalePower</li>
<li>scaleLog</li>
<li>scaleSqrt</li>
<li>scaleTime</li>
<li><p>scaleSequential</p>
<p>后两个单独做解释。<br><code>线性scaleLinear</code>， 没什么可说的，就是输出与输入呈线性相关。<code>y = ax + b</code><br><code>幂指数scalePower</code>，输出与输入的幂指数呈正相关。<code>y = m * x^k + b</code><br><code>平方根缩放scaleLog</code>，就是幂指数中k = 0.5。关于这个，一般用于使用面积来表达数据值的大小时。所以该scale函数的结果可以作为r的值。<br><code>对数缩放scaleLog</code>， 输出与输入的对数呈正相关。 <code>y = m * log(x) + b</code></p>
<p>参考代码：<a href="https://github.com/MissSweety/practiceD3" target="_blank" rel="external">d3-practice</a></p>
<p>关于连续型的缩放，还有其他几个参数：  </p>
</li>
<li><code>Clamp()</code>：控制当输入超过range的情况。默认是false，如果超过range，则会自动按比例换算成domain以外的值。设为true则会严格控制结果在对应的domain中。</li>
<li><code>Nice()</code>：主要用在使用真实数据来设置range的时候，<code>d3.extent(data)</code>会自动读取min&amp;max作为范围。但是如果作为坐标轴，可能数据看起来不是很好看，设置成nice()它会自动向上取整。</li>
<li><code>invert()</code>：可以根据给出的输出值，来计算输入值。【注意】：domain必须是数字类型的</li>
<li><p><code>range</code>: 支持多个value。同时domain也要输入多个参数。相互为边界，实现缩放。例子：（见下面的多段缩放）  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 位置缩放</span></div><div class="line"><span class="keyword">const</span> firstScale = d3.scaleLinear()</div><div class="line">  .domain([<span class="number">0</span>, <span class="number">10</span>])</div><div class="line">  .range([<span class="number">0</span>, <span class="number">400</span>]);</div><div class="line"><span class="comment">// 面积缩放</span></div><div class="line"><span class="keyword">const</span> sqrScale = d3.scaleSqrt()</div><div class="line">  .domain([<span class="number">0</span>, <span class="number">10</span>])</div><div class="line">  .range([<span class="number">0</span>, <span class="number">40</span>]);</div><div class="line"><span class="comment">// 多段缩放</span></div><div class="line"><span class="keyword">const</span> fourthScale = d3.scaleLinear()</div><div class="line">  .domain([<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>])</div><div class="line">  .range([<span class="string">'purple'</span>,<span class="string">'white'</span>, <span class="string">'lightgreen'</span>]);</div><div class="line"></div><div class="line">canvas.selectAll(<span class="string">'.fourthScale'</span>)</div><div class="line">  .data(testData)</div><div class="line">  .enter()</div><div class="line">  .append(<span class="string">'circle'</span>)</div><div class="line">  .attr(<span class="string">'class'</span>, <span class="string">'fourthScale'</span>)</div><div class="line">  .attr(<span class="string">'r'</span>, d =&gt; sqrScale(d))</div><div class="line">  .attr(<span class="string">'cx'</span>, d =&gt; firstScale(d))</div><div class="line">  .attr(<span class="string">'cy'</span>, <span class="number">200</span>)</div><div class="line">  .attr(<span class="string">'fill'</span>, d =&gt; fourthScale(d));</div></pre></td></tr></table></figure>
</li>
</ul>
<p>结果如下：<img src="./scaleMult.png" width="400px"></p>
<h3 id="输入连续，输出离散"><a href="#输入连续，输出离散" class="headerlink" title="输入连续，输出离散"></a>输入连续，输出离散</h3><ul>
<li><p>scaleQuantize<br>输入可以是连续范围，输出是离散的值，在range中规定。输入会按照输出数组的长度n分成n份。调用的时候，根据输入判定落在那个区间内，就输出对应的range中的值。<br>例子:  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> quantizeScale = d3.scaleQuantize()</div><div class="line">  .domain([<span class="number">0</span>, <span class="number">100</span>])</div><div class="line">  .range([<span class="string">'purple'</span>, <span class="string">'pink'</span>, <span class="string">'lightgreen'</span>]);</div><div class="line"></div><div class="line">quantizeScale(<span class="number">10</span>);   <span class="comment">// returns 'purple'</span></div><div class="line">quantizeScale(<span class="number">30</span>);  <span class="comment">// returns 'purple'</span></div><div class="line">quantizeScale(<span class="number">90</span>);  <span class="comment">// returns 'lightgreen'</span></div></pre></td></tr></table></figure>
</li>
<li><p>scaleQuantile<br>与上面类似，但是输入可以是随机的数组，d3会主动将domain中的数组排序，然后按照range的参数长度n来将排序后的输入分成n组，然后，按照下标值将domain内容均分，然后分别对应range中的内容。（当数量不均分时，可通过<code>quantileScale.quantiles()</code>查看边界分类）。 例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myData = [<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>];</div><div class="line"></div><div class="line"><span class="keyword">var</span> linearScale = d3.scaleLinear()</div><div class="line">  .domain([<span class="number">0</span>, <span class="number">100</span>])</div><div class="line">  .range([<span class="number">0</span>, <span class="number">600</span>]);</div><div class="line"></div><div class="line"><span class="keyword">var</span> quantileScale = d3.scaleQuantile()</div><div class="line">  .domain(myData)</div><div class="line">  .range([<span class="string">'lightblue'</span>, <span class="string">'orange'</span>, <span class="string">'lightgreen'</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(quantileScale.quantiles())  <span class="comment">// [4.666666666666666, 8]</span></div><div class="line">d3.select(<span class="string">'#wrapper'</span>)</div><div class="line">  .selectAll(<span class="string">'circle'</span>)</div><div class="line">  .data([<span class="number">0</span>, <span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,<span class="number">10</span>, <span class="number">20</span>])</div><div class="line">  .enter()</div><div class="line">  .append(<span class="string">'circle'</span>)</div><div class="line">  .attr(<span class="string">'r'</span>, <span class="number">3</span>)</div><div class="line">  .attr(<span class="string">'cx'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> linearScale(d);</div><div class="line">  &#125;)</div><div class="line">  .style(<span class="string">'fill'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> quantileScale(d);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>scaleThreshold<br>将domain中的数据映射到range中的颜色或者离散值。其实domain规定的数据的门限值，就是range中范围的分界点。domain中的数组长度要比range的少一位，这样才能将所有数据包含。看例子：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> thresholdScale = d3.scaleThreshold()</div><div class="line">  .domain([<span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>])</div><div class="line">  .range([<span class="string">'#purple'</span>, <span class="string">'lightblue'</span>, <span class="string">'orange'</span>, <span class="string">'#red'</span>]);</div><div class="line"></div><div class="line">thresholdScale(<span class="number">-10</span>);  <span class="comment">// returns '#purple'</span></div><div class="line">thresholdScale(<span class="number">20</span>);   <span class="comment">// returns 'lightblue'</span></div><div class="line">thresholdScale(<span class="number">70</span>);   <span class="comment">// returns 'orange'</span></div><div class="line">thresholdScale(<span class="number">110</span>);  <span class="comment">// returns '#red'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="输入输出都离散"><a href="#输入输出都离散" class="headerlink" title="输入输出都离散"></a>输入输出都离散</h3><ul>
<li><p>scaleOrdinal<br>domain和range规定的内容是一一对应的。如果range长度不够，则重复range。如果输入的数据布在domain中，则会将range中的第一个值赋给他。这个可以通过设置<code>.unknown(&#39;xxxx&#39;)</code>来自定义。</p>
</li>
<li><p>scaleBand<br>domain规定每个band的值，range中规定整个柱形图的长度，也就是多个柱子和间隙的总和。当输入数据时，会返回对应的柱子的宽度以及起始位置。柱子宽度通过<code>d3.scaleBand().bandwidth()</code>  </p>
<blockquote>
<p>bandwidth() 柱子宽度<br>paddingInner() 每个band间的距离<br>paddingOuter() 第一个子band前面的padding和最后一个子band后面padding 之和。<br>常用在柱形图，条形图中。自动生成柱子和间隙的位置。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>scalePoint<br>按照给出的domain将range范围分为对应的n-1份。两边的间隔可以通过<code>d3.scalePoint.padding()</code>来计算。而间隔的值可通过<code>step()</code>获取</p>
<p>一般输入输出都离散，常用在坐标轴，颜色中。</p>
</li>
</ul>
<h3 id="颜色相关"><a href="#颜色相关" class="headerlink" title="颜色相关"></a>颜色相关</h3><ul>
<li><p>scaleSequential<br>这个和线性的类似，只不过range是不能配置的，而是通过interpolator()来对应的。其中，插值函数是接收0，1之间的输入，输出两个数字，颜色或者字符之间的插值。<br>这个一般用于热力图等关于颜色的计算中，而且<code>d3</code>规定了一些内置的颜色插值。<a href="https://bl.ocks.org/d3indepth/89ced137bece23b908cf51580d5e082d" target="_blank" rel="external">代码参考</a><br>如下图：<br><img src="./interpolate.png" width="500px"></p>
</li>
<li><p>category Scales 用于 scaleOrdinal中<br>根据预置的颜色集合，生成具体的颜色块。更多颜色参考：<a href="https://github.com/d3/d3-scale-chromatic" target="_blank" rel="external">https://github.com/d3/d3-scale-chromatic</a><br>使用方法：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> color = d3.scaleOrdinal(d3.schemeCategory10);</div><div class="line">...</div><div class="line"></div><div class="line">canvas.selectAll(<span class="string">'.test'</span>)</div><div class="line">  .data(testData)</div><div class="line">  .enter()</div><div class="line">  .append(<span class="string">'circle'</span>)</div><div class="line">  .attr(<span class="string">'class'</span>, <span class="string">'test'</span>)</div><div class="line">  .attr(<span class="string">'fill'</span>, d =&gt; color(d));</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h3><ul>
<li><p>scaleTime<br>主要用于与时间相关的应用上。可以将连续的时间转换成range中的范围，可以是长度颜色等等。<br>可以通过scaleTime获取一些数据，用<code>ticks()</code>。比如想要获取domain中每十天的值，可以使用如下代码：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> timescale = d3.scaleTime()</div><div class="line">  .domain([<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2017</span>, <span class="number">7</span>, <span class="number">1</span>), <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">1</span>)])</div><div class="line">  .range([<span class="number">0</span>, <span class="number">600</span>]);</div><div class="line"></div><div class="line"><span class="keyword">const</span> infor = timescale.ticks(d3.timeDay.every(<span class="number">10</span>));</div></pre></td></tr></table></figure>
<p>以上输出的是：<br>August 01<br>August 11<br>August 21<br>August 31<br>September 01<br>September 11<br>September 21<br>October 01<br>更多时间tick可以参考：<a href="https://github.com/d3/d3-scale#time-scales" target="_blank" rel="external">https://github.com/d3/d3-scale#time-scales</a><br>时间格式输出，参考：<a href="https://github.com/d3/d3-time-format" target="_blank" rel="external">https://github.com/d3/d3-time-format</a></p>
</li>
</ul>
<blockquote>
<p><a href="http://d3indepth.com/scales/" target="_blank" rel="external">参考一</a><br><a href="https://github.com/d3/d3-scale" target="_blank" rel="external">参考二</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;scale&lt;/code&gt;缩放也叫比例尺。是可视化的基本，使抽象的数据，转换成可视化的代表，比如宽高，位置或者颜色等。&lt;/p&gt;
&lt;h2 id=&quot;输入-amp-输出&quot;&gt;&lt;a href=&quot;#输入-amp-输出&quot; class=&quot;headerlink&quot; title=&quot;输入
    
    </summary>
    
    
      <category term="d3" scheme="https://misssweety.github.io/tags/d3/"/>
    
      <category term="学习笔记" scheme="https://misssweety.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>html5-小插件</title>
    <link href="https://misssweety.github.io/2017/09/21/html5-%E5%B0%8F%E6%8F%92%E4%BB%B6/"/>
    <id>https://misssweety.github.io/2017/09/21/html5-小插件/</id>
    <published>2017-09-21T02:56:33.000Z</published>
    <updated>2017-09-21T03:38:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>有些时候会遇到上传文件和下载的需求，一般原生html样式并不能满足要求。所以总结了一下平时常用的图片上传，问价上传下载等简单的小需求的实现。</p>
<p>包含图片上传，限制图片的大小。<br>文件上传和下载（不用form 标签）<br>之前做地图需求的，字符颜色转rgb的简单转化。  </p>
<p>大部分的组件渲染是基于react，所以写法都是react相关的。  </p>
<h2 id="上传图片及检查大小"><a href="#上传图片及检查大小" class="headerlink" title="上传图片及检查大小"></a>上传图片及检查大小</h2><p>本示例是限制了上传图片的大小，<code>maxWidth: 600</code>, <code>maxHeight: 300</code>, <code>maxSize: 200</code>, 上传前前端先做检查。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> React, &#123; Component, PropTypes &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> imageStyles <span class="keyword">from</span> <span class="string">'../styles/image.css'</span>;</div><div class="line"><span class="keyword">import</span> &#123; imageSizeCheck, newImageSrc &#125; <span class="keyword">from</span> <span class="string">'../utils/imgCheck.js'</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Image 组件，支持上传图片</div><div class="line"> *</div><div class="line"> * @props   onImageChange   传回上传的图片的地址</div><div class="line"> * @props   onError         上传失败的处理</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>(...arguments);</div><div class="line">    <span class="comment">// 用于自动设置图片高度</span></div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      <span class="attr">imageHeight</span>: <span class="number">180</span>,</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  componentDidMount() &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">'undefined'</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">const</span> imageHeight = <span class="keyword">this</span>.refs.imageContainer.offsetWidth * <span class="number">0.618</span>;</div><div class="line">    <span class="keyword">this</span>.setState(&#123; imageHeight &#125;);</div><div class="line">  &#125;</div><div class="line">  handleClick() &#123;</div><div class="line">    <span class="comment">// 模拟点击上传图片按钮</span></div><div class="line">    <span class="keyword">this</span>.refs.file.click();</div><div class="line">  &#125;</div><div class="line">  handleChange() &#123;</div><div class="line">    <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData();</div><div class="line">    formData.append(<span class="string">'file'</span>, <span class="keyword">this</span>.refs.file.files[<span class="number">0</span>]);</div><div class="line">    <span class="comment">// 检验图片大小</span></div><div class="line">    <span class="keyword">this</span>.imageCheck(<span class="keyword">this</span>.props.subtype, <span class="keyword">this</span>.refs.file.files[<span class="number">0</span>], (err, res) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="keyword">const</span> msg = <span class="string">`请选择<span class="subst">$&#123;res.maxWidth&#125;</span>*<span class="subst">$&#123;res.maxHeight&#125;</span>像素且大小不超过<span class="subst">$&#123;res.maxSize&#125;</span>k的图片上传`</span>;</div><div class="line">        <span class="built_in">window</span>.alert(<span class="string">`您的图片为<span class="subst">$&#123;res.height&#125;</span>*<span class="subst">$&#123;res.width&#125;</span>像素,大小为<span class="subst">$&#123;res.size&#125;</span>k. <span class="subst">$&#123;msg&#125;</span>`</span>);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 成功的操作</span></div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  imageCheck(subtype, file, cb) &#123;</div><div class="line">  <span class="comment">// 可修改图片检查的大小和尺寸。</span></div><div class="line">    <span class="keyword">const</span> sixthree = &#123;</div><div class="line">      <span class="attr">imgFile</span>: file,</div><div class="line">      <span class="attr">maxWidth</span>: <span class="number">600</span>,</div><div class="line">      <span class="attr">maxHeight</span>: <span class="number">300</span>,</div><div class="line">      <span class="attr">maxSize</span>: <span class="number">200</span>,</div><div class="line">    &#125;;</div><div class="line">    imageSizeCheck(sixthree, (err, res) =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="keyword">return</span> cb(err, res);</div><div class="line">      &#125;</div><div class="line">      imageSizeCheck(&#123;</div><div class="line">        <span class="attr">imgFile</span>: file,</div><div class="line">        <span class="attr">maxWidth</span>: <span class="number">700</span>,</div><div class="line">        <span class="attr">maxHeight</span>: <span class="number">350</span>,</div><div class="line">        <span class="attr">maxSize</span>: <span class="number">200</span>,</div><div class="line">      &#125;, cb);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span></span></span></div><div class="line">        <span class="attr">ref</span>=<span class="string">"imageContainer"</span></div><div class="line">        <span class="attr">className</span>=<span class="string">&#123;imageStyles.imageContainer&#125;</span>&gt;</div><div class="line">        <span class="tag">&lt;<span class="name">div</span></span></div><div class="line">          <span class="attr">className</span>=<span class="string">&#123;imageStyles.imageUpload&#125;</span></div><div class="line">          <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span></div><div class="line">          <span class="attr">style</span>=<span class="string">&#123;&#123;</span></div><div class="line">            <span class="attr">height:</span> <span class="attr">this.state.imageHeight</span>,</div><div class="line">            <span class="attr">lineHeight:</span> <span class="attr">this.state.imageHeight</span> + '<span class="attr">px</span>',</div><div class="line">          &#125;&#125;</div><div class="line">        &gt;点击上传图片</div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">"file"</span> <span class="attr">className</span>=<span class="string">&#123;imageStyles.inputFile&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange.bind(this)&#125;</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/*"</span>/&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default Image;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">image</span><span class="selector-class">.css</span></div><div class="line"><span class="selector-class">.imageContainer</span> &#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.imageContainerHasImg</span> <span class="selector-class">.imageUpload</span> &#123;</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.imageUpload</span> &#123;</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;</div><div class="line">  <span class="attribute">background</span>: <span class="number">#999</span>;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">color</span>: white;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</div><div class="line">  <span class="attribute">cursor</span>: pointer;</div><div class="line">  <span class="attribute">transition</span>: opacity <span class="number">0.3s</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.imageUpload</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">0.6</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="file"]</span><span class="selector-class">.inputFile</span> &#123;</div><div class="line">  <span class="attribute">display</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.img</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">imageCheck.js</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">imageSizeCheck</span>(<span class="params">&#123; imgFile, maxWidth, maxHeight, maxSize &#125;, cb</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> res = &#123;</div><div class="line">    maxWidth,</div><div class="line">    maxHeight,</div><div class="line">    maxSize,</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">const</span> size = <span class="built_in">Math</span>.floor(imgFile.size / <span class="number">1024</span>);</div><div class="line">  <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();</div><div class="line">  reader.onload = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> data = e.target.result;</div><div class="line">    <span class="keyword">const</span> tempImg = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</div><div class="line">    tempImg.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      res.width = tempImg.width;</div><div class="line">      res.height = tempImg.height;</div><div class="line">      res.size = size;</div><div class="line">      <span class="keyword">if</span> (res.width &gt; maxWidth || res.height &gt; maxHeight || res.size &gt; maxSize) &#123;</div><div class="line">        cb(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'上传失败'</span>), res);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        cb(<span class="literal">null</span>, <span class="literal">null</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">    tempImg.src = data;</div><div class="line">  &#125;;</div><div class="line">  reader.readAsDataURL(imgFile);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>文件上传有默认的样式，一般都是不满足的，所以用一下方式修改。后面的span用于展示文件内容。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"monitor-clickUploader"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">"monitor-upload-btn"</span>&gt;</span> + 上传商户id<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">ref</span>=<span class="string">&#123;input</span> =&gt;</span> &#123; this.upload = input; &#125; &#125; onChange=&#123;() =&gt; this.handleFileChanged()&#125;/&gt;</div><div class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;this.state.fileName&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="selector-class">.monitor-clickUploader</span> &#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">overflow</span>: hidden;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">10px</span> <span class="number">0px</span> <span class="number">20px</span>;</div><div class="line">  <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.monitor-clickUploader</span> <span class="selector-tag">input</span> &#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">cursor</span>: pointer;</div><div class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">filter</span>: <span class="built_in">alpha</span>(opacity=0);</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.monitor-upload-btn</span> &#123;</div><div class="line">  <span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#3bb4f1</span>;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#3bb4f1</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">4px</span> <span class="number">10px</span> <span class="number">4px</span> <span class="number">10px</span>;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</div><div class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</div><div class="line">  <span class="attribute">cursor</span>: pointer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">handleFileChanged() &#123;</div><div class="line">  <span class="keyword">const</span> fileList = <span class="keyword">this</span>.upload.files;</div><div class="line">  <span class="keyword">if</span> (fileList.length &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">fileName</span>: fileList[<span class="number">0</span>].name&#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>展示样式：<br><img src="./button.png"></p>
<h2 id="文件上传提交"><a href="#文件上传提交" class="headerlink" title="文件上传提交"></a>文件上传提交</h2><p>上传文件需要formdata格式，但是不用自己显式的写明content-type,有时会出问题。不需要写form，可以这样写。  </p>
<p>文件上传的html同上。<br>触发上传：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;button</div><div class="line">  style=&#123;&#123; marginLeft: 70, marginTop: 20 &#125;&#125;</div><div class="line">  type="button" </div><div class="line">  className="btn Btn"</div><div class="line">  disabled=&#123;startDate === "" || endDate === "" || poiResultList.length &lt;=0 || monitorIndexList.length &lt;= 0&#125;</div><div class="line">  onClick=&#123;() =&gt; this.handleFileUpload()&#125;</div><div class="line">&gt;开始监控&lt;/button&gt;</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">handleFileUpload() &#123;</div><div class="line">    <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData();</div><div class="line">    <span class="keyword">const</span> fileList = <span class="keyword">this</span>.upload.files;</div><div class="line">    <span class="keyword">if</span> (fileList.length &gt; <span class="number">0</span>) &#123;</div><div class="line">      formData.append(<span class="string">'uploadFile'</span>, fileList[<span class="number">0</span>]);</div><div class="line">      <span class="keyword">this</span>.props.postMonitor(&#123; formData &#125; )</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//postMonitor里发送formdata文件。xhr就行。</span></div></pre></td></tr></table></figure>
<h2 id="前端实现下载功能"><a href="#前端实现下载功能" class="headerlink" title="前端实现下载功能"></a>前端实现下载功能</h2><h3 id="2进制文件"><a href="#2进制文件" class="headerlink" title="2进制文件"></a>2进制文件</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// render部分：</div><div class="line">&lt;div</div><div class="line">  style=&#123;&#123; display: canDownload ? 'inline-block' : 'none' &#125;&#125;</div><div class="line">  className=&#123;listcss.download&#125;</div><div class="line">  onClick=&#123;this.handleDownload&#125;</div><div class="line">&gt;导出数据&lt;/div&gt;</div><div class="line"> </div><div class="line">// 处理：</div><div class="line">handleDownload() &#123;</div><div class="line">    const &#123; download &#125; = this.props;</div><div class="line">    if (download &amp;&amp; download.length &gt; 0) &#123;</div><div class="line">      const u8arr = new Uint8Array(download.length);</div><div class="line">      let length = download.length;</div><div class="line">      while (length--) &#123;</div><div class="line">        u8arr[length] = download[length];</div><div class="line">      &#125;</div><div class="line">      const blob = new Blob([u8arr.buffer], &#123; type: 'application/vnd.ms-excel' &#125;);</div><div class="line">      const fileName = 'orderData.xls';</div><div class="line">      downBinaryToExcel(blob, fileName);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">export const downBinaryToExcel = (blob, fileName) =&gt; &#123;</div><div class="line">  if (window.navigator.msSaveOrOpenBlob) &#123;</div><div class="line">    navigator.msSaveBlob(blob, fileName);</div><div class="line">  &#125; else &#123;</div><div class="line">    const link = document.createElement('a');</div><div class="line">    link.href = window.URL.createObjectURL(blob);</div><div class="line">    link.download = fileName;</div><div class="line">    link.click();</div><div class="line">    window.URL.revokeObjectURL(link.href);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="数组或者字符串内容下载"><a href="#数组或者字符串内容下载" class="headerlink" title="数组或者字符串内容下载"></a>数组或者字符串内容下载</h3><p>主要是拼接成excel需要的格式, 然后放在blob的内容里。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">const</span> headerInfo = <span class="string">`&lt;?xml version="1.0"?&gt;</span></div><div class="line">&lt;ss:Workbook xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet"&gt;</div><div class="line">&lt;ss:Worksheet ss:Name="Sheet1"&gt;</div><div class="line">&lt;ss:Table&gt;\n</div><div class="line">`;</div><div class="line"></div><div class="line"><span class="keyword">const</span> footerInfo = <span class="string">`</span></div><div class="line">&lt;/ss:Table&gt;</div><div class="line">&lt;/ss:Worksheet&gt;</div><div class="line">&lt;/ss:Workbook&gt;`;</div><div class="line"></div><div class="line"><span class="comment">// 自己组织数据结构，包括一行表头，和每行的数据。</span></div><div class="line"><span class="keyword">const</span> composeRow = R.compose(</div><div class="line">  <span class="function"><span class="params">item</span> =&gt;</span> <span class="string">`&lt;ss:Row&gt;\n<span class="subst">$&#123;item&#125;</span>&lt;/ss:Row&gt;\n`</span>,</div><div class="line">  R.join(<span class="string">''</span>),</div><div class="line">  R.map(</div><div class="line">    <span class="function"><span class="params">item</span> =&gt;</span></div><div class="line">      <span class="string">`  &lt;ss:Cell&gt;</span></div><div class="line">    &lt;ss:Data ss:Type="<span class="subst">$&#123;R.is(<span class="built_in">Number</span>, item)</span></div><div class="line">      ? <span class="string">'Number'</span></div><div class="line">      : <span class="string">'String'</span>&#125;"&gt;<span class="subst">$&#123;item&#125;</span>&lt;/ss:Data&gt;</div><div class="line">  &lt;/ss:Cell&gt;</div><div class="line">`</div><div class="line">  )</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">const</span> rows = FUNC（composeRow）<span class="comment">// 具体的自己写吧</span></div><div class="line"><span class="keyword">const</span> xml = <span class="string">`<span class="subst">$&#123;headerInfo&#125;</span><span class="subst">$&#123;rows&#125;</span><span class="subst">$&#123;footerInfo&#125;</span>`</span>;</div></pre></td></tr></table></figure>
<h2 id="HEX-TO-RGB"><a href="#HEX-TO-RGB" class="headerlink" title="HEX TO RGB"></a>HEX TO RGB</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> hexToRgb = <span class="function"><span class="params">hex</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> rgb = [];</div><div class="line">  <span class="keyword">let</span> letters = hex.substr(<span class="number">1</span>);</div><div class="line">  <span class="keyword">if</span> (letters.length === <span class="number">3</span>) &#123;</div><div class="line">    letters = letters.replace(<span class="regexp">/(.)/g</span>, <span class="string">'$1$1'</span>);</div><div class="line">  &#125;</div><div class="line">  letters.replace(<span class="regexp">/../g</span>, color =&gt; &#123; rgb.push(<span class="built_in">parseInt</span>(color, <span class="number">0x10</span>)); &#125;);</div><div class="line">  <span class="keyword">return</span> rgb;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些时候会遇到上传文件和下载的需求，一般原生html样式并不能满足要求。所以总结了一下平时常用的图片上传，问价上传下载等简单的小需求的实现。&lt;/p&gt;
&lt;p&gt;包含图片上传，限制图片的大小。&lt;br&gt;文件上传和下载（不用form 标签）&lt;br&gt;之前做地图需求的，字符颜色转rgb的
    
    </summary>
    
    
      <category term="html5" scheme="https://misssweety.github.io/tags/html5/"/>
    
      <category term="图片上传" scheme="https://misssweety.github.io/tags/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
    
      <category term="文件上传" scheme="https://misssweety.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
      <category term="文件下载" scheme="https://misssweety.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>D3-api-transition</title>
    <link href="https://misssweety.github.io/2017/09/18/D3-api-transition/"/>
    <id>https://misssweety.github.io/2017/09/18/D3-api-transition/</id>
    <published>2017-09-18T08:45:41.000Z</published>
    <updated>2017-09-22T03:10:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="D3的动效API-transition"><a href="#D3的动效API-transition" class="headerlink" title="D3的动效API-transition"></a>D3的动效API-transition</h1><p>D3的动效都是通过transition来实现的。</p>
<p><code>transition</code> 是类似于selection的接口，它用于动画改变DOM界面。<br><code>transition</code> 通过 <code>selection.transition</code> 获得，他和d3.select(…)返回的内容是一样的。</p>
<h2 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h2><p>基本api：</p>
<blockquote>
<p>selection.transition([name])<br>selection.interrupt([name])<br>transition.duration()<br>transition.delay(value|func)<br>transition.ease(name)<br>transition.each()<br>transition.call()<br>transition.filter()<br>transition.merge()<br>transition.remove()  </p>
</blockquote>
<p>高级：</p>
<blockquote>
<p>transition.on  监控控制流，几个状态：start，end，interrupt。这个只是transition对象有。</p>
<p>transition.attrTween<br>transition.styleTween<br>transition.tween(name[, value])</p>
</blockquote>
<h2 id="最简单例子"><a href="#最简单例子" class="headerlink" title="最简单例子"></a>最简单例子</h2><p>在需要变化的属性前加上<code>transition()</code>即可~~<br>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">svg.selectAll(<span class="string">"rect"</span>)</div><div class="line"> .data(dataset)</div><div class="line"> .transition()    <span class="comment">// &lt;-- This is new! Everything else here is unchanged.</span></div><div class="line"> .attr(<span class="string">"y"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> h - yScale(d);</div><div class="line"> &#125;)</div><div class="line"> .attr(<span class="string">"height"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> yScale(d);</div><div class="line"> &#125;)</div><div class="line"> .attr(<span class="string">"fill"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="string">"rgb(0, 0, "</span> + (d * <span class="number">10</span>) + <span class="string">")"</span>;</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<p>如果不加，则立即执行，加了则延迟一点点。默认：250ms</p>
<h2 id="常用的transition写法"><a href="#常用的transition写法" class="headerlink" title="常用的transition写法"></a>常用的transition写法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.transition()</div><div class="line">  .delay(<span class="function"><span class="keyword">function</span>(<span class="params">d,i</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> i * <span class="number">150</span>;</div><div class="line">   &#125;)</div><div class="line">  .duration(<span class="number">1500</span>)</div><div class="line">  .ease(d3.easeBack)</div></pre></td></tr></table></figure>
<p>每个元素都会有自己的delay。</p>
<h3 id="ease-函数"><a href="#ease-函数" class="headerlink" title=" ease  函数"></a><strong> ease </strong> 函数</h3><pre><code>&quot;easeElastic&quot;,  
&quot;easeBounce&quot;,  
&quot;easeLinear&quot;,  
&quot;easeSin&quot;,  
&quot;easeQuad&quot;,  
&quot;easeCubic&quot;,  
&quot;easePoly&quot;,  
&quot;easeCircle&quot;,  
&quot;easeExp&quot;,  
&quot;easeBack&quot;  
</code></pre><p>调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">selection.ease(d3.easeElastic)</div></pre></td></tr></table></figure></p>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>连续添加多个transition,最简单的方法之一，就是在第一个transition完成后，继续调用transition。<br>参考例子：<a href="https://codepen.io/akixiao/pen/BwNZRp" target="_blank" rel="external">https://codepen.io/akixiao/pen/BwNZRp</a></p>
<h3 id="d3-active-node-name"><a href="#d3-active-node-name" class="headerlink" title="d3.active(node, [name])"></a>d3.active(node, [name])</h3><p>返回具有指定名称（如果有）的指定节点上的<code>active transition</code>。如果未指定名称，则使用null。如果指定节点上没有这样的<code>active transition</code>，则返回null。此方法对于创建链接<code>transition</code>很有用。</p>
<h3 id="tween-补间动画"><a href="#tween-补间动画" class="headerlink" title="tween 补间动画"></a>tween 补间动画</h3><p>transition的变化详情，是通过interpolate实现的。<br>默认有几个情况：<br>如果attr中的value是数字，则使用interpolateNumber<br>如果value是color或者字符颜色，则使用 interpolateRgb.<br>其他情况：interpolateString  </p>
<p><code>style</code>的属性也是一样的<br><code>tween</code>有自己的时间函数<br><code>tween</code>相关函数使用重点就是在，tween函数中设置自己的时间函数：  </p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">transition.tween(<span class="string">"attr.fill"</span>, function() &#123;</div><div class="line">  var <span class="keyword">node</span> <span class="title">= this</span>, i = d3.interpolateRgb(<span class="keyword">node</span>.<span class="title">getAttribute</span>(<span class="string">"fill"</span>), <span class="string">"blue"</span>);</div><div class="line">  return function(t) &#123;</div><div class="line">    <span class="keyword">node</span>.<span class="title">setAttribute</span>(<span class="string">"fill"</span>, i(t));</div><div class="line">  &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>另一个数字补间应用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.tween(<span class="string">'number'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> that = d3.select(<span class="keyword">this</span>);</div><div class="line">  <span class="keyword">const</span> i = d3.interpolateRound(<span class="number">0</span>, <span class="number">200</span>);</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</div><div class="line">    that.style(<span class="string">'color'</span>, <span class="string">`rgb(<span class="subst">$&#123;<span class="number">0</span> + i(t)&#125;</span>, <span class="subst">$&#123;<span class="number">80</span> + i(t)&#125;</span>, 232)`</span>);</div><div class="line">    that.text(i(t));</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>演示：<a href="https://codepen.io/akixiao/pen/mBJqzO" target="_blank" rel="external">https://codepen.io/akixiao/pen/mBJqzO</a></p>
<h3 id="循环变换"><a href="#循环变换" class="headerlink" title="循环变换"></a>循环变换</h3><p>一般通过是将transition写成一个函数。然后使用on监听end事件，实现递归调用。简单例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   show.transition()</div><div class="line">   .delay(<span class="number">800</span>)</div><div class="line">   .duration(<span class="number">2000</span>)</div><div class="line">   .tween(<span class="string">'number'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     <span class="keyword">const</span> that = d3.select(<span class="keyword">this</span>);</div><div class="line">     <span class="keyword">const</span> i = d3.interpolateRound(<span class="number">0</span>, <span class="number">200</span>);</div><div class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</div><div class="line">       that.style(<span class="string">'color'</span>, <span class="string">`rgb(<span class="subst">$&#123;<span class="number">0</span> + i(t)&#125;</span>, <span class="subst">$&#123;<span class="number">80</span> + i(t)&#125;</span>, 232)`</span>);</div><div class="line">       that.text(i(t));</div><div class="line">     &#125;</div><div class="line">   &#125;)</div><div class="line">   .on(<span class="string">'end'</span>, repeat); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><p>d3实现的smooth scroll<br>高级玩法：<br><a href="https://bl.ocks.org/mbostock/70d5541b547cc222aa02" target="_blank" rel="external">https://bl.ocks.org/mbostock/70d5541b547cc222aa02</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="http://duspviz.mit.edu/d3-workshop/transitions-animation/" target="_blank" rel="external">d3 transition</a><br><a href="https://bost.ocks.org/mike/transition/" target="_blank" rel="external">working with transitions</a><br><a href="https://leanpub.com/d3-t-and-t-v4/read" target="_blank" rel="external">D3 Tips and Tricks V4.0</a><br><a href="https://www.dashingd3js.com/lessons/d3-transition-basics" target="_blank" rel="external">D3 Transition Basics</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;D3的动效API-transition&quot;&gt;&lt;a href=&quot;#D3的动效API-transition&quot; class=&quot;headerlink&quot; title=&quot;D3的动效API-transition&quot;&gt;&lt;/a&gt;D3的动效API-transition&lt;/h1&gt;&lt;p&gt;D3
    
    </summary>
    
    
      <category term="d3" scheme="https://misssweety.github.io/tags/d3/"/>
    
      <category term="transition" scheme="https://misssweety.github.io/tags/transition/"/>
    
  </entry>
  
  <entry>
    <title>关于Object查缺补漏</title>
    <link href="https://misssweety.github.io/2017/09/18/%E5%85%B3%E4%BA%8EObject%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"/>
    <id>https://misssweety.github.io/2017/09/18/关于Object查缺补漏/</id>
    <published>2017-09-18T08:09:48.000Z</published>
    <updated>2017-09-18T08:10:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>这些都是对象子类型，看起来与基础类型一样。如下：</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Error</li>
</ul>
<p>以上内置函数可以当做构造函数来使用。一些字面可以自动转换成对象类型进行一些方法的操作。</p>
<h2 id="深复制-amp-浅复制"><a href="#深复制-amp-浅复制" class="headerlink" title="深复制 &amp; 浅复制"></a>深复制 &amp; 浅复制</h2><p>对于对象和数组来说，<code>浅复制</code>是对对象地址的复制，并没有开辟新的栈，复制的结果是两个对象指向同一个地址，修改一个对象的属性，会改变另一个对象属性。<code>深复制</code>则开辟新的栈，两个对象对应两个不同的地址，属性隔离。</p>
<p>浅复制：拷贝引用<br>深复制：拷贝实例<br>深复制比较耗内存，而且可能出现死循环栈溢出的情况。<br>深复制死循环的例子：  </p>
<p>const testArr = [];<br>const myObj = {<br>  a: 2,<br>  b: testArr,<br>};</p>
<p>testArr.push(myObj, true);</p>
<p>比如深复制myObj, 除了复制myObj外，还要复制testArr，而testArr引用了myObj,所以又要再次复制myObj，然后这两个开始循环引用导致死循环了。</p>
<p>Object.assign是es6里非常好用的一个方法，<br><code>Object.assign()</code></p>
<h2 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h2><p>是从es5以后，对象属性有了属性描述符。<br>一个对象的属性不仅包含属性值，还包含另外三个特性：<code>writable</code>，<code>enumerable</code> 和 <code>configurable</code><br>使用该函数，可以获取一个对象属性的配置信息。<br>Object.getOwnPropertyDescriptor( myObject, “a” );</p>
<p>使用下面的函数，可以配置对象属性<br>Object.defineProperty(obj, ‘prop’, {<br>  value: 6,<br>  writable: true,<br>  configurable: true,<br>  enumerable: true,<br>});</p>
<p><code>writable</code>: 控制能否重写这个属性的值<br><code>enumerable</code>: 控制这个属性能否被遍历<br><code>configurable</code>: 控制这个属性的属性描述符是否可以修改，也就是控制这三个属性是否可以被修改。configurable:false 还会禁止删除这个属性</p>
<h2 id="控制属性的不变性"><a href="#控制属性的不变性" class="headerlink" title="控制属性的不变性"></a>控制属性的不变性</h2><p>当我们想控制一些对象的属性，让他成为不可改变的，我们有如下几种方法：</p>
<h3 id="结合writable-amp-configurable"><a href="#结合writable-amp-configurable" class="headerlink" title="结合writable &amp; configurable"></a>结合writable &amp; configurable</h3><p>writable:false<br>configurable:false</p>
<p>对应的属性将不会被更改。也不能被删除。</p>
<h3 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h3><p><code>Object.preventExtensions</code><br>可以禁止一个对象添加新属性，并且保留已有属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">2</span>&#125;;</div><div class="line"><span class="built_in">Object</span>.preventExtensions(obj);</div><div class="line">obj.b = <span class="number">3</span>;</div><div class="line">obj.b; <span class="comment">// undefined </span></div><div class="line"><span class="comment">// strict mode：typeError</span></div></pre></td></tr></table></figure>
<h3 id="seal-密封"><a href="#seal-密封" class="headerlink" title="seal 密封"></a>seal 密封</h3><p>Object.seal(..) 会创建一个“密封”的对象，等价于preventExtensions + 每个属性configurable: false;<br>但是其实这个是可以修改属性值的。</p>
<h3 id="freeze-冻结"><a href="#freeze-冻结" class="headerlink" title="freeze 冻结"></a>freeze 冻结</h3><p>等价于对对象使用seal，并把每个属性标记为writable:false;</p>
<p>但是该属性可以修改深度的对象。</p>
<h2 id="对象属性获取原理"><a href="#对象属性获取原理" class="headerlink" title="对象属性获取原理"></a>对象属性获取原理</h2><p>属性访问其实是通过对象的[[get]]获取的。对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性， 如果找到就会返回这个属性的值。如果本对象中没有，会遍历原型链进行寻找。如果都没有则返回undefined。</p>
<p>在es6中，我们可以进行这个内置操作的修改了。比如Proxy 代理对象。</p>
<p>对应的还有[[Put]]内置操作。主要用来设置对象的值。<br>[[Put]] 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性(这是最重要的因素，没有则会去查原型链)。<br>如果已经存在这个属性，[[Put]] 算法大致会检查下面这些内容。  </p>
<ol>
<li>属性是否是访问描述符?如果是并且存在setter就调用setter。  </li>
<li>属性的数据描述符中writable是否是false?如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。  </li>
<li>如果都不是，将该值设置为属性的值。  </li>
</ol>
<h3 id="getter-amp-setter"><a href="#getter-amp-setter" class="headerlink" title="getter &amp; setter"></a>getter &amp; setter</h3><p>可以在对象的某个属性上进行修改默认的getter与setter函数。但是一般这两个要绑定在一起输出。两个方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">const obj = &#123; <span class="keyword">get</span> c() &#123; <span class="keyword">return</span> <span class="number">1</span>;&#125; &#125;;</div><div class="line">Object.definePropperty(obj, <span class="string">'b'</span>,</div><div class="line">  &#123; <span class="keyword">get</span>: function() &#123; <span class="keyword">return</span> <span class="number">2</span>;&#125;&#125;</div><div class="line">);</div><div class="line"></div><div class="line">obj.c <span class="comment">// 1</span></div><div class="line">obj.b <span class="comment">// 2 </span></div><div class="line">obj.b = <span class="number">3</span>;</div><div class="line">obj.b <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="comment">// get set 经典搭配</span></div><div class="line">const myObj = &#123;</div><div class="line">  <span class="keyword">get</span> a() &#123; <span class="keyword">return</span> <span class="keyword">this</span>._a_; &#125;</div><div class="line">  <span class="keyword">set</span> a(<span class="keyword">val</span>) &#123; <span class="keyword">this</span>._a_ = <span class="keyword">val</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="属性存在性"><a href="#属性存在性" class="headerlink" title="属性存在性"></a>属性存在性</h2><p>检验一个对象中是否有某个属性，可以用 <code>in</code>  <code>hasOwnProperty</code> 。可以用于检测是属性值为undefined，还是为定义属性。<br>但是这两个的区别是，<code>in</code>是对象本身和其原型链都查，后者则只查对象本身。</p>
<p>参考的是《你不知道的javascript》</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内置对象&quot;&gt;&lt;a href=&quot;#内置对象&quot; class=&quot;headerlink&quot; title=&quot;内置对象&quot;&gt;&lt;/a&gt;内置对象&lt;/h2&gt;&lt;p&gt;这些都是对象子类型，看起来与基础类型一样。如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;Number&lt;/
    
    </summary>
    
    
      <category term="javascript" scheme="https://misssweety.github.io/tags/javascript/"/>
    
      <category term="object" scheme="https://misssweety.github.io/tags/object/"/>
    
  </entry>
  
  <entry>
    <title>React生命周期</title>
    <link href="https://misssweety.github.io/2017/09/12/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://misssweety.github.io/2017/09/12/React生命周期/</id>
    <published>2017-09-12T11:07:41.000Z</published>
    <updated>2017-10-25T11:44:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react生命周期"><a href="#react生命周期" class="headerlink" title="react生命周期"></a>react生命周期</h1><p>在自定义React组件时，会根据需要在组件生命周期的不同阶段实现不同的逻辑。本文源码是【15.6.1】</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>而组件的生命周期在不同状态下的执行顺序如下：</p>
<h4 id="首次挂载组件"><a href="#首次挂载组件" class="headerlink" title="首次挂载组件"></a>首次挂载组件</h4><ul>
<li>getDefaultProps</li>
<li>getInitialState</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
<h4 id="重新挂载组件"><a href="#重新挂载组件" class="headerlink" title="重新挂载组件"></a>重新挂载组件</h4><ul>
<li>getInitialState</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
<h4 id="再次渲染组件-props-CHANGE"><a href="#再次渲染组件-props-CHANGE" class="headerlink" title="再次渲染组件-props CHANGE"></a>再次渲染组件-props CHANGE</h4><ul>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ul>
<h4 id="再次渲染组件-state-CHANGE"><a href="#再次渲染组件-state-CHANGE" class="headerlink" title="再次渲染组件-state CHANGE"></a>再次渲染组件-state CHANGE</h4><ul>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ul>
<p>下面就是揭秘React为何会按照上面这个执行生命周期。</p>
<h2 id="生命周期详解"><a href="#生命周期详解" class="headerlink" title="生命周期详解"></a>生命周期详解</h2><p>自定义组件声明周期存在3个阶段：<br><strong>MOUNTING</strong>, <strong>RECEIVE_PROPS</strong>, <strong>UNMOUNTING</strong></p>
<p>分别对应3种方法。</p>
<ul>
<li>mountComponent，</li>
<li>updateComponent</li>
<li>unmountComponent</li>
</ul>
<p>以上每个都提供了几种处理方法。will前缀的方法在进入状态之前调用，did在进入状态之后调用。</p>
<h3 id="使用createClass创建自定义组件"><a href="#使用createClass创建自定义组件" class="headerlink" title="使用createClass创建自定义组件"></a>使用createClass创建自定义组件</h3><p>ES6编写React组件时：</p>
<pre><code>class MyComponent extends React.Component
</code></pre><p>是调用<code>createClass</code>创建组件，利用原型继承<code>ReactClassComponent</code>父类，合并<code>mixins</code>，初始化<code>defaultProps</code>，返回构造函数。下面是代码。</p>
<p>关于createClass：【isomorphic/class/createClass.js】  </p>
<pre><code>&apos;use strict&apos;;

var {Component} = require(&apos;ReactBaseClasses&apos;);
var {isValidElement} = require(&apos;ReactElement&apos;);
var ReactNoopUpdateQueue = require(&apos;ReactNoopUpdateQueue&apos;);
var factory = require(&apos;create-react-class/factory&apos;);

module.exports = factory(Component, isValidElement, ReactNoopUpdateQueue);
</code></pre><p>factory: [react/addons/create-react-class/factory.js];</p>
<p>component如上，但是<code>createClass</code>实际上导出的是由<code>factory``包裹的函数。各种生命周期都是在factory</code>里构造的。<code>factory</code>里定义了，<code>ReactClassInterface</code>，里面规定了好多协议（如render等）</p>
<pre><code>// Helper function to allow the creation of anonymous functions which do not
// have .name set to the name of the variable being assigned to.
function identity(fn) {
  return fn;
}

function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
  var injectedMixins = [];
  // 定义reactclass中的协议（其实就是方法）
  var ReactClassInterface = {
    mixins: &apos;DEFINE_MANY&apos;,
    statics: &apos;DEFINE_MANY&apos;,
    propTypes: &apos;DEFINE_MANY&apos;,
    contextTypes: &apos;DEFINE_MANY&apos;,
    childContextTypes: &apos;DEFINE_MANY&apos;,
    getDefaultProps: &apos;DEFINE_MANY_MERGED&apos;,
    getInitialState: &apos;DEFINE_MANY_MERGED&apos;,
    getChildContext: &apos;DEFINE_MANY_MERGED&apos;,
    render: &apos;DEFINE_ONCE&apos;,
    componentWillMount: &apos;DEFINE_MANY&apos;,
    componentDidMount: &apos;DEFINE_MANY&apos;,
    componentWillReceiveProps: &apos;DEFINE_MANY&apos;,
    shouldComponentUpdate: &apos;DEFINE_ONCE&apos;,
    componentWillUpdate: &apos;DEFINE_MANY&apos;,
    componentDidUpdate: &apos;DEFINE_MANY&apos;,
    componentWillUnmount: &apos;DEFINE_MANY&apos;,
    updateComponent: &apos;OVERRIDE_BASE&apos;
};

  var ReactClassComponent = function() {};
  _assign(
    ReactClassComponent.prototype,
    ReactComponent.prototype,
    ReactClassMixin
  );

  function createClass(spec) {
    // Constructor.name !== &apos;Constructor&apos;.确保不会将没有displayName的类识别为&apos;Constructor&apos;。重写了contructor函数~~~~
     var Constructor = identity(function(props, context, updater) {
     // 自动绑定
     if (this.__reactAutoBindPairs.length) {
      bindAutoBindMethods(this);
    }

    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;

    this.state = null;
    // reactClasses没有构造函数，通过getInitialState，与componentWillMount来进行初始化。
    var initialState = this.getInitialState ? this.getInitialState() : null;
    // 原型继承自父类。
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
// 把didmount，willunmount赋给原型
    mixSpecIntoComponent(Constructor, IsMountedPreMixin);
    mixSpecIntoComponent(Constructor, spec);
    mixSpecIntoComponent(Constructor, IsMountedPostMixin);

    // Initialize the defaultProps property after all mixins have been merged.
    // 所有mixin合并后，开始初始化defaultProps
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }
    // 减少查找并设置原型的时间。
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  } 
  return createClass;
}
</code></pre><p>以上是初始化的阶段，第一次mounting前，<code>createClass</code>返回<code>Constructor</code>函数。<code>getDefaultProps</code> 是在constructor阶段调用的，所以生成一个实例后，就不会再调用了。所以只有初次挂载的时候才会调用。。。</p>
<h3 id="mountComponent阶段"><a href="#mountComponent阶段" class="headerlink" title="mountComponent阶段"></a>mountComponent阶段</h3><p>mountComponent负责管理生命周期的<code>getInitialState</code>，<code>componentWillMount</code>，<code>render</code>，和<code>componentDidMount</code>.</p>
<p>mountComponent挂载组件，初始化序号，标记等参数，判断是否为无状态组件，以及初始化操作。使用<code>getInitialState</code>获取初始化state。在<code>componentWillMount</code>中调用setState，<strong>不触发re-render</strong>，而是merge state。这个状态的this.state并不是最新的。在render中才可以获取更新的this.state。  </p>
<p>[代码里]</p>
<pre><code>// When mounting, calls to `setState` by `componentWillMount` will set
  // `this._pendingStateQueue` without triggering a re-render.
  if (this._pendingStateQueue) {
    inst.state = this._processPendingState(inst.props, inst.context);
    // merge state 
  }
</code></pre><p>利用：<code>this._pendingStateQueue</code> , <code>this._pendingReplaceState</code>, <code>this._pendingForceUpdate</code> 实现setState的异步跟新机制。</p>
<p>render后，若存在didMount，则调用。</p>
<p>mountComponent通过递归渲染的，由于是递归，肯定是父的willMOUNT, 父的RENDER, 子的willMount，子render，子didMount，父didmount。</p>
<p>mountComponent,初始化state，执行<code>initialMount</code>，返回markup。</p>
<pre><code>mountComponent: function(
    transaction,
    hostParent,
    hostContainerInfo,
    context,
  ){
    ...
    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }

    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    var markup;
    if (inst.unstable_handleError) {
      markup = this.performInitialMountWithErrorHandling(
        renderedElement,
        hostParent,
        hostContainerInfo,
        transaction,
        context,
      );
    } else {
      markup = this.performInitialMount(
        renderedElement,
        hostParent,
        hostContainerInfo,
        transaction,
        context,
      );
    }

    if (inst.componentDidMount) {
      if (__DEV__) {
        transaction.getReactMountReady().enqueue(() =&gt; {
          measureLifeCyclePerf(
            () =&gt; inst.componentDidMount(),
            this._debugID,
            &apos;componentDidMount&apos;,
          );
        });
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
      }
    }

    return markup;
  } 
</code></pre><p>在<code>performInitialMount</code>函数中, 使用ReactReconciler，进行递归渲染组件。</p>
<pre><code>var markup = ReactReconciler.mountComponent(
  child,
  transaction,
  hostParent,
  hostContainerInfo,
  this._processChildContext(context),
  debugID,
);
</code></pre><h3 id="RECEIVE—props-update的过程"><a href="#RECEIVE—props-update的过程" class="headerlink" title="RECEIVE—props update的过程"></a>RECEIVE—props update的过程</h3><p>源码里面：updateComponent负责管理生命周期的 <code>componentWillReceiveProps</code>，<code>shouldComponentUpdate</code>, <code>componentWillUpdate</code>, <code>componentDidUpdate</code>;</p>
<p>首先通过<code>updateComponent</code>更新组件，如果元素不一致，说明要进行组件更新。<br>代码继续向下执行，如果有<code>componentWillReceiveProps</code>执行，其中有<code>setState</code>会合并state，且在<code>componentWillReceiveProps，shouldComponentUpdate，componentWillUpdate</code>中不会获取到新的state。只能在render和did状态才能获取。剩下几个状态也是有就执行，且顺序为：<br><code>shouldComponentUpdate</code><br><code>componentWillUpdate</code><br><code>render</code><br><code>componentDidUpdate</code></p>
<p>在<code>updateComponent</code>中</p>
<pre><code>updateComponent: function(
transaction,
prevParentElement,
nextParentElement,
prevUnmaskedContext,
nextUnmaskedContext,
</code></pre><p>  ) {<br>    var inst = this._instance;<br>    …<br>    var willReceive = false;</p>
<pre><code>// 判断context变化与否，设置willReceive。
if (this._context === nextUnmaskedContext) {
  nextContext = inst.context;
} else {
  nextContext = this._processContext(nextUnmaskedContext);
  willReceive = true;
}

var prevProps = prevParentElement.props;
var nextProps = nextParentElement.props;
// 判断props变化与否，设置willReceive。
if (prevParentElement !== nextParentElement) {
  willReceive = true;
}

if (willReceive &amp;&amp; inst.componentWillReceiveProps) {
...
判断和执行componentWillReceiveProps
}

var nextState = this._processPendingState(nextProps, nextContext);
var shouldUpdate = true;
... 下面是关于shouldupdate的判断和执行。
</code></pre><p>shouldComponentUpdate，如果用户自定义了，则按照自定义判断来返回shouldUpdate，否则执行默认操作：</p>
<pre><code>if (!this._pendingForceUpdate) {
if (inst.shouldComponentUpdate) {
    if (__DEV__) {
      shouldUpdate = measureLifeCyclePerf(
        () =&gt; inst.shouldComponentUpdate(nextProps, nextState, nextContext),
        this._debugID,
        &apos;shouldComponentUpdate&apos;,
      );
    } else {
      shouldUpdate = inst.shouldComponentUpdate(
        nextProps,
        nextState,
        nextContext,
      );
    }
  } else {
    if (this._compositeType === CompositeTypes.PureClass) {
      shouldUpdate =
        !shallowEqual(prevProps, nextProps) ||
        !shallowEqual(inst.state, nextState);
    }
  }
  }
</code></pre><p>后面render要根据shouldUpdate的状态来执行。</p>
<pre><code> if (shouldUpdate) {
  this._pendingForceUpdate = false;
  // Will set `this.props`, `this.state` and `this.context`.
  this._performComponentUpdate(
    nextParentElement,
    nextProps,
    nextState,
    nextContext,
    transaction,
    nextUnmaskedContext,
  );
} else {
  // 如果确定不更新，也要设置props，state，context
  this._currentElement = nextParentElement;
  this._context = nextUnmaskedContext;
  inst.props = nextProps;
  inst.state = nextState;
  inst.context = nextContext;
}
</code></pre><p>如果应该update则调用一下函数<br><code>this._performComponentUpdate</code><br>规定了如果有componentWillUpdate，调用。<br>然后是_updateRenderedComponent，进行re-render，调动render方法更新dom<br>接着，如果有hasComponentDidUpdate，调用。</p>
<pre><code>_updateRenderedComponent: function(transaction, context) {
// 如果需要更新，则调用ReactReconciler.receiveComponent跟新组件
  if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler.receiveComponent(
        prevComponentInstance,
        nextRenderedElement,
        transaction,
        this._processChildContext(context),
      );
   } else {
     // 渲染组件，render递归
     var nextMarkup = ReactReconciler.mountComponent(
        child,
        transaction,
        this._hostParent,
        this._hostContainerInfo,
        this._processChildContext(context),
        debugID,
      );
    }
</code></pre><p>也是递归render的，所以也是父的先willUpdate，然后子的willUpdate,子的didUpdate，父的DidUpdate</p>
<h3 id="unmounting"><a href="#unmounting" class="headerlink" title="unmounting"></a>unmounting</h3><p>负责管理<code>componentWillUnmount</code></p>
<p>如果规定了componentWillUnmount，则执行并重置所有参数，更新队列以及状态。有setState，不会执行re-render。并清除了当前的这个实例。</p>
<h3 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h3><p>只是一个render方法，没有组件实例化过程。因为没有状态，没有生命周期，接收props生成dom结构。</p>
<h2 id="setState-机制"><a href="#setState-机制" class="headerlink" title="setState 机制"></a>setState 机制</h2><p>this.state 用来访问state，this.setState 用来更新state。但是我们在刚写react的时候，有些时候setState并不生效。原因慢慢来分析。  </p>
<p>首先记住，setState是异步更新，这是通过监控一个state队列实现的，这也避免了频繁重复更新state。  </p>
<p>调用setState的时候，会执行enqueueSetState方法，对partialState 和 _pendingStateQueue进行合并操作，最终通过enqueueUpdate执行state更新。这个也就是setState的时候，将需要更新的state进行合并，让后放到state 队列中，通过this.state = xxx 修改的state，并不会放入state队列中，也就不会更新。</p>
<p>源码在：src/isomorphic/modern/class/ReactBaseClasses.js  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState, callback</span>) </span>&#123;</div><div class="line">  invariant(</div><div class="line">    <span class="keyword">typeof</span> partialState === <span class="string">'object'</span> ||</div><div class="line">      <span class="keyword">typeof</span> partialState === <span class="string">'function'</span> ||</div><div class="line">      partialState == <span class="literal">null</span>,</div><div class="line">    <span class="string">'setState(...): takes an object of state variables to update or a '</span> +</div><div class="line">      <span class="string">'function which returns an object of state variables.'</span>,</div><div class="line">  );</div><div class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState);</div><div class="line">  <span class="keyword">if</span> (callback) &#123;</div><div class="line">    <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>, callback, <span class="string">'setState'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">src/renderers/shared/stack/reconciler/ReactUpdateQueue.js:</div><div class="line">enqueueSetState: <span class="function"><span class="keyword">function</span>(<span class="params">publicInstance, partialState</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> internalInstance = getInternalInstanceReadyForUpdate(</div><div class="line">      publicInstance,</div><div class="line">      <span class="string">'setState'</span>,</div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!internalInstance) &#123;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> queue =</div><div class="line">      internalInstance._pendingStateQueue ||</div><div class="line">      (internalInstance._pendingStateQueue = []);</div><div class="line">    queue.push(partialState);</div><div class="line"></div><div class="line">    enqueueUpdate(internalInstance);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line"></div><div class="line">/src/renderers/shared/stack/reconciler/ReactUpdates.js:</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>) </span>&#123;</div><div class="line">  ensureInjected();</div><div class="line"></div><div class="line">  <span class="comment">// Various parts of our code (such as ReactCompositeComponent's</span></div><div class="line">  <span class="comment">// _renderValidatedComponent) assume that calls to render aren't nested;</span></div><div class="line">  <span class="comment">// verify that that's the case. (This is called by each top-level update</span></div><div class="line">  <span class="comment">// function, like setState, forceUpdate, etc.; creation and</span></div><div class="line">  <span class="comment">// destruction of top-level components is guarded in ReactMount.)</span></div><div class="line"><span class="comment">// 不处于批量更新模式，马上更新</span></div><div class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</div><div class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"><span class="comment">// 处于批量更新模式，则放在dirtyComponent中，不能马上更新</span></div><div class="line">  dirtyComponents.push(component);</div><div class="line">    <span class="keyword">if</span> (component._updateBatchNumber == <span class="literal">null</span>) &#123;</div><div class="line">    component._updateBatchNumber = updateBatchNumber + <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用如下例子解释：setSTATE: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestState</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">val</span> : <span class="number">0</span>&#125;;</div><div class="line">  &#125;</div><div class="line">  componentDidMount() &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val);</div><div class="line"></div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val);</div><div class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">val</span>: <span class="keyword">this</span>.state.val + <span class="number">1</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.val);</div><div class="line">    &#125;, <span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> TestState;</div></pre></td></tr></table></figure>
<p>输出 0 0 2 3</p>
<p>在componentDidMount中，<code>this.setState({ val: this.state.val + 1});</code> 处于各种事务中，而事务的进行和结束，都需要一个一个的进行，而不是瞬时执行的，前两个setState语句运行时，isBatchingUpdates设为true了（这个应该是事务导致的），所以此时console.log state制并没有变。而setTimeout中，调用栈都发生变化了，变得很简单，并不处于事务中，也就没有bachedUpdate，所以isBatchingUpdate是false，马上就会更新state。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;react生命周期&quot;&gt;&lt;a href=&quot;#react生命周期&quot; class=&quot;headerlink&quot; title=&quot;react生命周期&quot;&gt;&lt;/a&gt;react生命周期&lt;/h1&gt;&lt;p&gt;在自定义React组件时，会根据需要在组件生命周期的不同阶段实现不同的逻辑。本文源码
    
    </summary>
    
    
      <category term="react" scheme="https://misssweety.github.io/tags/react/"/>
    
      <category term="生命周期" scheme="https://misssweety.github.io/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>d3-basic-line</title>
    <link href="https://misssweety.github.io/2017/06/29/d3-basic-line/"/>
    <id>https://misssweety.github.io/2017/06/29/d3-basic-line/</id>
    <published>2017-06-29T04:19:49.000Z</published>
    <updated>2017-06-29T04:27:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="d3-折线图"><a href="#d3-折线图" class="headerlink" title="d3-折线图"></a>d3-折线图</h1><p>从一个最基本的折线图开始，看看d3是怎么实现的，以及用到哪些知识</p>
<h2 id="需要的知识"><a href="#需要的知识" class="headerlink" title="需要的知识"></a>需要的知识</h2><ul>
<li><a href="https://github.com/d3/d3-scale" target="_blank" rel="external">scale</a></li>
<li><a href="https://github.com/d3/d3-array/blob/master/README.md#extent" target="_blank" rel="external">extent</a></li>
<li><a href="https://github.com/d3/d3/blob/master/API.md#transitions-d3-transition" target="_blank" rel="external">transition</a></li>
<li><a href="https://github.com/d3/d3-shape/blob/master/README.md#lines" target="_blank" rel="external">line</a></li>
<li><a href="https://github.com/d3/d3-shape/blob/master/README.md#curves" target="_blank" rel="external">curve</a></li>
<li><a href="https://github.com/d3/d3-axis" target="_blank" rel="external">axis</a></li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>获取svg容器</p>
<pre><code>&lt;svg width=&quot;500&quot; height=&quot;270&quot; class=&quot;testline&quot;&gt;&lt;/svg&gt;

const svg = d3.select(&apos;.testline&apos;);
const margin = {top: 20, right: 20, bottom: 20, left: 20};
const width = +svg.attr(&quot;width&quot;) - margin.left - margin.right;
const height = +svg.attr(&quot;height&quot;) - margin.top - margin.bottom;
const g = svg.append(&quot;g&quot;).attr(&quot;transform&quot;, `translate(${margin.left},${margin.top})`);
</code></pre></li>
</ol>
<ol>
<li><p>x，y轴缩放<br>这里，如果x轴是与时间有关的，可以直接使用d3提供的scaleTime()来实现时间的转换。关于scale还有好多内容，待总结。这里需要确定两个轴，缩放的类型，以及xy轴图像在屏幕中的实际宽高值。<br>这里的<code>x</code>, <code>y</code> 其实是函数（根据给出的数据，得出该数据的x，y坐标值）。</p>
<pre><code>const x = d3.scaleTime().range([0, width]);
const y = d3.scaleLinear().range([height, 0]);
</code></pre></li>
<li><p>line<br>line的生成就需要上面的轴缩放函数。 这里是因为date函数可以接受ms的unix时间戳，所以乘以1000.这里也可以加一些点与点之间的连接方式。 <code>curveMonotoneX</code>平滑, <code>curveLinear</code>线性。需要两步，line函数生成。line呈现。<br>关于line的展示，需要把数据绑定到path标签上，将line函数运用到path的d属性上。就可以绘制出线了，transition这里是为了实现简单的动画效果。<br>注意，line展示的时候，data([data]) 也可应用datum(data)，前者删了数组标记是不可以的。不知道为什么</p>
<pre><code>const line = d3.line()
  .x((d, i) =&gt; x(d.ts * 1000))
  .y(d =&gt; y(d.y))
  .curve(d3.curveMonotoneX);

// line 的展示。
g.append(&apos;path&apos;)
      .data([data]).attr(&apos;fill&apos;, &apos;none&apos;).attr(&apos;d&apos;, line).attr(&apos;stroke&apos;, &apos;#f33155&apos;)
      .transition(500)
      .attr(&apos;stroke-width&apos;, 3);
</code></pre></li>
<li><p>x坐标轴，y坐标轴<br>domain是将坐标轴对应的真实数据连接起来，一般就是将坐标轴要展示的数据的最大最小值放进来。<code>d3.extent</code>可以自动的算出数组内的最小，最大值，很方便。如下x轴的计算。<br>v4支持axisBottom，axisTop，axisRight，axisLeft等快捷操作，就是说明坐标轴的展现方式。<br>规定好domain后，可以将轴展示在图像中了。给出selector然后调用call(如果是x轴，记得把上面x轴函数传进来，y轴同理)，同时，这里可以规定轴线样式和<a href="https://github.com/d3/d3-axis" target="_blank" rel="external">刻度</a>的相关内容。下面的例子是规定了，最大最小值中间还可以有多少个刻度。</p>
<pre><code>x.domain(d3.extent(data, d =&gt; d.ts * 1000));
y.domain([0, d3.max(data, d =&gt; d.y * 1.1 )]);
// Add the X Axis
g.append(&quot;g&quot;).attr(&quot;transform&quot;, `translate(0,${height})`)
  .call(d3.axisBottom(x).ticks(5));
// Add the Y Axis
g.append(&quot;g&quot;).attr(&quot;transform&quot;, `translate(0,0)`)
  .call(d3.axisLeft(y).ticks(8));
</code></pre></li>
<li><p>线上打点<br>线上打点，主要是通过line函数，获取点的center位置。需要将data绑定到circle标签上，最后根据line函数绘制出来。</p>
<pre><code>g.selectAll(&quot;.dot&quot;)
.data(data).enter().append(&quot;circle&quot;).attr(&apos;class&apos;, &apos;.dot&apos;)
.attr(&quot;cx&quot;, line.x()).attr(&quot;cy&quot;, line.y())
.transition(500)
.attr(&quot;r&quot;, 3.5).attr(&apos;fill&apos;, &apos;white&apos;).attr(&apos;stroke&apos;, &apos;#f33155&apos;);
</code></pre></li>
</ol>
<ol>
<li><p>数据label<br>类似的，label也是根据line函数获取位置，然后将要现实的值，用text属性显示出来。</p>
<pre><code>g.selectAll(&quot;.text&quot;)
    .data(this.data).enter().append(&quot;text&quot;)
    .attr(&apos;class&apos;, &apos;.text&apos;).attr(&apos;font-size&apos;, 12)
    .attr(&quot;x&quot;, line.x()).attr(&quot;y&quot;, line.y())
    .attr(&apos;dx&apos;, -15).attr(&apos;dy&apos;, 7)
    .text(function(d) { return d.y})
    .transition(500)
    .attr(&apos;fill&apos;, &apos;#333&apos;).attr(&apos;stroke&apos;, &apos;#333&apos;);
</code></pre></li>
</ol>
<p>当绑定了data数据后，x函数，y函数，会自动按顺序获取数据。</p>
<p>最后结果：<br><a href="https://codepen.io/akixiao/pen/eRyBdY" target="_blank" rel="external">参考</a><br><img src="./line.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;d3-折线图&quot;&gt;&lt;a href=&quot;#d3-折线图&quot; class=&quot;headerlink&quot; title=&quot;d3-折线图&quot;&gt;&lt;/a&gt;d3-折线图&lt;/h1&gt;&lt;p&gt;从一个最基本的折线图开始，看看d3是怎么实现的，以及用到哪些知识&lt;/p&gt;
&lt;h2 id=&quot;需要的知识&quot;&gt;&lt;a
    
    </summary>
    
    
      <category term="d3" scheme="https://misssweety.github.io/tags/d3/"/>
    
      <category term="line" scheme="https://misssweety.github.io/tags/line/"/>
    
      <category term="可视化" scheme="https://misssweety.github.io/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>git实用指令</title>
    <link href="https://misssweety.github.io/2017/06/02/git%E5%AE%9E%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>https://misssweety.github.io/2017/06/02/git实用指令/</id>
    <published>2017-06-02T02:51:14.000Z</published>
    <updated>2017-06-02T03:23:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实用指令"><a href="#实用指令" class="headerlink" title="实用指令"></a>实用指令</h1><h2 id="回滚相关"><a href="#回滚相关" class="headerlink" title="回滚相关"></a>回滚相关</h2><p>最近又好好复习了下reset指令。<br>一般这些回滚的操作最好不要用，尤其是在多人开发的时候，但是偶尔想用，还有点模糊了，这次在记录一下。</p>
<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>步骤：<br>readme中分别添加  </p>
<p>test1<br>tess2<br>test3  </p>
<p>每一句添加一个commit<br>先看下log</p>
<pre><code>git log
</code></pre><p><img src="./reset-1.png" width="400px"></p>
<p>暂存区有其他修改，但没有add。</p>
<p>此时，<strong>我改错了</strong>，想<strong>回退到test1</strong>的状态。用</p>
<pre><code>git reset --hard 46670a
</code></pre><p>执行后，暂存区的内容也清空了，readme中，只有test1 了。<br>查看git log前两个提交也不见了。</p>
<p><img src="./reset-2.png" width="400px"></p>
<p>假如我后悔了，我又不想回退了，我还想在test3的情况下修改。</p>
<p>git reflog<br><img src="./reset-3.png" width="400px"><br>可以看到指令的log，从这里可以找回之前回退的相关commit<br>这里会记录着还未被回收的commit号。<br>此次，我把内容添加到暂存区了，也就是add过了，<br>再次使用reset，回滚到原来的test3的状态</p>
<pre><code>git reset --hard 9d91688
</code></pre><p>内容回到test3 处的commit，并且，之前add到暂存区的都没了</p>
<p>真想回滚，用<code>reset</code>就够了。</p>
<h3 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h3><p>其实是取消某个提交的意思。<br>revert  功能：revert是撤销某一次的提交，并不是回滚到这次提交时的状态！！！  </p>
<p>revert 的历史保留在commit中</p>
<h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>用来合并多个commits<br>场景，我们自己在本地改了好多乱七八糟的，但是并不想让所有的commit信息，比如fix之类的都提交，这个时候可以用rebase 配合 squash ，合并commit。</p>
<p>过程如下：<br>先</p>
<pre><code>git log：
</code></pre><p><img src="./rebase-1.png" width="400px"></p>
<p>我们想将0fad78ccc3到现在的commit都合并, 那么先rebase到那个不变动的commit</p>
<pre><code>git rebase -i 4c9bc3a7
</code></pre><p>如下：<br><img src="./rebase-2.png" width="400px"></p>
<p>需要留一个pick，其他都改成squash, 如下<br><img src="./rebase-3.png" width="400px"></p>
<p><code>esc</code> <code>:wq</code><br>保存后，这样就把其他的提交都合并了。自动跳到如下界面(这里可以重写合并的commit内容了)<br><img src="./rebase-4.png" width="400px"></p>
<p>修改完毕，<code>esc</code>  <code>:wq</code> 保存<br><img src="./rebase-5.png" width="400px"></p>
<p>最后，看下git log，干净了！！！！</p>
<h3 id="远端分支回滚"><a href="#远端分支回滚" class="headerlink" title="远端分支回滚"></a>远端分支回滚</h3><p>如果远端对应的分支也想修改，必须要—force</p>
<pre><code>git push --force origin branch-name
</code></pre><h3 id="刪除远端分支"><a href="#刪除远端分支" class="headerlink" title="刪除远端分支"></a>刪除远端分支</h3><pre><code>git push origin --delete target_branch
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实用指令&quot;&gt;&lt;a href=&quot;#实用指令&quot; class=&quot;headerlink&quot; title=&quot;实用指令&quot;&gt;&lt;/a&gt;实用指令&lt;/h1&gt;&lt;h2 id=&quot;回滚相关&quot;&gt;&lt;a href=&quot;#回滚相关&quot; class=&quot;headerlink&quot; title=&quot;回滚相关&quot;&gt;&lt;/a
    
    </summary>
    
    
      <category term="git" scheme="https://misssweety.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>前端页面-网络性能</title>
    <link href="https://misssweety.github.io/2017/05/25/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    <id>https://misssweety.github.io/2017/05/25/网络优化/</id>
    <published>2017-05-25T02:48:54.000Z</published>
    <updated>2017-05-25T03:02:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端页面-网络性能"><a href="#前端页面-网络性能" class="headerlink" title="前端页面-网络性能"></a>前端页面-网络性能</h1><p>一个网站从开始访问，发送请求，页面渲染，异步请求，到最终呈现，每个阶段都有各自不同的优化点。  </p>
<p>前一段时间，自己项目的网站在加载和渲染的时候表现很奇怪，遂仔细用起chrome的network以及timeline面板，期待找到问题的根源。用的时候发现很多自己缺失的知识，于是就有这篇文章记录查缺补漏的内容。</p>
<p>这里先从网络性能角度来看，它将从初始阶段影响网站的性能。<br>下面会以chrome中的network面板出发，从三点介绍网络性能相关内容，分别包括：<strong>主要网络属性</strong>，<strong>如何在chrome devtool中查看网络性能</strong>，<strong>如何优化</strong>  </p>
<h2 id="主要网络属性"><a href="#主要网络属性" class="headerlink" title="主要网络属性"></a>主要网络属性</h2><p>这里主要关注timing这个属性。某个请求的timing如下：<br><img src="./屏幕快照 2017-05-23 下午8.33.48.png"></p>
<p>在network页面点击具体的请求url即可进入上述页面。</p>
<p>可以看到一条资源从列队、停滞、代理协议、初始化连接、SSL协议、发送request、等待及内容下载所耗的时间。 </p>
<h3 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h3><ul>
<li>Queueing时间：请求排队的时间，出现原因有：更高优先级的请求，或者在HTTP/1.0和HTTP/1.1中，已经有6个同源请求在进行中</li>
<li>Stalled阻塞时间：原因如上queueing</li>
<li>DNS Lookup. 浏览器解析请求的ip地址需要的时间</li>
<li>Proxy negotiation. 与代理服务器通信需要的时间</li>
<li>Initial Connection / connecting: 建立连接的过程，包含TCP握手/重试，商定SSL</li>
<li>SSL: 完成SSL握手阶段</li>
<li>Request sent：发送请求耗时，通常只要不到1ms的时间</li>
<li>ServiceWorker Preparation.浏览器启动服务worker的时间</li>
<li>Request to ServiceWorker.The request is being sent to the service worker.</li>
<li>Waiting (TTFB). 收到首字节的时间。</li>
<li>Content Download. 浏览器接收响应数据的时间。</li>
</ul>
<h3 id="performance-api"><a href="#performance-api" class="headerlink" title="performance api"></a>performance api</h3><p>上面这些资源数据是根据js的性能api计算的。<br><strong>window.performance.getEntries()</strong> 获取资源加载时间列表。每个performanceResourceTiming大概如下：<br><img src="./屏幕快照 2017-05-23 下午8.34.34.png"> </p>
<ul>
<li>connectEnd：浏览器与服务器完成建立用以检索资源的网络连接的时间戳  </li>
<li>connectStart：浏览器与服务器开始建立用以检索资源的网络连接的时间戳</li>
<li>damainLookupEnd：浏览器完成资源的域名解析的时间戳</li>
<li>damainLookupStart：浏览器开始进行资源的域名解析的时间戳</li>
<li>duration：资源请求从开始到结束的时间差</li>
<li>entryType：PerformanceEntry对象的类型，该对象封装一个单一的性能指标作为性能表的一部分，此类型是<code>frame</code>, <code>mark</code>, <code>measure</code>, <code>navigation</code>, <code>resource</code>,<code>server</code>的其中一个。</li>
<li>fetchStart：浏览器开始获取资源的时间戳</li>
<li>initiatorType：资源文件的类型</li>
<li>name：资源的url</li>
<li>redirectEnd：接收到重定向资源的最后一个响应字节的时间戳</li>
<li>redirectStart：启动重定向以获取资源的开始时间戳</li>
<li>requestStart：浏览器从服务器请求资源的开始时间戳</li>
<li>responseEnd：浏览器接收到资源最后一个字节的时间戳，或者关闭传输连接的时间戳</li>
<li>responseStart：浏览器接收到服务器的响应的第一个字节的时间戳</li>
<li>secureConnectionStart：浏览器开始握手协议，以保护当前连接的安全性，握手开始的时间</li>
<li>startTime：浏览器开始获取资源前的时间戳(整个过程的开始时间)</li>
<li>workerStart：如果当前上下文是”worker”，返回开始获取资源的时间戳，否则返回0(应该是应用于双工通信的)</li>
</ul>
<p>下面这张图定义了PerformanceResourceTiming 接口的各个时间属性：</p>
<p><img src="./resource-timing-overview-1.png"></p>
<p><strong>performance.timing()</strong> 获取页面整体的时间参数<br><img src="./屏幕快照 2017-05-24 上午11.56.02.png"></p>
<p>这个api可以参考这个非正式的标准规范<a href="https://www.w3.org/TR/resource-timing/" target="_blank" rel="external">Resouce timing - w3c</a>   <a href="https://www.w3.org/TR/performance-timeline/#sec-PerformanceEntry-interface" target="_blank" rel="external">old one</a></p>
<p>该规范定义了一个用于Web应用程序的接口，这个接口可以访问文档需要的资源的完整时序信息。 接口的详细说明这里就不一一介绍了，细节了解需要自己去读标准。 下面只挑和我们相关的内容。 </p>
<p>由上面这个图，我们可以获取到chrome网络面板中，timing的相关信息，举个例子：   </p>
<p>页面整体的时间参数 （mta应该有用到以下参数） </p>
<pre><code>pageloadtime = t.loadEventStart - t.navigationStart,  
dns = t.domainLookupEnd - t.domainLookupStart,  
tcp = t.connectEnd - t.connectStart,  
ttfb = t.responseStart - t.navigationStart; 
</code></pre><p>某个资源的时间参数 </p>
<pre><code>var r0 = performance.getEntriesByType(&quot;resource&quot;)[0],
    loadtime = r0.duration,
    dns = r0.domainLookupEnd - r0.domainLookupStart,
    tcp = r0.connectEnd - r0.connectStart,
    ttfb = r0.responseStart - r0.startTime;
</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>还有一些其他的测量时间的问题，请参考<a href="http://mutongwu.iteye.com/blog/2164917?utm_source=tuicool" target="_blank" rel="external">performance的资源计时统计</a><br>其他方法使用，参考<a href="http://www.alloyteam.com/2015/09/explore-performance/" target="_blank" rel="external">初探performance-监控网页与程序性能</a>  </p>
<h2 id="如何在chrome-devtool中查看网络性能"><a href="#如何在chrome-devtool中查看网络性能" class="headerlink" title="如何在chrome devtool中查看网络性能"></a>如何在chrome devtool中查看网络性能</h2><p>在chrome devtool中，我们可以模拟各种网络环境，可以过滤请求，查看http请求信息，了解dom加载时间，cookie信息，资源的上下游等等。</p>
<p>内容略多，参考这里，chrome developers 官网<a href="https://developers.google.com/web/tools/chrome-devtools/network-performance/" target="_blank" rel="external">测量网络性能</a><br>英文不好的可以看这个：<a href="http://www.jianshu.com/p/471950517b07" target="_blank" rel="external">Chrome DevTools 之 Network，网络加载分析利器</a></p>
<h2 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h2><p>网站加载时间对用户的影响：<br>0.1秒：秒开<br>100-300 ：比较小的可察觉的延迟<br>300-1s：Machine is working<br>1秒：还能接受，但是已经不开心了<br>10秒：什么破玩意，不想看了<br>chrome developer里提到，目标是250ms</p>
<p>优化主要从四个属性入手，以下基本翻译自chrome devtool </p>
<h3 id="Queued-or-stalled-requests"><a href="#Queued-or-stalled-requests" class="headerlink" title="Queued or stalled requests"></a>Queued or stalled requests</h3><p>这两个指标如果时间很长，说明很多资源等待<br><strong>造成的原因</strong>：访问同一个域名的请求太多，对于http1.1来说，每个host最多同时支持6个tcp连接。</p>
<p><strong>解决</strong>：</p>
<ul>
<li>域名分片：将资源放在不同的域名中，用来克服浏览器对同一个域名访问的限制，但是不能过多因为dns解析也需要时间  </li>
</ul>
<p><strong>[备注]</strong>domain sharding (域名分片)（<a href="https://wp-rocket.me/blog/difference-cdn-and-domain-sharding/" target="_blank" rel="external">和cdn的不同</a>域名分片是一种分布方式，是将资源分布在不同的域名中达到克服浏览器访问限制的目的；cdn则是在不同的服务器上托管世界各地的网站资源。<br>）</p>
<ul>
<li>使用http2.0<br>让重要的请求先发起，不重要的remove或者推迟。</li>
</ul>
<h3 id="Slow-Time-To-First-Byte-TTFB"><a href="#Slow-Time-To-First-Byte-TTFB" class="headerlink" title="Slow Time To First Byte (TTFB)"></a>Slow Time To First Byte (TTFB)</h3><p><strong>起因：</strong> client与server的连接慢；server响应太慢</p>
<p><strong>解决：</strong></p>
<ul>
<li>连接慢， 使用cdn，或者换个服务商</li>
<li>如果server慢，优化数据库查询，用缓存，修改server配置等。</li>
</ul>
<h3 id="Slow-content-download"><a href="#Slow-content-download" class="headerlink" title="Slow content download"></a>Slow content download</h3><p><strong>原因：</strong>网络不好；内容过大</p>
<p><strong>解决：</strong></p>
<ul>
<li>连接慢， 使用cdn，或者换个服务商；</li>
<li>优化请求使数据更少。</li>
</ul>
<p><hr><br>以上是关于网络层面的网站优化内容，与前端人员开发技术能力相关性不大，需要一些网络层面以及后台来支持。当我们发现网页加载过慢的时候，可以先从网络这边入手，把网络和连接的基础问题排查后，再从优化自己写的代码入手。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前端页面-网络性能&quot;&gt;&lt;a href=&quot;#前端页面-网络性能&quot; class=&quot;headerlink&quot; title=&quot;前端页面-网络性能&quot;&gt;&lt;/a&gt;前端页面-网络性能&lt;/h1&gt;&lt;p&gt;一个网站从开始访问，发送请求，页面渲染，异步请求，到最终呈现，每个阶段都有各自不同的
    
    </summary>
    
    
      <category term="timing" scheme="https://misssweety.github.io/tags/timing/"/>
    
  </entry>
  
  <entry>
    <title>高德地图api使用总结</title>
    <link href="https://misssweety.github.io/2017/05/18/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BEapi%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://misssweety.github.io/2017/05/18/高德地图api使用总结/</id>
    <published>2017-05-18T04:28:44.000Z</published>
    <updated>2017-05-18T07:11:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用的高德地图api"><a href="#常用的高德地图api" class="headerlink" title="常用的高德地图api"></a>常用的高德地图api</h1><p>关于appkey，分为两种，一个是api调用的key，一个是地图服务的key，例如，获取门店信息，search功能等等。</p>
<h2 id="脚本加载"><a href="#脚本加载" class="headerlink" title="脚本加载"></a>脚本加载</h2><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://webapi.amap.com/maps?v=1.3&amp;key=您申请的key值&quot;&gt;&lt;/script&gt;
</code></pre><p>需要把这个脚本加载完成后，才能使用AMap。</p>
<p>可以使用<code>map-div</code>这个组件。</p>
<p>如果搭配react，需要在componentDidMount阶段，调用<code>map-div</code> 中的createMap函数。配套的，最好将该地图实例保存在一个对象中，并设置一个flag作为地图加载完成的标志位，以便react使用。</p>
<p>示例：  </p>
<pre><code>mapInstance.js

let __value = null;
export default {
  getter: () =&gt; __value,
  setter: (val) =&gt; { __value = val; },
};
---------------------------------------

const mapConfig = {
  name: &apos;AMap&apos;,
  initOpts: {
    zoom: MAP_CONFIG.zoom,
    zooms: MAP_CONFIG.zooms,
  },
  query: {
    plugin: &apos;AMap.Geocoder,AMap.CitySearch&apos;,
  },
};

componentDidMount() {
  (async () =&gt; {
    const mapIns = await createMap(mapConfig, &apos;mapComponent&apos;);
    mapInstance.setter(mapIns);
    this.props.setMapInstanceFlag(true);
    // 一些事件监听
    mapEventHandler(mapIns, &apos;dragend&apos;, &apos;on&apos;, throttle(this.handleMapScale, 800));
    mapEventHandler(mapIns, &apos;click&apos;, &apos;on&apos;, throttle(this.handleMapClick, 800));

    ...
  })();

  ...
}
</code></pre><h2 id="创建地图对象"><a href="#创建地图对象" class="headerlink" title="创建地图对象"></a>创建地图对象</h2><p>需要给出一个div作为地图的容器。</p>
<pre><code>&lt;div id=&quot;container&quot; style=&quot;width:800px; height:500px&quot;&gt;&lt;/div&gt;

var map = new AMap.Map(&apos;container&apos;,{ config })
</code></pre><p><strong>注意：</strong> 如果不加center，地图默认显示用户当前城市范围</p>
<h3 id="config常用基本配置"><a href="#config常用基本配置" class="headerlink" title="config常用基本配置"></a>config常用基本配置</h3><table>
<thead>
<tr>
<th>options</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>zoom</td>
<td>缩放级别</td>
</tr>
<tr>
<td>center</td>
<td>地图中心点坐标[lon, lat]</td>
</tr>
<tr>
<td>zooms</td>
<td>地图可以缩放的范围 ，数组格式[max, min]</td>
</tr>
<tr>
<td>zoomEnable</td>
<td>是否可缩放，默认为true</td>
</tr>
<tr>
<td>dragEnable</td>
<td>是否可拖拽，默认为true</td>
</tr>
<tr>
<td>mapStyle</td>
<td>地图显示样式，normal（默认样式）、dark（深色样式）、light（浅色样式）、fresh(osm清新风格样式)、blue_night</td>
</tr>
<tr>
<td>features</td>
<td>地图上显示的元素种类， 默认都显示，支持’bg’（地图背景）、’point’（POI点）、’road’（道路）、’building’（建筑物）</td>
</tr>
</tbody>
</table>
<h2 id="常用的地图实例方法"><a href="#常用的地图实例方法" class="headerlink" title="常用的地图实例方法"></a>常用的地图实例方法</h2><h3 id="地图常用方法"><a href="#地图常用方法" class="headerlink" title="地图常用方法"></a>地图常用方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getZoom()， setZoom()</td>
<td>缩放级别</td>
</tr>
<tr>
<td>getCenter(), setCenter()</td>
<td>获取地图中心点坐标[lon, lat]</td>
</tr>
<tr>
<td>setZoomAndCenter</td>
<td>同时设定缩放级别和中心点坐标</td>
</tr>
<tr>
<td>setCity(city:String，callback:Functon)</td>
<td>通过设置城市名称来设置地图显示的中心点</td>
</tr>
<tr>
<td>zoomIn</td>
<td>地图放大一级</td>
</tr>
<tr>
<td>zoomOut</td>
<td>地图缩小一级</td>
</tr>
</tbody>
</table>
<h3 id="地图常用事件类型"><a href="#地图常用事件类型" class="headerlink" title="地图常用事件类型"></a>地图常用事件类型</h3><ul>
<li>click: 鼠标左键单击  </li>
<li>mapmove: 地图平移时触发</li>
<li>movestart: 地图平移开始时触发</li>
<li>moveend: 地图移动结束后触发，包括平移和缩放(经试验，缩放并没有触发moveend)。</li>
<li>zoomchange: 地图缩放级别更改后触发</li>
<li>zoomstart: 缩放开始时触发</li>
<li>zoomend: 缩放停止时触发</li>
<li>dragstart: 开始拖拽地图时触发</li>
<li>dragend: 停止拖拽地图时触发</li>
<li>dragging: 拖拽地图过程中触发</li>
</ul>
<p>如果地图操作后会有其他操作，一般监听  XXXend 方法。<br>注意：setCity，setCenter等操作不会触发drag相关内容。</p>
<h3 id="关于amap的事件绑定"><a href="#关于amap的事件绑定" class="headerlink" title="关于amap的事件绑定"></a>关于amap的事件绑定</h3><p>有两种方法：  </p>
<ul>
<li><p>针对Map、覆盖物等常用类<br>直接使用on， off 方法来实现事件的简单绑定和移除</p>
</li>
<li><p>使用AMap.event命名空间<br>addDomListener(domobj, eventName, handler, context(没用过，不清楚))<br>addListener(obj, eventName, handler, context(没用过，不清楚))<br>removeListener(listener): 可以移除dom和非dom事件。</p>
<p><a href="http://lbs.amap.com/api/javascript-api/example/event/dom-event/" target="_blank" rel="external">参考</a></p>
</li>
</ul>
<h3 id="事件event中的内容"><a href="#事件event中的内容" class="headerlink" title="事件event中的内容"></a>事件event中的内容</h3><ul>
<li>所有的CLICK事件<br>点击位置的经纬度，对应在画布上的横纵坐标，事件target， 事件type<br><img src="./pic2.png"></li>
<li>其他类型事件，如moveend，zoom<br>event中只有事件类型type</li>
</ul>
<p>针对以上，我们可以对地图事件进行封装，一般需要的是事件发生的zoom，地图范围，点击位置的经纬度。<br>🌰如下:</p>
<pre><code>const eventInjector = (ev, mapINS, cb) =&gt; {
    const bounds = mapINS.getBounds();
    const param = {
        sw: bounds.getSouthWest(),
        ne: bounds.getNorthEast(),
        zoom: mapINS.getZoom(),
        type: ev.type,
        lng: ev.lnglat ? ev.lnglat.getLng() : &apos;&apos;,
        lat: ev.lnglat ? ev.lnglat.getLat() : &apos;&apos;,
    };
      if (cb) cb(param);
};

const mapEventHandler = (mapINS, type, opt, cb) =&gt; mapINS[opt](type, (ev) =&gt; eventInjector(ev, mapINS, cb));

//使用
mapEventHandler(mapIns, &apos;dragend&apos;, &apos;on&apos;, this.handleMapScale);
mapEventHandler(mapIns, &apos;dragend&apos;, &apos;off&apos;,this.handleMapScale);

//handleMapScale
 handleMapScale(ev) {
   console.log(ev);
   const { ne, sw, zoom, type } = ev;
   ...
 }
</code></pre><p>之后，如果在地图上发生dragend，event的结果如下：<br><img src="./pic1.png"></p>
<h2 id="常用地图基本类型"><a href="#常用地图基本类型" class="headerlink" title="常用地图基本类型"></a>常用地图基本类型</h2><h3 id="LngLat-：-经纬度坐标，确定地图上的一个点"><a href="#LngLat-：-经纬度坐标，确定地图上的一个点" class="headerlink" title="LngLat ： 经纬度坐标，确定地图上的一个点"></a>LngLat ： 经纬度坐标，确定地图上的一个点</h3><p>构造函数： AMap.LngLat(lng: 119.78, lat: 39.99);<br>生成一个经纬度为[119.78, 39.99]的地理坐标对象。<br>常用方法：  </p>
<pre><code>- getLng()    获取经度
- getLat()    获取纬度
- offset(w:2,s:-3)   w经度，s纬度，参数为数字。将当前经纬度坐标值变化。经度是越向右越大，所以向右为正。同理，纬度越向上越大，所以向上为正。    
- distance(lnglat: LngLat | [lng, lat])  当前经纬度与传入的经纬度的连线的地面距离
- equals(lnglat:LngLat)
</code></pre><h3 id="Bounds：经纬度范围矩形框"><a href="#Bounds：经纬度范围矩形框" class="headerlink" title="Bounds：经纬度范围矩形框"></a>Bounds：经纬度范围矩形框</h3><p>AMap.Bounds(southWest:LngLat1, northEast:LngLat2);<br>生成一个东北角是LngLat2，西南角是LngLat1  的矩形地物框。<br>常用方法：    </p>
<pre><code>- contains(point: LngLat)   给出的经纬度点是否包含在矩形范围内
- getCenter()
- getSouthWest()
- getNorthEast()
</code></pre><h2 id="常用覆盖物"><a href="#常用覆盖物" class="headerlink" title="常用覆盖物"></a>常用覆盖物</h2><h3 id="AMap-Marker"><a href="#AMap-Marker" class="headerlink" title="AMap.Marker"></a>AMap.Marker</h3><ul>
<li>构造：AMap.Marker({ markeroptions })  </li>
<li>常用选项<br><strong>map</strong>:marker所在的地图<br><strong>position</strong>: LngLat类型，点在地图上的位置<br><strong>offset</strong>: 像素类型(-75，-75)，marker距离左上角的偏移<br><strong>content</strong>: string/object  这里可以自定义marker显示的内容，图片，svg等都可以。<br><strong>bubble</strong>: 将覆盖物的事件冒泡到地图上，默认false<br><strong>zIndex</strong>: 叠加顺序<br><strong>title</strong>: 鼠标滑过时，点标记的文字提示。<br><strong>extData</strong>: 用户自定义属性<br><strong>draggable</strong>: 标记点是否可以拖拽移动</li>
<li>方法略多，这里就不写了，基本对应每个选项都会有个get，set方法。hide，show控制点标记的隐藏，还在map中。setMap比较有用，如果设为null，则在地图上移除当前Marker相关的div。还有一些移动类的应用，目前还没使用过，这里就不详述了，主要有：<code>moveAlong</code>, <code>moveTo</code>, <code>stopMove</code>, <code>pauseMove</code>, <code>resumeMove</code>。</li>
<li>事件与地图对象基本一致，少了个ready。多了一些move的行为，<a href="http://lbs.amap.com/api/javascript-api/reference/overlay#Marker" target="_blank" rel="external">具体可参考</a></li>
</ul>
<h3 id="AMap-Polygon"><a href="#AMap-Polygon" class="headerlink" title="AMap.Polygon"></a>AMap.Polygon</h3><ul>
<li>构造：AMap.Polygon({ options })  </li>
<li><p>常用选项<br><strong>map</strong>:marker所在的地图<br><strong>path</strong>: 参数为，包含经纬度数组的数组.  </p>
<pre><code>eg：[
         [116.368904, 39.913423],
        [116.382122, 39.901176],
        [116.387271, 39.912501],
        [116.398258, 39.904600]
    ] 
</code></pre></li>
</ul>
<p>  <strong>bubble</strong>: 将覆盖物的事件冒泡到地图上，默认false。<br>  <strong>zIndex</strong>: 叠加顺序, 默认比marker低。<br>  <strong>类似svg的多边形属性</strong>: strokeColor，strokeOpacity， strokeWeight， fillColor， fillOpacity， strokeStyle， strokeDasharray。<br>  <strong>extData</strong>: 自定义属性</p>
<ul>
<li>方法。对应path，extData， options都会有个get，set方法。hide，show控制多边形的隐藏，多边形还在map中。setMap比较有用，如果设为null，则在地图上移除当前polygon相关的div。getBounds,矩形范围对象，返回Bounds类型。getArea,获取多边形面积。contains(point:LngLat)，点是否在polygon内。</li>
<li>事件很多，常用的又mouseover， click等。<a href="http://lbs.amap.com/api/javascript-api/reference/overlay#Polygon" target="_blank" rel="external">具体可参考</a>  </li>
</ul>
<h3 id="AMap-Circle"><a href="#AMap-Circle" class="headerlink" title="AMap.Circle"></a>AMap.Circle</h3><ul>
<li>构造：AMap.Circle({ options })  </li>
<li><p>常用选项<br><strong>map</strong>:marker所在的地图<br><strong>center</strong>: LngLat类型，圆心在地图上的位置<br><strong>radius</strong>: 半径，number类型，单位是米<br><strong>bubble</strong>: 将覆盖物的事件冒泡到地图上，默认false<br><strong>zIndex</strong>: 叠加顺序, 默认比marker低。<br><strong>extData</strong>: 用户自定义属性<br><strong>类似svg的多边形属性</strong>： 同上polygon</p>
</li>
<li><p>方法。对应center，extData， radius，options都会有个get，set方法。hide，show控制隐藏，还在map中。setMap同上。getBounds，圆外切矩形范围对象，返回Bounds类型。contains(point:LngLat)，点是否在圆内。</p>
</li>
<li>事件类型类似polygon  <a href="http://lbs.amap.com/api/javascript-api/reference/overlay#Circle" target="_blank" rel="external">具体可参考</a></li>
</ul>
<h3 id="AMap-Polyline"><a href="#AMap-Polyline" class="headerlink" title="AMap.Polyline"></a>AMap.Polyline</h3><ul>
<li>构造：AMap.Marker({ markeroptions })  </li>
<li>常用选项，与polygon差不多。多一些线条相关的内容，<a href="http://lbs.amap.com/api/javascript-api/reference/overlay#Polyline" target="_blank" rel="external">具体可参考</a></li>
<li>方法和事件与polygon差不多</li>
</ul>
<h2 id="常用图层"><a href="#常用图层" class="headerlink" title="常用图层"></a>常用图层</h2><p>图层是位于最底层的模块，他可能在地图上的其他物件还没加载完就已经生成了。图层都需要地图以plugin的形式引进。  </p>
<h3 id="AMap-Heatmap"><a href="#AMap-Heatmap" class="headerlink" title="AMap.Heatmap"></a>AMap.Heatmap</h3><p>heatmap是个plugin，需要添加plugin，在回调函数中生成AMap.Heatmap实例。</p>
<pre><code>const heatmap;
map.plugin([&quot;AMap.Heatmap&quot;], function() {
  heatmap = new AMap.Heatmap(map, {
        radius: 25, //给定半径
        opacity: [0, 0.8]
    });
});
</code></pre><p>上面的config，包含<code>radius``gradient``opacity``zooms</code>(支持的缩放级别，不在范围内，就不显示热力图了)<br>渐变可以按照如下设置  </p>
<pre><code>gradient: { 0.4: &apos;red&apos;, 0.8: &apos;yellow&apos;, 1: &apos;blue&apos;}
</code></pre><p><strong>方法</strong><br>与覆盖物的差不多，除了，  </p>
<pre><code>addDataPoint(lng: Lng, lat: Lat, count: number)  
setDataSet(data: obj, url:jsonp格式数据的服务地址，urlDataParser:可以传递函数进行数据转化) 
// 这两个可以配合zoom，不同的zoom，热力图对应的数据集不同。 
</code></pre><p>其中，data格式为：</p>
<pre><code>{ max: number,
  data: [
  { lng: 116.7, lat: 39.9, count: 10 }, 
  { lng: 116.7, lat: 39.9, count: 10 }],
}
</code></pre><h3 id="AMap-CustomLayer"><a href="#AMap-CustomLayer" class="headerlink" title="AMap.CustomLayer"></a>AMap.CustomLayer</h3><p>同样需要plugin来引入。</p>
<p>给出的属性和方法很少，但是功能强大，需要自己开发，<a href="http://lbs.amap.com/api/javascript-api/example/layers/custom-layer/" target="_blank" rel="external">参考实例</a>  </p>
<p>一般是自己做一些canvas，然后挂载在map上即可。<br>自定义图层有个render属性？使其等于绘制函数，就可以在地图上绘制出来。</p>
<h2 id="搜索服务"><a href="#搜索服务" class="headerlink" title="搜索服务"></a>搜索服务</h2><p>支持搜索服务脱离地图使用，即使用搜索服务不再需要先实例化地图。通过AMap.plugin方法，加载需要的服务</p>
<h3 id="AMap-Autocomplete"><a href="#AMap-Autocomplete" class="headerlink" title="AMap.Autocomplete"></a>AMap.Autocomplete</h3><ul>
<li><p>常用选项：<br><strong>city:</strong>输入提示被限定的城市<br><strong>citylimit:</strong> 是否强制限制在设置的城市内搜索<br><strong>input:</strong>指定一个输入框，内容则作为input的id，在input输入文字后，会自动生成一个下拉选择列表。</p>
</li>
<li><p>search方法，可以结合他的search方法，获取数据，然后自己render样式~~</p>
<p>AutocompleteResult对象： </p>
<pre><code>{ info： 状态说明,
  count: 输入提示条数,
  tips: [
    { name: 名称, district: 所属区域, ,adcode: 区域编码},
    { name: 名称, district: 所属区域, ,adcode: 区域编码}...
  ]
}
</code></pre></li>
</ul>
<p>通常autocomplete配合placeSearch进行使用的</p>
<h3 id="AMap-PlaceSearch"><a href="#AMap-PlaceSearch" class="headerlink" title="AMap.PlaceSearch"></a>AMap.PlaceSearch</h3><ul>
<li><p>常用选项：<br><strong>city:</strong>输入提示被限定的城市<br><strong>citylimit:</strong> 是否强制限制在设置的城市内搜索<br><strong>type:</strong>兴趣点类别，可以通过setType设置<br><strong>pageSize:</strong>单页显示结果条数<br><strong>extensions:</strong> ‘all’ 返回基本+详细信息<br><strong>panel&amp;renderStyle</strong>结果列表的html容器id，或者容器元素，结果列表将在给出的容器中进行展示，自己可以render样式。</p>
</li>
<li><p>可用方法见<a href="http://lbs.amap.com/api/javascript-api/reference/search#m_AMap.PlaceSearch" target="_blank" rel="external">参考</a>吧</p>
</li>
</ul>
<p>上个search使用示例：  </p>
<pre><code>html： 
&lt;img
  className={styles.searchIcon}
  src={searchIcon}
  alt=&quot;search&quot;
  onClick={() =&gt; this.handleSearch()}
/&gt;

js:
handleSearch() {
// this.state.placeSearch是个AMap.Autocomplete实例
    this.state.placeSearch.search(this.refs.searchInput.value,             this.handleSearchSelect);
 }

 handleSearchSelect(search, result) {
    if (result.info === &apos;OK&apos;) {
      // mapInstance是个封装了AMap的对象。
      const mapIns = mapInstance.getter();
      // 自定义搜索结果的marker样式。并绘制在地图上
      this.generateSearchMarkers(result.poiList);
      if (result.poiList.pois.length &gt; 0) {
        const { lng, lat } = result.poiList.pois[0].location;
        // 将map的中心定位到获取到的第一个poi的位置上。
        mapIns.setCenter([lng, lat]);
        mapIns.zoomIn();
      }
    }
  }
</code></pre><p> 如果查到结果searchResult有以下内容：<br> <img src="/Users/zcx/Desktop/屏幕快照 2017-05-18 下午2.38.49.png"></p>
<p>其他还有好多具体的搜索的服务。由于没有用到，就没看。。。</p>
<h2 id="信息窗体"><a href="#信息窗体" class="headerlink" title="信息窗体"></a>信息窗体</h2><h3 id="AMap-InfoWindow"><a href="#AMap-InfoWindow" class="headerlink" title="AMap.InfoWindow"></a>AMap.InfoWindow</h3><p>用于在地图上弹出一个详细信息展示窗体，地图上只允许同时展示1个信息窗体  </p>
<ul>
<li>属性<br><strong>isCustom：</strong> 是否自定义窗体，true 则完全按照content中的规定来显示<br><strong>autoMove：</strong> 将窗体完全展现在视图中。<br><strong>closeWhenClickMap: </strong>鼠标点击地图后是否关闭信息窗体<br><strong>position: </strong>信息窗体显示位置，类型为经纬度对象  </li>
<li>方法事件类似polygon，有一些属性的get，set方法，open，close方法。</li>
</ul>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h3 id="AMap-CitySearch"><a href="#AMap-CitySearch" class="headerlink" title="AMap.CitySearch"></a>AMap.CitySearch</h3><p>项目中用到这个api。它主要是根据ip返回对应的城市信息，根据输入ip或自动获取ip来获取城市信息。<br>该api也是个plugin，可以在初始loader地图的时候，就将其配置进去，将脚本加载时的代码。  </p>
<p>两个方法：<br>getLocalCity((status, citySearchResult) =&gt; {…})<br>getCityById(ip, (status, citySearchResult) =&gt; {})</p>
<p>例子：   </p>
<pre><code>// citysearch部分代码，省略地图实例了，用mapIns代替
citysearch.getLocalCity((status, result) =&gt; {
    if (status === &apos;complete&apos; &amp;&amp; result.info === &apos;OK&apos;) {
      if (result &amp;&amp; result.city &amp;&amp; result.bounds) {
        const city = R.slice(0, -1, result.city);
        const cindex = R.indexOf(city, R.pluck(&apos;cityName&apos;, cityList));
        const ccode = R.pluck(&apos;cityCode&apos;, cityList);
        if (cindex !== -1 &amp;&amp; city !== &apos;北京&apos;) {
          mapIns.setCity(city);
          mapIns.setZoom(11);
        }
      }
    }
});
</code></pre><p>citySearchResult 的属性：city， bounds</p>
<h2 id="位置解析"><a href="#位置解析" class="headerlink" title="位置解析"></a>位置解析</h2><h3 id="AMap-Geocoder"><a href="#AMap-Geocoder" class="headerlink" title="AMap.Geocoder"></a>AMap.Geocoder</h3><p>Geocoder是进行地址描述与地理坐标间的相互转换。也就是，给出一个地址名称，转换为地理坐标的经纬度等信息。或者给出一个经纬度，确定这个点的地址名称信息。  </p>
<p>相关方法：</p>
<ul>
<li><p>获取地理编码：<br>getLocation(address:String, (status:String,result:info/GeocodeResult) =&gt; {})</p>
</li>
<li><p>逆地理编码：<br>getAddress(location:LngLat|Array.<lnglat>,<br>(status:String,result:info/ReGeocodeResult) =&gt; {})<br>// 最多20个地址数组。</lnglat></p>
</li>
</ul>
<p>s<br>用的比较多的是逆地理编码，比如自己做一个在地图上点击，然后找出该位置的相关信息。<br>逆地理编码的返回结果属性：想展示什么，就从以下选择吧<br><img src="./pic3.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常用的高德地图api&quot;&gt;&lt;a href=&quot;#常用的高德地图api&quot; class=&quot;headerlink&quot; title=&quot;常用的高德地图api&quot;&gt;&lt;/a&gt;常用的高德地图api&lt;/h1&gt;&lt;p&gt;关于appkey，分为两种，一个是api调用的key，一个是地图服务的key
    
    </summary>
    
    
      <category term="js" scheme="https://misssweety.github.io/tags/js/"/>
    
      <category term="地图api" scheme="https://misssweety.github.io/tags/%E5%9C%B0%E5%9B%BEapi/"/>
    
      <category term="总结" scheme="https://misssweety.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>css3实现3d效果</title>
    <link href="https://misssweety.github.io/2017/05/15/css3%E5%AE%9E%E7%8E%B03d%E6%95%88%E6%9E%9C/"/>
    <id>https://misssweety.github.io/2017/05/15/css3实现3d效果/</id>
    <published>2017-05-15T08:34:12.000Z</published>
    <updated>2017-05-18T07:11:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="css3实现3D效果"><a href="#css3实现3D效果" class="headerlink" title="css3实现3D效果"></a>css3实现3D效果</h2><h3 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h3><ul>
<li>transform: rotateX(…)</li>
<li>transfrom-origin: left center;</li>
<li>transform-style: preserve-3d;</li>
<li>perspective: 200px;</li>
<li>perpective-origin: left center;</li>
<li>backface-visibility: true;</li>
</ul>
<h3 id="3d效果基础知识"><a href="#3d效果基础知识" class="headerlink" title="3d效果基础知识"></a>3d效果基础知识</h3><p>一般是在旋转后才能表现出3d效果，css中规定的旋转规则如下：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="./axis.png" alt="alt axis" title="">
                </div>
                <div class="image-caption">alt axis</div>
            </figure></p>
<p>rotateX是以屏幕的水平方向为轴旋转，rotateY是以屏幕的垂直方向为轴，rotateZ是以与屏幕平面垂直的方向为轴。<br>其实rotatex rotateY已经能实现3d效果了，但是不是很直观。搭配上perspective，perfect！</p>
<h3 id="perspective"><a href="#perspective" class="headerlink" title="perspective"></a>perspective</h3><p>含义：透视效果。指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。等同于绘画中的1点透视||平行透视。<br>一个物体如果z-index为正，那么我们在画布中实际看到的就要偏大。如下第一个图。如果一个物体的z-index为负，那么显示在画布视图中，则偏小，如第二个图<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="./view.png" alt="alt perspective" title="">
                </div>
                <div class="image-caption">alt perspective</div>
            </figure></p>
<p><strong>两种写法:</strong><br><code>a：perspective：300px;</code><br><code>b：transform: perspective(300px) rotateX(aa);</code>  </p>
<p><strong>区别</strong>：第一个需要写在一个父级元素上，他规定了这个父级元素的透视点位置，换个角度说，当为元素规定perspective 属性时，其直接子元素会获得透视效果，而不是元素本身。第二个可以直接作用在当前元素上，也可以结合其他transform属性，规定了当前元素的透视点位置，对其他元素无影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>perspective</strong> 值越大，3d效果越不明显；越小越明显。想像成镜头到物体的距离，越近越能看出高低起伏，越远线条展示的越平缓。<br>两种写法以及perspective对比，<a href="https://codepen.io/akixiao/pen/wdwdgW" target="_blank" rel="external">查看示例</a></p>
<h3 id="webkit-perspective-origin"><a href="#webkit-perspective-origin" class="headerlink" title="-webkit-perspective-origin"></a>-webkit-perspective-origin</h3><p>消失点的位置，<br>语法：<code>-webkit-perspective-origin: xpos ypos</code><br>xpos,ypos 可以选择关键字，left|right|center     top|bottom|center 。如果是关键字，则是否对应xy无关紧要，浏览器会自己选择。如果是数值，百分比或者像素，则要按照x，y的顺序写。<br><a href="https://codepen.io/akixiao/pen/qmWeqj" target="_blank" rel="external">参考实例</a></p>
<h3 id="backface-visibility"><a href="#backface-visibility" class="headerlink" title="backface-visibility"></a>backface-visibility</h3><p><code>backface-visibility</code> 属性定义当元素不面向屏幕时是否可见。有些时候前面的div如果设置了透明度，就会看到后面的对象，这是可以将该属性设为hidden就可以了。默认：<code>visible</code></p>
<h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>这里主要提和3d有关的几个属性  </p>
<ul>
<li>rotateX( angle )</li>
<li>rotateY( angle )</li>
<li>rotateZ( angle )</li>
<li>translateZ( tz )</li>
<li>scaleZ( sz )</li>
<li>translateZ，scaleZ会将对象在与屏幕平行的方向变化物体。会有失真。</li>
</ul>
<p>也有综合的写法：  </p>
<ul>
<li>translate3d( tx, ty, tz )</li>
<li>scale3d( sx, sy, sz )</li>
<li>rotate3d( rx, ry, rz, angle )</li>
</ul>
<p>rotate3d这里，前三个规定旋转轴在空间中的方向，比如x轴，就是（1，0，0）<br><code>rotate3d(1,0,0,90deg)   ===  rotateX(90deg)</code></p>
<h3 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h3><p>规定变化的中心点。一般都是对象的重心。可以修改成任意的值，以旋转为例:</p>
<pre><code>html
&lt;div class=&quot;test1&quot;&gt;test&lt;/div&gt;
&lt;div class=&quot;test2&quot;&gt;test2&lt;/div&gt;
css
div {
  width:200px;
  height: 200px;
  background: rgba(255, 0, 0,.5);
  margin: 20px auto;
  animation: mymove 3s infinite;
}
.test1{
  transform: perspective(500px) rotateY(0deg);
}
.test2 {
  transform-origin: left;
  transform: perspective(500px) rotateY(0deg);
}

@keyframes mymove
{
  from {transform: perspective(500px) rotateY(0deg);}
  to {transform:perspective(500px) rotateY(360deg);}
}
</code></pre><p>表现是：test1将沿着div的宽度的一半为轴旋转。test2则沿着最左边的边框为轴旋转。<br><a href="https://codepen.io/akixiao/pen/mmdKYJ?editors=0100" target="_blank" rel="external">参考实例</a></p>
<h3 id="实例一：翻牌效果"><a href="#实例一：翻牌效果" class="headerlink" title="实例一：翻牌效果"></a>实例一：翻牌效果</h3><pre><code>&lt;div class=&quot;container&quot;&gt;
  &lt;div id=&quot;card&quot;&gt;
    &lt;div class=&quot;front&quot;&gt;1&lt;/div&gt;
    &lt;div class=&quot;back&quot;&gt;2&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

//css,设置一个container，他是个具有3d效果的box
.container {
  width: 200px;
  height: 200px;
  position: relative;
  perspective: 800px;
  border: 1px solid #888;
  margin: 40px auto;
}
#card {
  width: 100%;
  height: 100%;
  position: absolute;
  transform-style: preserve-3d;
  animation: flip 2s infinite;
  transform-origin: left center;
}
#card figure {
  display: block;
  width: 100%;
  height: 100%;
  position: absolute;
  text-align: center;
  color: white;
  font-size: 40px;
  line-height: 200px;
  backface-visibility: hidden;
}
.front {
  background: tomato;

}
.back {
  background: lightblue;
  transform: rotateY( 180deg );
}

@keyframes flip {
  0% {
    transform: rotateY( 0deg );
  }
  50% {
    transform: rotateY( 180deg ) translateX(-100%);
  }
  100% {
    transform: rotateY( 360deg )
  }
}
</code></pre><p>container中的card div具有3d效果，如果想让card中的div等也有3d变化效果，可以通过对card设置： <code>transform-style: preserve-3d;</code> 将其父元素的3d透视集成下来，并使所有子元素保持在同一个3d空间中。背面那张牌需要翻到背面去，也就是<code>rotateY( 180deg );</code><br><a href="http://codepen.io/akixiao/pen/WjeWqQ" target="_blank" rel="external">参考示例</a></p>
<p>###实例二：旋转的正方体<br><a href="http://codepen.io/akixiao/pen/gWYNZo" target="_blank" rel="external">参考示例</a><br>六个div拼凑起来的。分别在xy方向上进行翻转，立到对应的方向。此时在添加一个<code>translateZ</code>才能显现出他们的效果。否则都是堆在zindex为0的位置，什么都看不见.  </p>
<p>别的配置及思想同上面的翻牌</p>
<p>###常见问题：<br>1.设了transfrom-style:preserve-3d为什么还不好使。  </p>
<p>这个时候需要查看父元素是否还设了，<code>overflow，filter，clip，isolation，clip-path，mask-image，mask-box-image-source， mix-blend-mode</code>，如果不是默认值的，会将transfrom-style:preserve-3d 失效。原因是前几个属性，会创造一个flatten的box，而preserve-3d是生成stacking context  的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;css3实现3D效果&quot;&gt;&lt;a href=&quot;#css3实现3D效果&quot; class=&quot;headerlink&quot; title=&quot;css3实现3D效果&quot;&gt;&lt;/a&gt;css3实现3D效果&lt;/h2&gt;&lt;h3 id=&quot;相关属性&quot;&gt;&lt;a href=&quot;#相关属性&quot; class=&quot;head
    
    </summary>
    
    
      <category term="css" scheme="https://misssweety.github.io/tags/css/"/>
    
      <category term="perspective" scheme="https://misssweety.github.io/tags/perspective/"/>
    
      <category term="3D效果" scheme="https://misssweety.github.io/tags/3D%E6%95%88%E6%9E%9C/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-闭包</title>
    <link href="https://misssweety.github.io/2017/05/08/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E9%97%AD%E5%8C%85/"/>
    <id>https://misssweety.github.io/2017/05/08/读书笔记-闭包/</id>
    <published>2017-05-08T03:11:08.000Z</published>
    <updated>2017-05-18T07:11:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="经典闭包"><a href="#经典闭包" class="headerlink" title="经典闭包"></a>经典闭包</h2><p>闭包是一个函数（引用），即使他是在当前词法作用域之外执行，他也可以记住并访问所在的词法作用域。就是用这个引用来访问。<br><a href="https://jsbin.com/duyotivalu/1/edit?js,console,output" target="_blank" rel="external">参考</a></p>
<pre><code>function foo () {
  const a = 9;
  const bar = () =&gt; {return a;}
  return bar;
}

const aa = foo();
console.log(aa());
</code></pre><p>返回9；  </p>
<p><strong>解析</strong><br>在<code>foo()</code>执行后，其返回值赋值给变量aa，并执行<code>aa()</code>，其实是通过不同的标识符引用调用了内部函数<code>bar()</code>。bar在其词法作用域外被正常执行了。而且foo函数执行后，通常整个foo内部作用域都被销毁，但是由于bar的存在，是的内部作用域依然存在，组织了垃圾回收。<br><code>bar()</code> 拥有涵盖<code>foo()</code>内部作用域的闭包，使得该作用域能一直存活。<code>bar()</code>依然持有对该作用域的饮用，这个引用就叫做<strong>闭包</strong>。  </p>
<p>如果将函数当作第一级的值类型进行传递，其实就会有闭包的存在。<br>一些异步或者同步操作中，使用了回调函数，也是在使用闭包。  </p>
<p><em>无处不在</em></p>
<p>本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在<code>定时器</code>、<code>事件监听器</code>、 <code>Ajax请求</code>、<code>跨窗口通信</code>、<code>Web Workers</code>或者<code>任何其他的异步(或者同步)任务</code>中，只要使用了<code>回调函数</code>，实际上就是在使用闭包.  </p>
<p>最常见的考题</p>
<pre><code>for (var i = 1; i&lt;= 5; i++) {
  setTimeout(() =&gt;console.log(i), 1000*i);
}
</code></pre><p>输出是：五个6</p>
<p>原因：i是全局变量，setTimeout是等待执行。延迟函数的回调会在循环结束时才执行,执行的时候i已经跳出循环，第一个满足的值就是6.所以输出5个6.</p>
<p>修改：将var 改为let。只在当时的循环中生效。可以每秒输出12345</p>
<p>另外一个应用：<br>模块</p>
<p>从方便观察的角度看，一个从函数调用 所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。</p>
<p>实例：</p>
<pre><code>function CoolModule() {
  var something = &quot;cool&quot;;
  var another = [1, 2, 3];
   function doSomething() { console.log( something ); }
  function doAnother() {
    console.log( another.join( &quot; ! &quot; ) );
  }         
  return {
    doSomething: doSomething, doAnother: doAnother
  };
}
var foo = CoolModule(); foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
</code></pre><p>上一个示例代码中有一个叫作 CoolModule() 的独立的模块创建器，可以被调用任意多次， 每次调用都会创建一个新的模块实例。<br>如果想实现单例模式：<br>就是将coolmodule 转换为iife，并赋予一个标识符：</p>
<pre><code>var foo = (...)();
foo.doSomething();
foo.doAnother(); 结果同上
</code></pre><p>  模块有两个主要特征:(1)为创建内部作用域而调用了一个包装函数;(2)包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。   </p>
<h4 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h4><pre><code>function foo() {
  console.log( a ); // 2
}
function bar() {
  var a = 3;
  foo();
}
var a = 2;
bar();
</code></pre><p>输出结果：2。词法作用域，运行bar，到foo的时候，这里的a是全局变量的a，所以为2.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;经典闭包&quot;&gt;&lt;a href=&quot;#经典闭包&quot; class=&quot;headerlink&quot; title=&quot;经典闭包&quot;&gt;&lt;/a&gt;经典闭包&lt;/h2&gt;&lt;p&gt;闭包是一个函数（引用），即使他是在当前词法作用域之外执行，他也可以记住并访问所在的词法作用域。就是用这个引用来访问。&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://misssweety.github.io/tags/js/"/>
    
      <category term="闭包" scheme="https://misssweety.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>linux 目录结构</title>
    <link href="https://misssweety.github.io/2017/05/08/linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/"/>
    <id>https://misssweety.github.io/2017/05/08/linux文件目录/</id>
    <published>2017-05-08T02:46:56.000Z</published>
    <updated>2017-05-08T03:11:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>原来学linux的时候，不上心，现在后悔莫及，开始补基础。<br>首先是最基本的目录结构。<br>linux是树状结构  </p>
<p><strong>标橘色为重要目录</strong></p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>／</td>
<td>根目录，整个文件系统层次结构的根目录，一般只放目录</td>
</tr>
<tr>
<td>/bin/</td>
<td>类似 <code>/usr/bin</code> 可执行的二进制文件的目录，常用的ls，tar，mv， cat等</td>
</tr>
<tr>
<td>/boot/</td>
<td>引导程序文件，放置linux系统启动时用到的一些文件</td>
</tr>
<tr>
<td><font color="orange">/dev/</font></td>
<td>存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备</td>
</tr>
<tr>
<td><font color="orange">/etc/</font></td>
<td>系统配置文件存放的目录,不建议在此目录下存放可执行文件，重要的配置文件</td>
</tr>
<tr>
<td><font color="orange">/home/</font></td>
<td>系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下, 建议单独分区，并设置较大的磁盘空间</td>
</tr>
<tr>
<td>/lib/,/usr/lib/, /usr/local/lib/</td>
<td>系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为/lib/modules</td>
</tr>
<tr>
<td>/lost+fount/</td>
<td>系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。</td>
</tr>
<tr>
<td>/mnt/</td>
<td>临时挂载的文件系统。比如cdrom,u盘等，直接插入光驱无法使用，要先挂载后使用</td>
</tr>
<tr>
<td>/opt/</td>
<td>给主机额外安装软件所摆放的目录, 可选应用软件包。</td>
</tr>
<tr>
<td><font color="orange">/proc/</font></td>
<td>此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间.比较重要的目录有/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*等</td>
</tr>
<tr>
<td>/root/</td>
<td>超级权限用户的家目录</td>
</tr>
<tr>
<td><font color="orange">/sbin:/usr/sbin:/usr/local/sbin</font></td>
<td>放置系统管理员使用的可执行命令，如fdisk、shutdown、mount等。sbin目录下的命令，普通用户都执行不了。</td>
</tr>
<tr>
<td>/tmp/</td>
<td>一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下,在系统重启时目录中文件不会被保留。</td>
</tr>
<tr>
<td>/srv/</td>
<td>服务启动之后需要访问的数据目录，如www服务需要访问的网页数据存放在/srv/www内</td>
</tr>
<tr>
<td><font color="orange">/usr/</font></td>
<td>默认软件都会存于该目录下。用于存储只读用户数据的第二层次；包含绝大多数的(多)用户工具和应用程序。</td>
</tr>
<tr>
<td><font color="orange">/var/</font></td>
<td>变量文件——在正常运行的系统中其内容不断变化的文件，如随时更改的日志文件 /var/log，/var/log/message： 所有的登录文件存放目录，/var/spool/mail： 邮件存放的目录， /var/run: 程序或服务启动</td>
</tr>
</tbody>
</table>
<h3 id="etc-目录"><a href="#etc-目录" class="headerlink" title="/etc/目录"></a>/etc/目录</h3><p>未完待续。。。<br><a href="http://yangrong.blog.51cto.com/6945369/1288072" target="_blank" rel="external">参考</a><br><a href="http://www.iteye.com/topic/1125162" target="_blank" rel="external">参考二</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原来学linux的时候，不上心，现在后悔莫及，开始补基础。&lt;br&gt;首先是最基本的目录结构。&lt;br&gt;linux是树状结构  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标橘色为重要目录&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;描
    
    </summary>
    
    
      <category term="linux" scheme="https://misssweety.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>export相关</title>
    <link href="https://misssweety.github.io/2017/04/18/exports/"/>
    <id>https://misssweety.github.io/2017/04/18/exports/</id>
    <published>2017-04-18T03:01:45.000Z</published>
    <updated>2017-05-18T07:11:50.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="exports-和-module-exports-的区别"><a href="#exports-和-module-exports-的区别" class="headerlink" title="exports 和 module.exports 的区别"></a>exports 和 module.exports 的区别</h3><p><code>exports</code> 是引用 <code>module.exports</code> 的值。<code>module.exports</code> 被改变的时候，<code>exports</code>不会被改变，而模块导出的时候，真正导出的执行是<code>module.exports</code>，而不是<code>exports</code>。</p>
<p>有以几点需要记住：</p>
<p>module.exports 初始值为一个空对象 {}<br>exports 是指向的 module.exports 的引用<br>require() 返回的是 module.exports 而不是 exports<br>如果module.exports 当前没有任何属性的话，exports会把属性收集起来赋给module.exports。<br>如果module.exports 有属性的话, exports中的所有内容都会被忽略。</p>
<pre><code>foo.js
exports.a = function(){
  console.log(&apos;a&apos;)
}

module.exports = {a: 2}
exports.a = 1 

test.js
var x = require(&apos;./foo&apos;);
console.log(x.a);
输出 ：2


如果：foo.js 为：
exports.a = function(){
  console.log(&apos;a&apos;)
}
exports.a = 1

test.js 输出：1


如果：foo.js为：
exports.a = function(){
  console.log(&apos;a&apos;)
}
test.js 输出：[Function]
</code></pre><p>首先，node中的require 引进的是module.exports。。。见第一个实例。如果没有显式的写module.exports，则自动连接exports与module.exports。如果显示的写了module.exports，则会断开module.exports 与 exports 的联系。</p>
<p>应用的话，如果只是导出某个变量或者某个功能，用exports.属性|方法。<br>如果是导出多个属性或方法或使用对象构造方法，module.module 比较好。</p>
<h4 id="export-default-和-export-区别"><a href="#export-default-和-export-区别" class="headerlink" title="export default 和 export 区别"></a>export default 和 export 区别</h4><p>1.export与export default均可用于导出常量、函数、文件、模块等<br>2.你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用<br>3.在一个文件或模块中，export、import可以有多个，export default仅有一个<br>4.通过export方式导出，在导入时要加{ }，export default则不需要</p>
<p>引入时：<br>加了default的变量，可以起任意名字，<br>非default的需要与export时的名字相同。</p>
<h4 id="module-exports-vs-export"><a href="#module-exports-vs-export" class="headerlink" title="module.exports vs export"></a>module.exports vs export</h4><p>commonjs：module.exports   搭配的引入： require<br>es6: export               搭配的引入：  import</p>
<p>普通js环境下是不支持es6的语法的，如果想这么用，需要用babel等进行转译。</p>
<p>es6 <code>default</code> export 其实是与exports 等价的，只不过 <code>default</code> 只是一个保留的名称，可以想象为，exports 一个属性，属性名为default。所以如果是在node.js环境下，用的export default， 引用的时候用require的话，需要这么写：  </p>
<p>var bar = require(‘./input’).default;</p>
<p><code>export</code>  vs  <code>export default</code><br>这两个在import的时候，前者需要用{} 扩起来，有种解构的感觉。后者不需要{}扩。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;exports-和-module-exports-的区别&quot;&gt;&lt;a href=&quot;#exports-和-module-exports-的区别&quot; class=&quot;headerlink&quot; title=&quot;exports 和 module.exports 的区别&quot;&gt;&lt;/a&gt;ex
    
    </summary>
    
    
      <category term="js" scheme="https://misssweety.github.io/tags/js/"/>
    
      <category term="node.js" scheme="https://misssweety.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>Visual-Formatting-Model</title>
    <link href="https://misssweety.github.io/2017/04/17/Visual-Formatting-Model/"/>
    <id>https://misssweety.github.io/2017/04/17/Visual-Formatting-Model/</id>
    <published>2017-04-17T04:00:00.000Z</published>
    <updated>2017-04-26T03:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-视觉格式化模型-introduction"><a href="#1-视觉格式化模型-introduction" class="headerlink" title="1.视觉格式化模型 introduction"></a>1.视觉格式化模型 introduction</h2><p>视觉格式化模型：<code>User Agent</code> 如何在 <code>Visual Media</code>下处理文档树。</p>
<p>视觉格式化模型中，文档树中的每一个元素根据盒模型 <code>Box Model</code> 产生零个或多个盒。这些盒的布局由以下内容控制：</p>
<ul>
<li>盒的尺寸和类型</li>
<li>定位体系 Positioning Scheme （常规流，浮动和绝对定位）</li>
<li>文档树中元素之间的关系</li>
<li>外部信息（如：视口大小，图片的固有尺寸等）</li>
</ul>
<h3 id="1-1-视口-viewport"><a href="#1-1-视口-viewport" class="headerlink" title="1.1 视口 viewport"></a>1.1 视口 viewport</h3><p>连续媒体 <code>Continuous Media</code> 上工作的<code>user agent</code>一般会向用户提供一个<code>viewport</code>（屏幕上的一个窗口或其它可视区域）来帮助用户访问文档。<code>user agent</code>可以在调整视口大小的同时改变文档的布局</p>
<h3 id="1-2-包含块-containing-blocks"><a href="#1-2-包含块-containing-blocks" class="headerlink" title="1.2 包含块 containing blocks"></a>1.2 包含块 containing blocks</h3><p>CSS2.1中，许多盒的定位和大小都根据一个名为包含块 <code>Containing Block</code> 的矩形盒的边缘来计算。生成的盒会充当其后代盒的包含块；我们称盒为其后代“创建”了包含块。说“盒的包含块”即是说“盒所处的包含块”，而不是盒所产生的包含块。</p>
<h2 id="2-盒的生成-Controlling-Box-Generation"><a href="#2-盒的生成-Controlling-Box-Generation" class="headerlink" title="2 盒的生成 Controlling Box Generation"></a>2 盒的生成 Controlling Box Generation</h2><p>display指定盒的类型</p>
<p>有几个概念：  </p>
<ul>
<li><code>block-level box</code>: display：block|table|list-item</li>
<li><code>block box</code>: 除了table块盒和可替换元素，其他的都是块容器盒。也是块盒。</li>
<li><code>block container box</code>: 一个块容器盒要么只包含块级盒，要么创建一个行内格式化上下文 <code>Inline Formatting Context</code> 并只包含行内级盒 <code>Inline-level Boxes</code>。不一定是block的才是，行内也是。所以和块级盒只是一部分有交集。</li>
</ul>
<h2 id="3-定位体系-Position-schemes"><a href="#3-定位体系-Position-schemes" class="headerlink" title="3 定位体系 Position schemes"></a>3 定位体系 Position schemes</h2><p>在<code>css2.1</code>中，一个<code>box</code>有三种机制来布局  </p>
<ul>
<li>normal flow：块级formatting, 行级formatting，相对定位</li>
<li>float：box先按照normal flow放置，然后从流中脱离出来，可能会对后面的排序有影响</li>
<li>absolute position：完全脱离出文档流，对之后的元素没有影响</li>
</ul>
<p>[<code>脱离文档流</code>] float， absolutely positioned， 根元素。</p>
<h3 id="3-1-position-属性"><a href="#3-1-position-属性" class="headerlink" title="3.1 position 属性"></a>3.1 position 属性</h3><p>属性：  </p>
<ul>
<li>static：<br>top right等并不生效</li>
<li>relative：<br>盒的定位根据常规流计算（盒被成为常规流内定位）。盒相对其常规位置移动。当B盒相对定位，B盒之后的盒定位时就当B没有移动一样来计算。table相关的内盒并没有relative属性</li>
<li>absolute：<br>位置大小通过top，right等定义。脱离文档流了，即便绝对定位盒有外边距，也不同其他任何外边距折叠。</li>
<li>fixed：<br>盒的定位根据 absolute 模型来计算，但除此之外，盒相对某些参照物保持固定。<br>【用户代理不可将固定盒的内容分页显示。注意用户代理可能用其他方法打印不可见内容。参见第13章“页盒外的内容”】</li>
</ul>
<h2 id="4-常规流-Normal-Flow"><a href="#4-常规流-Normal-Flow" class="headerlink" title="4 常规流 Normal Flow"></a>4 常规流 Normal Flow</h2><p>常规流中的盒子都属于某个<code>格式化上下文</code>，要么<code>块格式化上下文BFC</code>，要么<code>行内格式化上下文LFC</code>，总之不能二者得兼。</p>
<p>###4.1 bfc  </p>
<ul>
<li>浮动</li>
<li>绝对定位元素、</li>
<li>非块盒的块容器（如：行内块 inline-block 、表格单元格 table-cell 以及表格标题 table-caption ）</li>
<li>以及 overflow 属性不为 visible 的块盒（除了该值被传播到视口的情况）</li>
</ul>
<p>将为其内容创建一个新的块级格式化上下文。</p>
<p>在块格式化上下文中:</p>
<ul>
<li>盒从包含块顶部一个接一个地垂直摆放。</li>
<li>两个同胞盒间的垂直距离取决于 margin 属性。</li>
<li>同一个块格式化上下文中的相邻块级盒的垂直外边距将折叠。</li>
<li>每个盒的左外边缘紧贴包含块的左边缘。</li>
</ul>
<p>###4.2 lfc</p>
<p>盒从包含块顶部一个接一个的水平摆放。盒的垂直对齐方式则不一：可能按底部或者顶部对齐，又或者按它们内容文本的基线对齐。</p>
<ul>
<li>行盒的宽度取决于包含块以及浮动。</li>
<li>行盒的高总是足以容纳其包含的所有盒，当一个盒（ B ）的高度小于包含它的行盒的高度时， B 的垂直对齐方式由 vertical-align 属性决定。</li>
<li>当一行不能包含所有时，它们会被分配到两个或者多个垂直摆放的行盒中，变成垂直堆叠。行盒的堆叠没有垂直间距（除非有特别声明）并且从不重叠。</li>
<li>一般行内盒超过行盒宽度是，行内盒会被分在多个行盒中。</li>
<li>如果一个行内盒不可切割（比如，行内盒包含的是单个字符或者语言指定的断字规则不允许断字，又或者行内盒的 white-space 属性值为 nowrap 或 pre ），那么该【行内盒将溢出行盒】。</li>
</ul>
<p>###4.3 相对定位<br>对于相对定位而言，<code>left</code> 和<code>right</code>使其发生水平位移。而且满足：left = - right。所以如果两个都定义了，则必有一个被忽略。<br>top bottom同理，top胜。</p>
<h2 id="5-浮动-floats"><a href="#5-浮动-floats" class="headerlink" title="5 浮动 floats"></a>5 浮动 floats</h2><p>浮动盒将被移动至左侧或右侧直至其外侧紧贴包含盒的边缘或另外一个浮动的外边缘。如果存在行盒，浮动盒的顶部外边缘将与行盒的顶部对齐。</p>
<p>float内元素的margin不会与包含他的发生垂直边距折叠。</p>
<p>clear 清除浮动</p>
<p><a href="https://segmentfault.com/a/1190000003096320#articleHeader5" target="_blank" rel="external">https://segmentfault.com/a/1190000003096320#articleHeader5</a></p>
<p>[link]<a href="https://www.w3.org/TR/CSS2/visuren.html#block-formatting" target="_blank" rel="external">https://www.w3.org/TR/CSS2/visuren.html#block-formatting</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-视觉格式化模型-introduction&quot;&gt;&lt;a href=&quot;#1-视觉格式化模型-introduction&quot; class=&quot;headerlink&quot; title=&quot;1.视觉格式化模型 introduction&quot;&gt;&lt;/a&gt;1.视觉格式化模型 introducti
    
    </summary>
    
    
      <category term="css" scheme="https://misssweety.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>thinking-with-join</title>
    <link href="https://misssweety.github.io/2017/03/09/thinking-with-join/"/>
    <id>https://misssweety.github.io/2017/03/09/thinking-with-join/</id>
    <published>2017-03-09T14:16:48.000Z</published>
    <updated>2017-04-26T04:21:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>下面这段代码是我们最常用的，为每个数据生成一个circle，调用数据里的x，y来定位。但是我们selectAll的元素，此时并不存在，那d3是如何工作的呢?</p>
<blockquote>
<p>svg.selectAll(“circle”)<br>  .data(data)<br>  .enter().append(“circle”)<br>    .attr(“cx”, function(d) { return d.x; })<br>    .attr(“cy”, function(d) { return d.y; })<br>    .attr(“r”, 2.5);</p>
</blockquote>
<p>在d3中，告诉d3你想要什么，而不是告诉d3怎样做什么。对于上面这个需求，我们要做的就是，我想要circle对应于数据，每个circle对应于一个数据，而不是告诉d3，你应该给我创造一个circle，然后告诉d3选择的circle应该和数据对应好。<br>这个原则就叫做<strong>data join</strong></p>
<svg width="720" height="240" version="1.1" xmlns="http://www.w3.org/2000/svg"><br/>  <g transform="translate(0,128)"><br/>    <g transform="translate(300)"><br/>      <circle r="110" style="fill: rgba(49, 130, 189,.2);" stroke="black"/><br/>      <text y="-120" dy=".35em" text-anchor="middle" style="font-weight: bold;">Data</text><br/>      <text x="-50" dy=".35em" text-anchor="middle">Enter</text><br/>    </g><br/>    <text x="360" dy=".35em" text-anchor="middle">Update</text><br/>    <g transform="translate(420)"><br/>      <circle r="110" style="fill: rgba(230, 85, 13,.2);" stroke="black"/><br/>      <text y="-120" dy=".35em" text-anchor="middle" style="font-weight: bold;">Elements</text><br/>      <text x="50" dy=".35em" text-anchor="middle">Exit</text><br/>    </g><br/>  </g><br/></svg>

<p>连接到现有元素的数据点生成update（内部）选择。剩余未绑定数据生成enter选择（左），表示缺少的元素。同样，任何剩余的未绑定元素会生成exit选择（右），表示要删除的元素。</p>
<p>现在，我们可以通过data join 来揭开enter-append序列的谜团了</p>
<ol>
<li><code>svg.selectAll(&quot;circle&quot;)</code> 返回一个新的空<code>selection</code>，因为SVG容器是空的，所以该<code>selection</code>的父节点是SVG容器</li>
<li>然后此<code>selection</code>连接到数据数组，生成三个新<code>selection</code>分别表示三种可能的状态：<code>enter</code>，<code>update</code>和<code>exit</code>。由于<code>selection</code>为空，所以<code>update</code>和<code>exit</code>选择为空，而<code>enter selection</code>包含每个新数据的占位符。</li>
<li><code>update selection</code>通过<a href="https://github.com/d3/d3-selection/blob/master/README.md#selection_data" target="_blank" rel="external">selection.data</a>返回,而<code>enter</code>和<code>exit selection</code>挂起<code>update selection</code>; <a href="https://github.com/d3/d3-selection/blob/master/README.md#selection_enter" target="_blank" rel="external">selection.enter</a>返回<code>enter selection</code>。</li>
<li>通过在<code>enter selection</code>上调用<a href="https://github.com/d3/d3-selection/blob/master/README.md#selection_append" target="_blank" rel="external">selection.append</a>，将缺少的元素添加到SVG容器。这会为每个数据点向SVG容器添加一个新圆。</li>
</ol>
<p><em>Thinking with joins</em> 意味着在一个selection和数据集中声明一种关系，然后通过<code>enter</code>, <code>update</code>, <code>exit</code>实现这个关系.</p>
<p>但是为什么会这么麻烦呢？为什么不一开始就创建多个元素呢？data join的美丽在于它的泛化。虽然上述代码只处理<code>enter selection</code>,这就可以处理静态可视化了，但是你可以将其扩展为支持动态可视化，只需对<code>update</code>和<code>exit</code>进行少量修改。这意味着您可以对<a href="https://bost.ocks.org/mike/path/" target="_blank" rel="external">实时数据</a>进行可视化，允许<a href="http://bl.ocks.org/mbostock/4063663" target="_blank" rel="external">交互式探索</a>，以及在数据集之间<a href="http://bl.ocks.org/mbostock/1256572" target="_blank" rel="external">平滑过渡</a>！</p>
<p>看下包含三个状态的例子：</p>
<blockquote>
<p>var circle = svg.selectAll(“circle”)<br>  .data(data);<br>circle.exit().remove();<br>circle.enter().append(“circle”)<br>  .attr(“r”, 2.5)<br>  .merge(circle)<br>  .attr(“cx”, function(d) { return d.x; })<br>  .attr(“cy”, function(d) { return d.y; });</p>
</blockquote>
<p>无论何时运行此代码，它都会重新计算数据连接并保持元素和数据之间的所需对应关系。如果新数据集小于旧数据集，则剩余元素将在退出选择中结束并被删除。如果新数据集较大，剩余数据将在输入选择中结束，并添加新节点。如果新数据集的大小完全相同，那么所有元素都将使用新位置进行更新，并且不会添加或删除任何元素。</p>
<p><code>thinking with join</code>用连接来思考意味着你的代码更具声明性：你处理这三个状态没有任何分支（if）或迭代（for）。而是描述元素应如何对应数据。如果给定的<code>enter</code>，<code>update</code>或<code>exit selection</code>恰好是空的，则相应的代码是无操作</p>
<p>连接还允许将操作定向到特定状态（如果需要）。例如，你可以在enter而不是update上设置常量属性（例如由“r”属性定义的圆的半径）。通过重新选择元素和最小化DOM更改，您大大提高了渲染性能！同样，您可以将动画过渡指定为特定状态。例如，在entering状态，加入动画<a href="https://jsbin.com/vubibuvaqo/1/edit?html,output" target="_blank" rel="external">圆圈展开</a></p>
<p>大致翻译自：<a href="https://bost.ocks.org/mike/join/" target="_blank" rel="external">thinking with join</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面这段代码是我们最常用的，为每个数据生成一个circle，调用数据里的x，y来定位。但是我们selectAll的元素，此时并不存在，那d3是如何工作的呢?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;svg.selectAll(“circle”)&lt;br&gt;  .data(dat
    
    </summary>
    
    
      <category term="d3" scheme="https://misssweety.github.io/tags/d3/"/>
    
      <category term="translate" scheme="https://misssweety.github.io/tags/translate/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建</title>
    <link href="https://misssweety.github.io/2016/10/27/blog-publish/"/>
    <id>https://misssweety.github.io/2016/10/27/blog-publish/</id>
    <published>2016-10-27T04:00:00.000Z</published>
    <updated>2017-04-26T04:23:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>适用于macOS</p>
<p>###1.需要安装git，npm，node<br>升级本地npm</p>
<pre><code>npm install npm@latest -g
如果有权限问题，前面加上sudo就可以了
</code></pre><p>###2.安装hexo</p>
<pre><code>sudo npm install -g hexo
全局安装了
</code></pre><p>###3.hexo管理一个网站</p>
<pre><code>hexo init blog
名字随自己喜欢，这里起的事blog
</code></pre><p>###4.进入该文件，进行管理</p>
<pre><code>cd blog
hexo server //启动你的本地网站，访问localhost:4000，就可以看到雏形了
hexo new &quot;hello world&quot; //生成一个hello world.md文件，新新文章，添加到网站中
</code></pre><p>###5.部署到github上</p>
<p>####git上建立仓库<br>先在自己的库里创建一个新的repo,作为网站的远端库，一般命名为自己的账号名，例如：</p>
<p>  我的账号<font color="purple"><code>missSweety</code></font>，新建的repo为<font color="purple"><code>missSweety.github.io</code></font></p>
<p>####修改hexo配置文件<br>回到hexo中，为了部署到github上，我们需要修改<font color="purple"><code>_config.yml</code></font>文件如下：</p>
<pre><code>deploy:
  type: git
  repository: https://github.com/MissSweety/MissSweety.github.io.git
  branch: master
</code></pre><p>####安装hexo deployer git<br>    npm install hexo-deployer-git –save<br>如果不安装这个，deploy的时候会报错的</p>
<p>####hexo deploy<br>    hexo deploy<br>如果没配过ssh，还是会报错的<br>解决方法：</p>
<pre><code>ssh-keygen -t rsa -b 4096 -C ‘email’
</code></pre><p>按照提示，输入账号，密码，就会生成文件了<br>回到github网站，在setting中把公钥放进去  </p>
<pre><code>ssh -T git@github.com
</code></pre><p>用该指令可以查看是否已经鉴权了</p>
<font color="lightblue">如果以上都好了，这次在用hexo deploy,就会自动push代码，并发布了，可以查看你的网站了</font>

<p>###大功告成!!!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;适用于macOS&lt;/p&gt;
&lt;p&gt;###1.需要安装git，npm，node&lt;br&gt;升级本地npm&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install npm@latest -g
如果有权限问题，前面加上sudo就可以了
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;###2.安装hex
    
    </summary>
    
    
      <category term="hexo" scheme="https://misssweety.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
