[{"title":"vue-cli3之部分配置","date":"2019-11-10T12:29:07.000Z","path":"2019/11/10/vue-cli3之部分配置/","text":"最近开始弄vue了，通过vue-cli3 我们可以快速生成使用 vue的单页应用。但是vue-cli3将babel，webpack等配置信息都封装起来了，很多配置不知道怎么改了。 下面写一些有用的配置。 vue.config.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// vue.config.js module.exports = &#123; publicPath: './', // 基本路径 outputDir: 'dist', // 输出文件目录 lintOnSave: false, // eslint-loader 是否在保存的时候检查 // see https://github.com/vuejs/vue-cli/blob/dev/docs/webpack.md // webpack配置 chainWebpack: config =&gt; &#123; if (process.env.use_analyzer) &#123; config .plugin(\"webpack-bundle-analyzer\") .use(require(\"webpack-bundle-analyzer\").BundleAnalyzerPlugin); // 加个包分析的工具，可以这样写。 &#125; config.module .rule('vue') .use('vue-loader') .loader('vue-loader') .tap(options =&gt; &#123; // 修改一些loader return options; &#125;); &#125;, configureWebpack: (config) =&gt; &#123; if (process.env.NODE_ENV === 'production') &#123; // 为生产环境修改配置... config.mode = 'production' &#125; else &#123; // 为开发环境修改配置... config.mode = 'development' &#125; Object.assign(config, &#123; // 开发生产共同配置 resolve: &#123; alias: &#123; '@': path.resolve(__dirname, './src'), '@c': path.resolve(__dirname, './src/components'), '@p': path.resolve(__dirname, './src/pages') &#125; // 别名配置 &#125; &#125;) &#125;, productionSourceMap: false, // 生产环境是否生成 sourceMap 文件 // css相关配置 css: &#123; extract: true, // 是否使用css分离插件 ExtractTextPlugin sourceMap: false, // 开启 CSS source maps? loaderOptions: &#123; css: &#123;&#125;, // 这里的选项会传递给 css-loader postcss: &#123;&#125; // 这里的选项会传递给 postcss-loader &#125;, // css预设器配置项 详见https://cli.vuejs.org/zh/config/#css-loaderoptions modules: false // 启用 CSS modules for all css / pre-processor files. &#125;, pwa: &#123;&#125;, // PWA 插件相关配置 see https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa // webpack-dev-server 相关配置 devServer: &#123; open: process.platform === 'darwin', host: '0.0.0.0', // 允许外部ip访问 port: 8022, // 端口 https: false, // 启用https overlay: &#123; warnings: true, errors: true &#125;, // 错误、警告在页面弹出 &#125;, // 第三方插件配置 pluginOptions: &#123;&#125;&#125; 关于开发环境的代理 1234567891011121314151617181920212223// vue.config.jsconst path = require('path');module.exports = &#123; // other config; devServer: &#123; proxy: &#123; // 假设请求地址：https://www.jianshu.com/shakespeare/v2/notes/3529d2d1e2f9/book。 // 当我们在本地请求：localhost:8022/testJianshu/3529d2d1e2f9/book 的时候，就会映射到 https://www.jianshu.com/shakespeare/v2/notes/3529d2d1e2f9/book '/testJianshu': &#123; target: 'https://www.jianshu.com', changeOrigin: true, // 允许跨域请求 // ws: true, // 是否代理websockets // secure: false, // 是否验证SSL Certs pathRewrite: &#123; '^/testJianshu': '/shakespeare/v2/notes/' &#125; &#125; &#125; // 代理转发配置，用于调试环境 &#125;,&#125;; 关于上面的代理测试，我们随便在一个vue文件中，使用如下请求，即可验证： 123456mounted() &#123; axios.get('/testJianshu/3529d2d1e2f9/book').then(res =&gt; &#123; console.log('-----'); console.log(res.data); // 输出&#123;\"notebook_id\":25529189,\"notebook_name\":\"【前端】工程化\",\"liked_by_user\":false&#125; &#125;)&#125;, 关于less全局变量的配置比如我们写了个less插件，想快速改变主题颜色，可以采用globalVars来实现 1234567891011121314151617181920// for： theme.jsmodule.exports = &#123; \"@button-primary-bg-color\": \"yellow\", \"@label-primary-color\": \"black\"&#125;;// vue.config.jsmodule.exports = &#123; // other config; css: &#123; extract: true, // 是否使用css分离插件 ExtractTextPlugin sourceMap: false, // 开启 CSS source maps loaderOptions: &#123; less: &#123; modifyVars: themeObj, // 这里在theme.js文件中配置全局变量，这样会把主题颜色打包在项目中。 &#125; &#125;, &#125;&#125; 生产环境去掉console.log 1234567891011121314151617181920212223242526272829303132const UglifyPlugin = require('uglifyjs-webpack-plugin')module.exports = &#123; ... configureWebpack: (config) =&gt; &#123; if (process.env.NODE_ENV === 'production') &#123; // 为生产环境修改配置... config.mode = 'production' // 将每个依赖包打包成单独的js文件 let optimization = &#123; ... minimizer: [new UglifyPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, drop_console: true, // console drop_debugger: false, pure_funcs: ['console.log'] // 移除console &#125; &#125; &#125;)] &#125; Object.assign(config, &#123; optimization &#125;) &#125; else &#123; // 为开发环境修改配置... config.mode = 'development' &#125; ... &#125;, ...&#125; postcss.config.js当我们在移动端，想完全适应屏幕，我们可以使用postcss-px-to-viewport插件，进行px到viewport的自动转换。转换后，会发现所有px都变为vw or vh。我们可以如下配置： 123456789101112131415161718192021222324module.exports = &#123; plugins: &#123; autoprefixer: &#123;&#125;, \"postcss-px-to-viewport\": &#123; viewportWidth: 750, // 视窗的宽度，对应的是我们设计稿的宽度，一般是750 viewportHeight: 1334, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置 unitPrecision: 4, // 指定`px`转换为视窗单位值的小数位数（很多时候无法整除） viewportUnit: \"vw\", // 指定需要转换成的视窗单位，建议使用vw exclude: [/node_modules/, /src\\/components/], // 排除无需编译的文件夹 selectorBlackList: [\".ignore\", \".hairlines\"], // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名 minPixelValue: 1, // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值 mediaQuery: false // 允许在媒体查询中转换`px` &#125;, // 不支持vw，vh的浏览器要加这个插件，进行兼容 \"postcss-viewport-units\": &#123; // 处理工具伪类和项目样式伪类的冲突问题 filterRule: rule =&gt; rule.selector.indexOf(\"::after\") === -1 &amp;&amp; rule.selector.indexOf(\"::before\") === -1 &amp;&amp; rule.selector.indexOf(\":after\") === -1 &amp;&amp; rule.selector.indexOf(\":before\") === -1 &#125; &#125;&#125;; 关于babel 配置。如果有一些自己写的组件，或者没有转为es5 的组件，需要babel-loader进行转换。可以在webpack中加入： 123456789101112131415161718192021222324252627282930313233transpileDependencies: [\"cccc\"], // 通过 Babel 显式转译一个依赖，可以在这个选项中列出来。 // 或者：const path = require('path');function resolve(dir) &#123; return path.join(__dirname, '.', dir);&#125;module.exports = &#123; ... // 其他配置 chainWebpack: config =&gt; &#123; config.module.rule('compile') .test(/\\.js$/) .include .add(resolve('src')) .add(resolve('node_modules/webpack-dev-server/client')) .add(resolve('node_modules/cccc')) .end() .use('babel') .loader('babel-loader') .options(&#123; presets: [ ['@babel/preset-env', &#123; modules: false &#125;] ] &#125;); &#125;&#125;;// 如上配置，会在整个loader后面加一个叫compile的loader 关于babel 配置，vue-cli3 已经进行了很多封装。 关于解释vue-cli3中的babel配置，以及相对于es678兼容性的问题，查看：链接这里写的很明白","tags":[{"name":"vuewebpack","slug":"vuewebpack","permalink":"https://akijiangrou.github.io/tags/vuewebpack/"},{"name":"vue-cli3","slug":"vue-cli3","permalink":"https://akijiangrou.github.io/tags/vue-cli3/"},{"name":"config","slug":"config","permalink":"https://akijiangrou.github.io/tags/config/"}]},{"title":"React滚动吸顶最佳实践","date":"2019-04-25T03:43:04.000Z","path":"2019/04/25/React滚动吸顶最佳实践/","text":"背景普通的模块吸顶实现思路，就是clone一个滚动的元素，当元素快要滚出视口的时候，将clone的元素fix到顶部或者某个位置。那么对于react组件，就可以使用两个同样组件，也是监听滚动事件，控制第二个组件的显示与否。例子如下 ###","tags":[{"name":"React 滚动吸顶","slug":"React-滚动吸顶","permalink":"https://akijiangrou.github.io/tags/React-滚动吸顶/"}]},{"title":"经典欧洲行","date":"2018-10-12T03:41:15.000Z","path":"2018/10/12/经典欧洲行/","text":"巴黎 酒店：铂尔曼巴黎埃菲尔酒店(铁塔旁边，很惬意，早餐非常棒) 景点： 第一天 埃菲尔铁塔 凯旋门 香榭丽舍大街 协和广场 亚历山大三十桥 巴黎歌剧院 第二天 卢浮宫 奥赛美术馆 巴黎圣母院 圣礼拜堂 化身咖啡馆 先贤寺 名人堂 地图： 图片： 因特拉肯 酒店：因特拉肯城市酒店（直接远眺少女峰，非常棒） 景点：闲逛就好 琉森（卢塞恩） 景点： 琉森湖 奢侈表一条街 垂死狮子 廊桥 佛罗伦萨 景点： 百花大教堂 领主广场 维琪奥桥 米开朗叽萝广场 (最好傍晚，太晒了) 米兰 米兰大教堂 埃马努埃莱二世长廊 比萨 比萨斜塔 威尼斯 里亚托桥 叹息桥 玻璃岛 罗马 酒店：萨伏伊酒店（很古老的感觉，与前两个稍逊色） 景点： 梵蒂冈 古罗马斗兽场 西班牙广场 少女喷泉","tags":[{"name":"旅游攻略","slug":"旅游攻略","permalink":"https://akijiangrou.github.io/tags/旅游攻略/"},{"name":"欧洲","slug":"欧洲","permalink":"https://akijiangrou.github.io/tags/欧洲/"}]},{"title":"基础知识查缺补漏-数据类型","date":"2018-01-04T07:24:57.000Z","path":"2018/01/04/查缺补漏/","text":"数组 数组delete元素后，length不变。 1234var a = [1,2,3,4];delete a[1] a; // [1, empty, 3, 4, 5]a.length; // 5 数组也可以加入键值，不过不计入长度，如果键值能够强制转化成十进制数字，则会当做数字索引来用。 12345678const b = [];b[0] = 1;b['foo'] = 2;b.length; // 1b.foo; // 2b['5'] = 5;b.length; // 6 字符串字符串和字符数组很像 ~~差别：字符串不可变，字符数组是可变的。 可以用数组方法来处理字符串 1234567891011const a = 'abcdefg';a.join; // undefined;a.map; // undefined;const b = Array.prototype.join.call(a, '-');b; // \"a-b-c-d-e-f-g\"const c = Array.prototype.map.call(a, v =&gt; v.toUpperCase() + ',').join('');c; // \"A.B.C.D.E.F.G.\" 注意join，如果没有其实就是普通的字符串数组了。 部分数组函数，字符串不能用，比如reverse。例子：实现字符串反转 需要先将字符串打散成数组，然后操作。 1const reverseStr = arr =&gt; arr.split(\"\").reverse().join(\"\"); 如果需要经常以字符数组的方式来处理字符串的话，倒不如直接使用数组，最后用join(“”)转换成字符串。 数字 指定有效数位显示位数 toPrecision(..) 都转化成相应位数的字符串 12345const a = 43.68;a.toPrecision(1) // \"4e+1\"a.toPrecision(2) // \"43\"a.toPrecision(3) // \"43.7\"a.toPrecision(5) // \"43.680\" 注意：如果用数字直接调用toFixed，toPrecision 等都要用（）抱起来，因为.会被认为是数字的一部分。 二进制八进制表示法0b11110011 //2430o363 // 243 最好用小写的 0[zero]b 或者 0o来表示。虽然大写也行，但是容易混淆 较小数值比较0.1 + 0.2 === 0.3 // 输出是false 二进制浮点数中的 0.1 和 0.2 并不是十分精确，它们相加的结果并非刚好等于 0.3，而是一个比较接近的数字 0.30000000000000004 解决方法：设置一个误差范围值，机器精度2^-52, ES6中已经规定了这个常数，Number.EPSILON; 自己写的判断： 123456 const numberClose = (s1,s2) =&gt; Math.abs(s1-s2) &lt; Number.EPSILON;// test const a = 0.1 + 0.2; const b = 0.3; numberClose(a, b); // true 整数的安全范围2^53 - 1 9007199254740991 ES6：Number.MAX_SAFE_INTEGER最小：-9007199254740991 定义为： Number. MIN_SAFE_INTEGER 检测整数： 12Number.isInteger(43) // trueNumber.isInteger(43.0) // true 检测是否是安全的整数12Number.isSafeInteger( Number.MAX_SAFE_INTEGER ); // true 特殊数值NaN 是唯一一个不等于自身的值。 1234567891011null === null // trueundefined === undefined // trueNaN === NaN // falseInfinity === Infinity// 语义上，判断一个数字是否是 NaN， 第一种，显然不对，因为他并不是 NaN。window.isNaN('abc') // true Number.isNaN('abc') // falseInfinity // 1/0Infinity/Infinity // NaN 注意：如果计算结果溢出，则为无穷数，而且无法再回到有穷数了。 0 &amp; -0有些奇怪：[1] 这两个值相等[2] 没有大小之分[3] 数字转换成string的时候，只会是’0’，但是parse回数字的时候，可以转换成 -0 1234567const a = 0;const b = -0;a === b; // truea &gt; b; // falseJSON.stringify(b) // \"0\"JSON.parse('-0') // -0 如果判断 -0 怎么弄呢？通过 1/-0 等于 -Inifinity 来实现。 1234function isNegZero(num) &#123; const n = Number(num); return n=== 0 &amp;&amp; 1/n === -Infinity; &#125; ES6 中用Object.is() 可以实现 负零判断，NaN判断 1234567const a = 1 / \"foo\";const b = -0;Object.is(a, NaN); // trueObject.is(b, -0); // trueObject.is(b, 0); // false 能用 == &amp; === 就不要用Object.is() 效率比较低，有特殊的相等比较的时候再用。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://akijiangrou.github.io/tags/javascript/"},{"name":"基础类型","slug":"基础类型","permalink":"https://akijiangrou.github.io/tags/基础类型/"}]},{"title":"CSS-grid","date":"2017-12-06T08:28:23.000Z","path":"2017/12/06/CSS-grid/","text":"例子grid布局的思想就是，先将一个container 设置上display:grid; ,然后使用grid-template-columns: &amp; grid-template-rows 将这个div划分为多个小格子。然后使用grid-column &amp; grid-row将子元素放置在一个或者多个小格子中。 代码实现。 See the Pen grid-start by akixiao (@akixiao) on CodePen. css： 12345678910111213141516.container &#123; display:grid; width:600px; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 100px 200px; grid-gap: 10px; background: gray;&#125;.grid-item &#123; background: lightblue; border: 1px solid #333;&#125;.last-item &#123; grid-column-start: 1; grid-column-end: -1;&#125; 在container中：display:grid;声明这个container是采用grid布局的。 grid-template-XXX设置了这个div的网格式布局的基本。 在item中：grid-column-xxx设置了这个div在grid中所占有的布局。 grid布局中新增了一些知识，下面就利用这个例子来分别解释gird布局中的一些基本术语。 基础知识 grid容器（grid container） 设置了display:gird|inline-grid|subgrid的元素，被称为grid container。他是所有网格项目grid item的直接父元素。 如上面的div.container grid项目（grid item) grid container的子元素被称为grid item。如上面的div.grid-item 网格线 （grid lines） 网格线是水平和垂直方向来分割空间的线。水平方向的网格线是从左向右；垂直方向是从上往下。编号都是从1开始的。grid布局就是通过grid lines进行元素的布局的。通过grid-template等属性设置网格线。如果是负值，是从右往左方向。 按照最上面的例子，grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 100px 200px;将空间分成了6个部分，水平方向3个格子，垂直方向2个格子。相应的，gridline如上，有7条。三条紫色虚线为 row grid lines 。四条蓝色垂直虚线为column grid lines。 这七条线划分出了该grid的6个子空间，之后可以根据网格线号码定位网格项目。 网格线还可在定义轨道的时候，进行命名。 详见[grid-template] 网格轨道（grid track） 两条邻近grid line之间的空间就是grid track。通过grid-template设置。 其中半透明橘黄色就是一个grid track。 grid cell 两条邻近的row grid line 和两条邻近的column grid line 之间的空间。是grid布局的基础单元。所有的布局都可以通过选择不同范围的grid cell 来实现。如下面的蓝色方块。 grid area 任意四条线间的空间，被称为grid area，由多个grid组成。如下绿色部分，如果用css表示该部分应该是。grid-row: 2/4grid-column: 1/3 或者 grid-row: -3/-1grid-column: -3/-1 gutters tracks 之间的间隔，如例子中的深灰色的部分。可以通过grid-column-gap, grid-row-gap, or grid-gap来设置。 grid container display 【display:grid|inline-grid|subgrid】第三个是指，当grid container 本身是一个grid item，也可以通过设置这个属性，进一步对该item进行网格式布局。 声明这个container是grid形式的。因此在块容器中的一些属性使用并不适用于网格容器当中: 多列布局属性column-*不能用于网格容器 float ，clear, vertical-align 都不生效 ::first-line和::first-letter伪元素不能用于网格容器 grid containe的可用css属性如下： grid-template 是grid-template-row and grid-template-column 的缩写。显示的设定网格的行和列。 grid-template-column【grid-template-column: [name] value …】每写一个value值，则定义了一个轨道宽度。 单位可以是px em % fr。 这里fr是一个新单位，代表可用空间的比例。一个例子如下： See the Pen grid-testone by akixiao (@akixiao) on CodePen. grid-gap: 10px;grid-template-columns: 50px repeat(2, 1fr) 2fr; 这里是在水平方向上分为4个部分，长度分别是 50px 1fr 1fr 2fr。 1fr是怎么计算呢，其实就是 (width - 50 - 3*10) / 4px。fr就不需要我们自己主动计算百分比了，他会自行计算。更准确。 代码https://codepen.io/akixiao/pen/jaRRQL repeat() 可以创建重复的网格轨道, 接受两个参数：第一个参数定义网格轨道应该重复的次数，第二个参数定义每个轨道的尺寸。 1grid-template-columns: 50px repeat(3, 1fr) minmax() 网格轨道最大最小尺寸。minmax()函数接受两个参数：第一个参数定义网格轨道的最小值，第二个参数定义网格轨道的最大值。可以接受任何长度值，也接受auto值。auto值允许网格轨道基于内容的尺寸拉伸或挤压。 12grid-template-rows: minmax(100px, auto) 50px;grid-template-columns: minmax(auto, 25%) 50px 1fr 1fr; 这个就是意味着，第一行的高度最小为100px，可以超过，第二行高度为50px; 第一列的宽度最大为25%，可以根据其他列适当缩小值，其余列为定义的值。 实际例子： See the Pen grid-test-minmax by akixiao (@akixiao) on CodePen. name代表什么呢？这里是指网格线名称。假如我写了如下的grid-template（这里copy了一下，偷懒了） 1234.container &#123; grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end]; grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line];&#125; 当我们在grid items中布局的时候，可以不用在写编号了，写name就可以了。例如： 1234.item &#123; grid-column: first/line3; grid-row: row1-start/third-line;&#125; 如上写法，这个item将占据 width：90px;height: 25%*height + 100 px 的空间，相当于左上角四个grid。 展示结果 grid-template-row【grid-template-row: [name] value …】先来说value，每写一个值，则定义了一个轨道高度。 单位可以是px em %。其余与column相似。 内容与grid-template-column相似，不多说了。 grid-template-areas【grid-template-areas: [name]|none|.】这个属性，就是将轨道分出来的每个grid 都赋予一个name，然后grid items 可以根据name来进行布局。不多说，上例子更明确 1234567891011121314151617181920212223242526272829.container &#123; display:grid; height: 400px; grid-template-columns: 120px auto; grid-template-rows: 60px 1fr 60px; background: gray; grid-template-areas: \"sidebar header\" \"sidebar content\" \"sidebar footer\";&#125;.sidebar &#123; grid-area: sidebar; background: purple;&#125;.header &#123; grid-area: header; background: #333;&#125;.content &#123; grid-area: content; background: lightblue;&#125;.footer &#123; grid-area: footer; background: orange;&#125; 123456&lt;div class=\"container\"&gt; &lt;div class=\"sidebar\"&gt;&lt;/div&gt; &lt;div class=\"header\"&gt;&lt;/div&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;div class=\"footer\"&gt;&lt;/div&gt;&lt;/div&gt; 结果图： 代码 关于简写的grid-template: 综合grid line，grid track，grid area。 123456grid-template-columns: 120px auto;grid-template-rows:[row-1] 60px [row-2] auto [row-3] 60px [row-4];grid-template-areas: \"sidebar header\" \"sidebar content\" \"sidebar footer\"; 等价于 1234grid-template: [row-1] \"sidebar header\" 60px [row-2] \"sidebar content\" auto [row-3] \"sidebar footer\" 60px [row-4] / 120px auto; grid-gap 这个是，grid-row-gap和grid-column-gap的缩写。创建的是轨道间的距离。如最开始的例子： grid-gap: 10px;这个等价于： grid-row-gap: 10pxgrid-column-gap: 10px 下面是grid 元素的对齐方式： justify-itemsalign-items 这两个分别是指定网格项目沿着行轴的对齐方式，和沿着列轴的对齐方式。可用的属性有： 解释都是以justify-items为例，align-items请自动转换为相对于纵轴来说。 start: 内容居左排列 end: 内容居右排列 center: 内容居中排列 stretch: 默认值，横跨整个row 轴 justify-contentsalign-contents 这两个是网格轨道的对齐方式，分别相对于justify-contents指定网格轨道沿着列轴的排列方式，其实就是row网格轨道在垂直方向上的排列情况。和align-contents网格轨道沿着row轴的排列方式，是column网格轨道在水平方向上的排列情况。可用属性： start：居左 end： 居右 center: 居中 strech： 拉伸 space-around：每个轨道两边距离相同 space-between：第一和最后的羽绒器边缘没有间距，其他轨道距离相同。 space-evenly：轨道距离容器边缘和轨道间的距离都相同。 grid-autogrid-template-columns, grid-template-rows, grid-template-areas 可以定义显示的网格，给出确定的网格轨道宽高，和明确的grid数量。也可以使用grid-auto-rows 和 grid-auto-columns创建隐式网格。 隐式网格，当项目被放置在template未规定的grid时，就会生成隐式网格。如果是按照template摆放的内容，就算定义了隐式grid，隐式grid也不会出现在展示中。 1234567891011121314151617181920212223242526272829303132.container &#123; display:grid; height: 400px; display: grid; grid-template-columns: 100px; grid-auto-columns: 200px; grid-template-rows: 100px; grid-auto-rows: 200px;&#125;.first &#123; grid-column: 1; grid-row: 1; background: lightblue;&#125;.second &#123; background: orange;&#125;.third &#123; background: pink;&#125;.forth &#123; background: tomato; grid-row: 2; grid-column:2;&#125;&lt;div class=\"container\"&gt; &lt;div class=\"first\"&gt;1&lt;/div&gt; &lt;div class=\"second\"&gt;2&lt;/div&gt; &lt;div class=\"third\"&gt;3&lt;/div&gt; &lt;div class=\"forth\"&gt;4&lt;/div&gt;&lt;/div&gt; 上面只显示定义了一个columns和rows。 如果不规定forth中的样式，则默认向1下方添加高度为200px，宽度为100px的div。如果在forth中设置了不存在的cell，则container会生成隐式grid，其他的div会根据顺序以添加了隐式grid进行排列。 当forth为 .forth { background: tomato; grid-row: 2; grid-column:2; } .forth { background: tomato; grid-row: 3; grid-column:3; } grid items上面都是grid container的属性，下面介绍grid items 可以使用的各种属性。首先既然是grid item了，一些block的属性就不在适用了，如下： 浮动和清除浮动，对于网格项目中使用不生效。 vertical-align属性对于网格项目不生效 grid-columngrid-rowgrid-area grid-area是grid-column &amp; grid-row的缩写。或者是template中的area-name缩写方式： 123grid-area: grid-row-start / grid-column-start/ grid-row-end / grid-column-end;grid-area: name; grid-column: grid-column-start / grid-column-end;grid-row: grid-row-start / grid-row-end; 以上都要输入grid line的值: 这个值可以是数字，也可以是具体名称name，也可以是name-start/name-end。 一个命名的template-area，都会隐式的生成 4 条 grid-line的名称： area-start, area-end 行 area-start, area-end 列 所以，在放置grid item 的时候，也可以不用grid-area, 用grid-column，grid-row输入隐式grid line 的名称即可。 还有一种方式，通过合并单元格的形式，对grid item进行布局。span关键词实现单元格的跨越，类似table中的合并单元格，比如colspan合并列，rowspan合并行。 1234567891011.item-2 &#123; grid-column: 2 / 4; grid-row: 1 / 2;&#125;等价于： .item-2 &#123; grid-column: 2 / span 2; grid-row: 1;&#125; justify-selfalign-self 含义及内容参考justify-items &amp; align-items。 这个是可以在项目本身修改下自己的排列方式。 实战参考：CSS Grid实现限宽容器 参考cheat sheet小游戏掌握grid","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://akijiangrou.github.io/tags/学习笔记/"},{"name":"css3","slug":"css3","permalink":"https://akijiangrou.github.io/tags/css3/"},{"name":"grid","slug":"grid","permalink":"https://akijiangrou.github.io/tags/grid/"}]},{"title":"flex布局","date":"2017-12-05T02:34:41.000Z","path":"2017/12/05/flex布局/","text":"flex是个超好用的css 布局属性。到2017-12 主要浏览器基本都支持了。如下： flex 属性可应用于，flex容器，flex项目。其中flex容器中的元素，自动成为flex项目。根据属性控制的轴的类型，简单总结下flex的各个属性，如下： 假设9个方块其html如下，基本css如下： 1234567891011&lt;div class=\"container\"&gt; &lt;div&gt;A&lt;/div&gt; &lt;div&gt;B&lt;/div&gt; &lt;div&gt;C&lt;/div&gt; &lt;div&gt;D&lt;/div&gt; &lt;div&gt;E&lt;/div&gt; &lt;div&gt;F&lt;/div&gt; &lt;div&gt;G&lt;/div&gt; &lt;div&gt;H&lt;/div&gt; &lt;div&gt;I&lt;/div&gt;&lt;/div&gt; css 1234567891011121314.container &#123; background: pink; width: 400px; height: 400px;&#125;.container div &#123; background: orange; height: 100px; width:100px; text-align:center; border: 1px solid; line-height: 100px;&#125; 未加flex布局时的原始样式。 flex container12345.container &#123; display: flex; background: pink; width: 600px;&#125; 主轴方向相关的属性 [flex-direction] 规定项目排列方式，也就是主轴方向 row：默认，沿主轴从左向右排列子元素。规定主轴为水平方向。 row-reverse：从右向左 column：规定主轴方向为垂直方向，从上到下排列子元素。 column-reverse： 从下到上排列。 [flex-direction] 规定换行情况 no-wrap： 默认，不换行。见上面第二张图 wrap：换行。 wrap-reverse： 换行，且第一行在下方。 如果规定了父元素宽度，默认不换行的话，其子元素会等比例缩小宽度（也就是子元素定义的宽不生效了）。如果换行，则按照子元素大小来显示。 [flex-flow] 以上两个的简写 主轴方向 + 换行 例子： flex-flow:row-reverse wrap-reverse; [justify-content] 项目在主轴方向上的对齐方式。 flex-start：默认，相对于主轴左对齐（要根据flex-direction规定的轴方向来说，以下相同，不赘述了） flex-end：右对齐 center：居中 space-between：两端对齐，项目之间间隔相同 space-around：每个项目的两侧间隔相同，所以项目间的距离是项目与边框的距离的二倍 例子：flex-flow:row-reverse wrap-reverse;justify-content:flex-end; 如果换成center：justify-content:center; 如果换成space-between：justify-content:space-between; 交叉轴方向相关的属性下面换个基础图， 1234567891011121314.container &#123; display: flex; background: pink; width: 400px; height: 400px;&#125;.container div &#123; background: orange; width: 100px; height: 100px; text-align:center; border: 1px solid; line-height: 100px;&#125; 如果我们设下：flex-flow:row wrap;则有： [align-items] 项目在交叉轴上的对齐方式 flex-start： 交叉轴的起点对齐 flex-end：交叉轴的终点对齐 center：交叉轴的中点对齐 baseline：项目的第一行文字的基线对齐 stretch：默认，如果项目未设置高度或设为auto，将占满整个容器的高度。 行数比较多的时候，有些效果可能看不出来。 例子：将c div改一下高度： 123456789101112&lt;div style=\"height:150px\"&gt;C&lt;/div&gt;.container &#123; displaybase: flex; background: pink; flex-flow: row wrap; justify-content: space-around; width: 400px; height: 400px; align-items: center;&#125; 如果：改成align-items: baseline; [align-content] 主轴在交叉轴上的对齐方式只有单行主轴的时候不生效。与justify-content内容相同，多了个stretch，这个是默认值。不过都是轴线相对于交叉轴的。比如：flex-start多根主轴在交叉轴的方向上，按交叉轴起点方向向下排列。 justify-content: space-around;align-content: space-around; align-content: space-between; flex item每个flex项目也可以自定义一些属性。 [order] 定义项目的排列顺序。数值越小，排列越靠前，默认为0 例子，假如我们把上面的Fdiv的order改一下：&lt;div style=&quot;order:2&quot;&gt;F&lt;/div&gt; [flex-grow] 项目的放大比例。默认为0。如果为1，就是都占据同样的空间。其他的数字，则是如果有空余空间，则按照比例分配空间。 [flex-shrink] 项目的缩小比例。如果空间不够，将项目按照比例缩小。数字越大，缩小比例越大。 例子： 12345&lt;div style=\"order:2;flex-shrink: 0\"&gt;F&lt;/div&gt;.container &#123; flex-flow: row nowrap;&#125; &lt;div style=&quot;order:2;flex-shrink: 2&quot;&gt;F&lt;/div&gt; [flex-basis] 项目占据的主轴空间。可以设为百分比。默认： 0 1 auto；快捷：auto （1 1 auto）flex属性：[&lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt;] 换新的布局： 123456789101112131415161718192021.container &#123; display: flex; background: pink; flex-flow: row wrap; align-items: center; justify-content: space-around; width: 400px; height: 400px; align-content: stretch;&#125;.container div &#123; background: orange; height: 100px; text-align:center; border: 1px solid; line-height: 100px; flex: 0 1 30%;&#125;&lt;div style=\"height:150px\"&gt;C&lt;/div&gt;其余不变 如果c设置上flex &lt;div style=&quot;height:150px;flex: 2 1 30%&quot;&gt;C&lt;/div&gt; [align-self]属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认继承父元素的align-items属性。其他属性与上面相同。&lt;div style=&quot;align-self:flex-end&quot;&gt;F&lt;/div&gt;","tags":[{"name":"css","slug":"css","permalink":"https://akijiangrou.github.io/tags/css/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://akijiangrou.github.io/tags/学习笔记/"},{"name":"flex","slug":"flex","permalink":"https://akijiangrou.github.io/tags/flex/"}]},{"title":"vue学习笔记","date":"2017-11-28T07:04:55.000Z","path":"2017/11/28/vue学习笔记/","text":"声明式渲染给vue一个div，将数据绑定在这个div范围内，然后就可以用vue操作和渲染了。 1234567891011&lt;div id=\"app\" v-bind:style='style'&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;var app = new Vue(&#123; el: '#app', data: &#123; message: 'my name is zcx', style: 'width: 200px;background: pink', &#125;,&#125;) 类似模板的方法: html 中嵌入数据，该数据存储在vue的data中。数据还可以通过，v-bind的方法，传到dom节点中。bind后面接的是dom应有的属性，等号后面接data中的数据。 常用指令以v- 开头的都是，vue整合了一些常用的便捷的写法，具体如下：【v-bind】绑定数据，还提供了简写：v-bind:href=&#39;url&#39; ===&gt; :href=&#39;url&#39;【v-if】 条件判定，绑定dom结构到数据上。【v-for】 循环【v-on】 事件监听，简写：v-on:click=&#39;...&#39; ===&gt; @click=&#39;...&#39; 实例代码： See the Pen Bwvrrb by akixiao (@akixiao) on CodePen. 【v-model】 实现表单信息与应用状态之间的双向绑定。对于input v-model绑定的是input中value。radio 对应的是value中的 ‘one’，’two’; 12345678&lt;input type=\"radio\" name=\"pick\" value=\"one\" v-model=\"pick\"/&gt;&lt;input type=\"radio\" name=\"pick\" value=\"two\" v-model=\"pick\"/&gt;&#123;&#123; pick &#125;&#125;// vue 部分data: &#123; pick: \"one\",&#125;, 【v-once】 只执行一次插值，当数据改变时，插值处的内容不会更新 v-model实例将input与v-model结合，如下： See the Pen EbeOXB by akixiao (@akixiao) on CodePen. 实例属性获取可以通过四种方式，展示&amp;监听vue实例中的属性。 12345678910111213var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125;&#125;) 模板表达式这个是最基本的获取方法。获取message的信息 1234&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"&#123;&#123; message &#125;&#125;\"&lt;/p&gt;&lt;/div&gt; 计算属性出现原因是在模板中放入太多的逻辑会让模板过重且难以维护,对于任何复杂逻辑，你都应当使用计算属性。如上面的reversedMessage。 1234&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"&#123;&#123; reversedMessage &#125;&#125;\"&lt;/p&gt;&lt;/div&gt; 如果我修改了message，则对应的reversedMessage 也会跟着改变。如果message不改变，re-render的时候，reversedMessage会立即展示之前的问题。 method其实使用method也可以达到获取reversedMessage的目的。 与上面的差别的是，每当触发重新渲染时，调用方法将总会再次执行函数。 1234567891011121314151617var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, methods: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125;&#125;)&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"&#123;&#123; reversedMessage() &#125;&#125;\"&lt;/p&gt;&lt;/div&gt; 侦听属性一种更通用的方式来观察和响应 Vue 实例上的数据变动。 当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。在watch函数中监听某些属性，该属性一变化，就会执行对应的函数，函数内可能会对其他属性进行操作。 1234567891011121314151617181920var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello', question: '', &#125;, watch: &#123; // 计算属性的 getter question: function () &#123; // `this` 指向 vm 实例 this.message = '...'; ... &#125; &#125;&#125;)&lt;div id=\"example\"&gt; &lt;input v-model=\"question\"/&gt; &lt;p&gt;Original message: \"&#123;&#123; message &#125;&#125;\"&lt;/p&gt;&lt;/div&gt; 样式class【v-bind:class】 可以与原始的class 混用 【计算属性】 返回一个classObject。 【v-bind:class=”[activeClass, errorClass]”&gt;】 数组形式，传给他一个class列表。 1&lt;div v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/div&gt; 上面的语法表示 active 这个 class 存在与否将取决于数据属性 isActive 是否为真。 1234567891011121314151617181920212223242526272829303132333435&lt;div id=\"app\"&gt;&lt;div class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt; helloworld&lt;/div&gt; &lt;div class=\"static\" v-bind:class=\"classObj\"&gt; second try&lt;/div&gt;&lt;/div&gt;.active &#123; text-decoration: underline;&#125;.static &#123; font-size: 20px;&#125;.text-danger &#123; color: orange;&#125;const app = new Vue(&#123; el: '#app', data: &#123; isActive: true, hasError: true, &#125;, computed:&#123; classObj: function() &#123; return &#123; active: !this.isActive, 'text-danger': this.isActive &amp;&amp; this.hasError, &#125; &#125; &#125;&#125;); 实例： See the Pen POdxyE by akixiao (@akixiao) on CodePen. style与class类似。","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://akijiangrou.github.io/tags/学习笔记/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://akijiangrou.github.io/tags/Vue-js/"}]},{"title":"学习笔记","date":"2017-11-23T03:08:00.000Z","path":"2017/11/23/学习笔记/","text":"","tags":[]},{"title":"post-message","date":"2017-11-17T07:10:44.000Z","path":"2017/11/17/post-message/","text":"用postmessage 进行iframe与parent的交流。需求描述：父页面包含iframe 12345&lt;html http://a.b.com&gt; &lt;iframe http://c.b.com&gt; sjdkfjaksjfakfjs &lt;/iframe&gt;&lt;/html&gt; 在http://c.b.com中有个button，点击后让父页面也就是a.b.com进行一些操作。那么怎么写呢？ 首先在a.b.com 重要监听message事件，如下： 123456789101112window.addEventListener(\"message\", handleIframe);const handleIframe = event =&gt; &#123; const &#123; data:&#123; pathStr &#125;&#125; = event;// 发送message的源 const origin = event.origin || event.originalEvent.origin; const url = window.top.location.origin;// 防止监听多个源头的message if (test(/c.b.com/, origin) &amp;&amp; pathStr) &#123; window.alert(pathStr); &#125;&#125;; 在c.b.com 中，点击button，触发click事件 1234handleClick() &#123; const msg = &#123; pathStr: '/shop/page/tagSetting?dim=poi&amp;tab=1' &#125;; window.top.postMessage(msg, ’http://a.b.com');&#125; 注意postMessage的发送方，必须是发送目的地的window对象，第一个参数是data信息，第二个参数是接收这个message的url。 也就是说，我虽然在iframe中控制parent，但是实现时，是期望收到信息的window发出的message事件，这样该window才能监听到这个message。这样就好理解了。 参考","tags":[{"name":"DOM","slug":"DOM","permalink":"https://akijiangrou.github.io/tags/DOM/"},{"name":"iframe","slug":"iframe","permalink":"https://akijiangrou.github.io/tags/iframe/"}]},{"title":"WebGL学习系列-threejs-形状","date":"2017-11-10T09:56:43.000Z","path":"2017/11/10/WebGL学习系列-threejs-形状/","text":"three.js中创建物体，比如一条线，需要如下函数：new THREE.Line( geometry, material );geometry: 几何体material: 材质这是创建物体[mesh]必须的。Geometry主要是存储物体的顶点信息，threejs中提供了一些固定的形状，省去我们一个个固定顶点的工作量。 常见几何体立方体，平面，球体，圆柱体，四面体，八面体，文字等。 立方体THREE.CubeGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) 前三个就是x，y，z方向上的长度。后三个是各自反向上的面分段，默认为1。对于立方体，默认位置是其几何中心在坐标原点。 平面THREE.PlaneGeometry(width, height, widthSegments, heightSegments)width是x方向上的长度；height是y方向上的长度；后两个参数同样表示分段 如果想让让平面在别的方向上，可以进行旋转。 球体THREE.SphereGeometry(radius, segmentsWidth, segmentsHeight, phiStart, phiLength, thetaStart, thetaLength)在图形底层中，并没有曲线，是通过多个折线近似构成曲线。所以segmentsWidth, segmentsHeight(纬度上的切片数)|width(经度上的切片数)设的越大越接近球体。 phiStart表示经度开始的弧度；phiLength表示经度跨过的弧度；thetaStart表示纬度开始的弧度；thetaLength表示纬度跨过的弧度。phi打头的就是代表水平方向。theta就是在垂直方向。 圆形THREE.CircleGeometry(radius, segments, thetaStart, thetaLength)同理，segments越大，越接近于圆。 圆台THREE.CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded)openEnded表示是否没有顶面和底面。默认为false(有顶面和底面)。 正四面体多面体的参数，都是半径 &amp; detail。半径是外接球半径，detail是细节层次，一般可以省略。 12345const tri = new THREE.TetrahedronGeometry(150); const triObj= new THREE.Mesh(tri, material(0x333333)); triObj.position.y = -300; triObj.position.x = 300; scene.add(triObj); 正八面体123456// 正八面体 const octo = new THREE.OctahedronGeometry(150); const octoObj= new THREE.Mesh(octo, material(0x33ff33)); octoObj.position.y = -300; octoObj.position.x = -300; scene.add(octoObj); 正20面体123456// 正二十面体 const icos = new THREE.IcosahedronGeometry(150); const icosObj= new THREE.Mesh(icos, material(0xff3333)); icosObj.position.y = -300; icosObj.position.x = 0; scene.add(icosObj); 甜甜圈THREE.TorusGeometry(150, 50, 10, 20)第一个甜甜圈整个半径，第二个参数:管道半径，后面分别对应两者的半径。需要把两个半径调大，甜甜圈看着就光滑了。 打结版的甜甜圈THREE.TorusKnotGeometry(radius, tube, radialSegments, tubularSegments, p, q, heightScale)p和q是控制其样式的参数，一般可以缺省， heightScale: z轴上的缩放。 边框boxHelper1234var mesh = new THREE.Mesh(geom,material);scene.add(mesh);border = new THREE.BoxHelper( mesh,0x0dc3b4 );//设置边框，这个边框不会旋转scene.add( border ); 边框不跟随物体旋转 edgesHelper边框跟随 1234var mesh = new THREE.Mesh(geom,material);scene.add(mesh);border = new THREE.edgesHelper( mesh,0x0dc3b4 );//设置边框，这个边框不会旋转scene.add( border ); 各种形状的展示：代码参考： https://github.com/MissSweety/threejs/blob/master/js/geometry.js 外部模型[3ds max]参考文献-几何形状形状实战视频教程","tags":[{"name":"webGL","slug":"webGL","permalink":"https://akijiangrou.github.io/tags/webGL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://akijiangrou.github.io/tags/学习笔记/"},{"name":"Three.js","slug":"Three-js","permalink":"https://akijiangrou.github.io/tags/Three-js/"}]},{"title":"WebGL学习系列-threejs-光源","date":"2017-11-06T07:08:09.000Z","path":"2017/11/06/WebGL学习系列-threejs-光源/","text":"图像渲染要依赖光源，如果没有光，世界就是一片黑暗，即使物体存在，你也看不出来。为了让计算机模拟光照效果，提出了几种不同的光源模型。 环境光 平行光 点光源 聚光灯 Three.js中也定义了以上几种光型，有了他们会让3d效果更逼真。 在解释光的问题外，还要先说明下Three.js 中，颜色都是16进制来表示的，白色：0xffffff。 环境光环境光是指场景整体的光照效果，是由于场景内若干光源的多次反射形成的亮度一致的效果，通常用来为整个场景指定一个基础亮度。因此，环境光没有明确的光源位置，在各处形成的亮度也是一致的。 构造函数THREE.AmbientLight(hex) 例子具体例子，创建光源添加到场景中。 12const light = new THREE.AmbientLight(0xffffff);scene.add(light); 加入两个物体： 白色正方形和绿色正方形，进行光的实验。 1234567891011121314151617181920212223 const cube = new THREE.CubeGeometry(200, 200, 200);const material = (color) =&gt; new THREE.MeshLambertMaterial(&#123;color: color &#125;)); const greenCube = new THREE.Mesh(cube, material(0x00ff00)); greenCube.position.x = 300; scene.add(greenCube); const whiteCube = new THREE.Mesh(cube, material(0xffffff)); whiteCube.position.x = -300; scene.add(whiteCube); // 照相机位置： function initCamera(width, height) &#123; const camera = new THREE.PerspectiveCamera(45, width / height, 1, 8000); // camera 位于屏幕外侧1500px的地方，这样可以直接做平面图了。 camera.position.x = 0; camera.position.y = 0; camera.position.z = 1500; camera.lookAt(0, 20, 1); return camera;&#125; 白色光源 + 白色正方形和绿色正方形效果如下： 想让光线暗一些，就把光源变灰一些。效果如下： 如果光源是红光，看下两个物体的颜色效果如下：我们可以看到，绿色的小方块没了（变成黑色的了），原因是，我们能看到物体，都是因为他反射的光，而绿色小方块的红色通道是0，反射不回来内容了，所以我们看到的就是黑色物体了，如果把光源调到带有绿色的，我们可以看到如下效果： 12const light = new THREE.AmbientLight(0xff8800); scene.add(light); 综上，当我们使用环境光的时候，最好使用白色光与灰色光，其他颜色会导致物体显色奇怪。 平行光太阳光常常被看作平行光，这是因为相对地球上物体的尺度而言，太阳离我们的距离足够远。对于任意平行的平面，平行光照射的亮度都是相同的，而与平面所在位置无关。 构造函数THREE.DirectionalLight(hex, intensity) intensity: 亮度，缺省值为1，表示100%亮度。对于平行光而言，设置光源位置尤为重要 例子也是两个小正方形，白色和绿色。与上面的不同，我们调整了照相机的位置： 12345678910function initCamera(width, height) &#123; const camera = new THREE.PerspectiveCamera(45, width / height, 1, 8000); // camera 位于屏幕外侧1500px的地方，这样可以直接做平面图了。 camera.position.x = 500; camera.position.y = 500; camera.position.z = 1500; camera.lookAt(100, 0, 1); return camera;&#125; 光源： 123light = new THREE.DirectionalLight(0xffffff, 1);light.position.set(0, 0, 200);scene.add(light); 说明，光是从z方向处200px的位置向着所有物体照射。 我们可以得到如下图像。 我们调整下光的照射方向： 1light.position.set(800, 0, 400); 说明，光是在x方向800，y方向为0，z方向处400px，与原点连线形成的向量，这个方向形成的光线。 我们可以得到如下图像。 对比下，我们加上y方向的光， light.position.set(800, 200, 400); 点光源点光源是不计光源大小，可以看作一个点发出的光源。点光源照到不同物体表面的亮度是线性递减的，因此，离点光源距离越远的物体会显得越暗。这里光在每个面上的亮度是不同的，对于每个三角面片，将根据三个顶点的亮度进行插值。 构造函数THREE.PointLight(hex, intensity, distance) distance：光源最远照射的距离，缺省值是0。 例子12light = new THREE.PointLight(0xffffff, 2, 1000);light.position.set(0, 200, 300); 一个点光源，在坐标(0, 200, 300)位置，进行照射，最远距离1000，结果如下： 当最远距离缩小为500，结果： 聚光灯聚光灯是一种特殊的点光源，它能够朝着一个方向投射光线。聚光灯投射出的是类似圆锥形的光线，这与我们现实中看到的聚光灯是一致的。 构造函数THREE.SpotLight(hex, intensity, distance, angle, exponent) angle：angle是聚光灯的张角，缺省值是Math.PI / 3，最大值是Math.PI / 2exponent：exponent是光强在偏离target的衰减指数（target需要在之后定义，缺省值为(0, 0, 0)），缺省值是10。 使用聚光灯，一般还要设置target。 如果想让一个物体的运动有灯光跟随，可以将target设置为改对象。 例子12light = new THREE.SpotLight(0xffff00, 2, 1000, Math.PI /4 , 25);light.position.set(300, 500, 0); 参考","tags":[{"name":"webGL","slug":"webGL","permalink":"https://akijiangrou.github.io/tags/webGL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://akijiangrou.github.io/tags/学习笔记/"},{"name":"Three.js","slug":"Three-js","permalink":"https://akijiangrou.github.io/tags/Three-js/"}]},{"title":"WebGL学习系列-threejs-camera","date":"2017-11-03T08:41:39.000Z","path":"2017/11/03/WebGL学习系列-threejs-camera/","text":"是什么？照相机定义了三维空间到二维屏幕的投影方式。因为投影的不同，照相机又分为正交投影相机和透视投影相机。 正交投影相机而使用正交投影照相机获得的结果就像我们在数学几何学课上老师教我们画的效果，对于在三维空间内平行的线，投影到二维空间中也一定是平行的。其特点是，远近高低比例都相同。如下： 具体方法OrthographicCamera( left, right, top, bottom, near, far )这六个参数分别代表正交投影照相机拍摄到的空间的六个面的位置，这六个面围成一个长方体，我们称其为视景体（Frustum）。只有在视景体内部的物体才可能显示在屏幕上，而视景体外的物体会在显示之前被裁减掉。需要保证(right - left)与(top - bottom)的比例与Canvas宽度与高度的比例一致 12345var camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );scene.add( camera );// 这个例子将浏览器窗口的宽度和高度作为了视景体的高度和宽度，相机正好在窗口的中心点上。这也是一般的设置方法，基本上为了方便不会设置其他的值。 left 透视投影相机而使用透视投影照相机获得的结果是类似人眼在真实世界中看到的有“近大远小”的效果。透视投影是更符合我们视觉的投影。如下： 具体方法PerspectiveCamera( fov, aspect, near, far )fov: 眼睛睁开的角度,即,视角的大小,如果设置为0,相当你闭上眼睛了,所以什么也看不到,如果为180,那么可以认为你的视界很广阔。视角越大，中间的物体越小，这是因为，视角越大，看到的场景越大，那么中间的物体相对于整个场景来说，就越小了。角度制而非弧度制。0-180aspect: 纵横比，一般为canvas的width/height, 照相机水平方向和竖直方向长度的比值，通常设为Canvas的横纵比例。near: 照相机到视景体最近的距离。far: 照相机到视景体最远的距离。相应的图像如下： 不同fov的对比，请参考：《三维空间的观察》","tags":[{"name":"three.js","slug":"three-js","permalink":"https://akijiangrou.github.io/tags/three-js/"},{"name":"webGL","slug":"webGL","permalink":"https://akijiangrou.github.io/tags/webGL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://akijiangrou.github.io/tags/学习笔记/"},{"name":"camera","slug":"camera","permalink":"https://akijiangrou.github.io/tags/camera/"}]},{"title":"WebGL学习系列-three.js入门","date":"2017-11-03T04:21:26.000Z","path":"2017/11/03/WebGL学习系列-three-js入门/","text":"被webGL吓得赶紧投入到three.js的怀抱，发现一个最简单的会旋转的正方型，只需10+就搞定了！好的，那我们还是先学习three.js吧~~ 我的目的是先学会怎么制造3d的内容，至于渲染优化什么的目前我还不需要，所以先放弃读webGL的api。先看three.js的基础知识。 三大组件在Three.js中，要渲染物体到网页中，我们需要3个组建：场景（scene）、相机（camera）和渲染器（renderer）。有了这三样东西，才能将物体渲染到网页中去。 场景（scene）用THREE.Scene来表示。场景是所有物体的容器。每一个three.js 构造的3d内容，都需要在一个scene中。 1const scene = new THREE.Scene(); 相机（camera）用THREE.PerspectiveCamera(param) 生成。相机决定了场景中哪个角度的景色会显示出来。相机就像人的眼睛一样，人站在不同位置，抬头或者低头都能够看到不同的景色。场景只有一种，但是相机却又很多种。要根据不同的场景选择不同的相机。 之后会介绍不同的相机。 1var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000); 渲染器（renderer）用THREE.WebGLRenderer()生成。渲染器决定了渲染的结果应该画在页面的什么元素上面，并且以怎样的方式来绘制。renderer有一些自己的方法和属性，如setSize(), domElement，可以用于场景的展示。渲染应该使用渲染器，结合相机和场景来得到结果画面。实现这个功能的函数是: render( scene, camera, renderTarget, forceClear ) 各个参数的意义是：scene：前面定义的场景camera：前面定义的相机renderTarget：渲染的目标，默认是渲染到前面定义的render变量中forceClear：每次绘制之前都将画布的内容给清除，即使自动清除标志autoClear为false，也会清除。 123var renderer = new THREE.WebGLRenderer();renderer.setSize(window.innerWidth, window.innerHeight);document.body.appendChild(renderer.domElement); light光源 &amp; object物体场景什么的都准备好了，上主角吧 ~~ 一个标准three.js 模板 这里我们把物体添加到场景中去。比如我们想添加一个矩形进去，12345678var geometry = new THREE.CubeGeometry(1,1,1); //CubeGeometry(width, height, depth, segmentsWidth, segmentsHeight, segmentsDepth, materials, sides)// 材质var material = new THREE.MeshBasicMaterial(&#123;color: 0x00ff00&#125;);var cube = new THREE.Mesh(geometry, material); scene.add(cube); 场景，相机，渲染器之间的关系场景是物体的容器，照相机就是选择场景的一部分，渲染器负责把照相机照下来的场景内容展示到屏幕上。 计算机的3D世界计算机的3D世界，是由点组成的，两个点组成线，不在一条线上的点组成面，无书面就能构成各种形状的物体，成为网状的模型，叫做mesh模型，在给这个模型贴上皮肤（纹理），那么物体就和现实差不多了。。。 three.js 的实现过程 创建一个场景var scene = new THREE.Scene(); 添加一个渲染器123456var render = new THREE.WebGLRenderer(&#123; canvas: document.getElementById('myCanvas'), antialias: true&#125;); // 抗锯齿属性 render.setClearColor(0xffffff); // 背景色为白色render.setSize(canvas.style.width, canvas.style.height); 创建一个照相机1234var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000); //设置相机朝向位置为(20,0,20) camera.lookAt(new THREE.Vector3(20, 0, 20)); 创建光 1234var light = new THREE.AmbientLight(0xffffff); //使用 Scene()的add方法将light添加到Scene中 scene.add(light); 创建一个物体 12345678910111213 //物体三维图形var geometry = new THREE.CubeGeometry(4, 4, 4); //物体材质 var material = new THREE.MeshBasicMaterial(&#123; color: 0x4d6dad &#125;); //生成三维物体var mesh = new THREE.Mesh(geometry, material); mesh.position.set(10, 0, 10);//使用 Scene()的add方法将mesh添加到Scene中scene.add(mesh); 创建一个物体 123// 渲染场景 render.render(scene, camera); 右手坐标系threejs使用右手坐标系，x轴正方向向右，y轴正方向向上，z轴由屏幕从里向外。如下： 坐标系的点联系原来学的几何，空间几何中，点可以用一个向量表示。那么在three.js中，可以用如下代码表示一个点： 假设一个点：(3,4,5) 1234const point = new THREE.Vector(3,4,5);const pointer = new THREE.Vector();pointer.set(3,4,5); 两点生成线以两个点生成一条渐变的彩色线为例: 完整实例参考line-three.html 1234567891011121314151617function initObject() &#123; // 声明一个几何体geometry， 几何体里面有一个vertices变量，可以用来存放点。 var geometry = new THREE.Geometry(); // 定义线条材质，`LineBasicMaterial` 是有多个参数的，这个之后了解吧。这里就是定义线条材质是否使用顶点颜色，这是一个boolean值。意思是，线条各部分的颜色会根据顶点的颜色来进行插值 var material = new THREE.LineBasicMaterial( &#123; vertexColors: true &#125; ); // 颜色，用于两个端点颜色。 var color1 = new THREE.Color( 0x444444 ), color2 = new THREE.Color( 0xFF0000 ); var p1 = new THREE.Vector3( -100, 0, 100 ); var p2 = new THREE.Vector3( 100, 0, -100 ); geometry.vertices.push(p1); geometry.vertices.push(p2); // 为上面两个顶点，设置两个颜色。 geometry.colors.push( color1, color2 ); // 第一个参数是几何体geometry，里面包含了2个顶点和顶点的颜色。第二个参数是线条的材质，或者是线条的属性，表示线条以哪种方式取色。第三个参数是一组点的连接方式 var line = new THREE.Line( geometry, material, THREE.LineSegments ); scene.add(line);&#125; 线的更多理解threejs中，线是由点，材质，颜色组成的。THREE.Vector是点，但是threejs中没有提供单独画点的函数，所以要用THREE.Geometry来画，该结构有vertices属性，用来存放顶点。材质的话，可以选择专为线准备的材质，THREE.LineBasicMaterial。最后通过THREE.Line绘制了一条线。new THREE.Line( geometry, material, THREE.LineSegments ) 如果想绘制一个网格线。那么思路就是，先定义一个长度为1000的x方向上的线，然后。将线均分为20份，每一条分别加一个y方向的位移。另一方面，垂直的线我们需要沿z方向旋转x轴上的线，然后在x方向上平移。 完整实例参考 grid-three.html 123456789101112131415161718192021function initObject(scene) &#123; var geometry = new THREE.Geometry(); var p1 = new THREE.Vector3( -500, 0, 0); var p2 = new THREE.Vector3( 500, 0, 0); geometry.vertices.push(p1); geometry.vertices.push(p2); var material = new THREE.LineBasicMaterial(&#123; color: 0x800080, opacity: 0.6&#125;); for ( let i = 0; i &lt;= 20; i ++ ) &#123; var line = new THREE.Line( geometry, material ); line.position.y = ( i * 50 ) - 500; scene.add( line ); var line = new THREE.Line( geometry, material); line.position.x = ( i * 50 ) - 500; // 将x轴方向的线，沿着z轴旋转90度，就变成了垂直的线~~ line.rotation.z = 90 * Math.PI / 180; scene.add( line ); &#125;&#125; 所有代码示例，可以参考这里code;英文参考：webgl with three.js实战参考： dragon/three.js实例参考：参考1实例参考：参考2","tags":[{"name":"three.js","slug":"three-js","permalink":"https://akijiangrou.github.io/tags/three-js/"},{"name":"webGL","slug":"webGL","permalink":"https://akijiangrou.github.io/tags/webGL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://akijiangrou.github.io/tags/学习笔记/"}]},{"title":"WebGL学习系列-基础篇","date":"2017-11-01T03:38:12.000Z","path":"2017/11/01/WebGL学习系列-基础篇/","text":"一直对图形之类的很喜欢，之后每天学习一点WEBGL相关的内容，明年也做出来一些3D动画网站就可以啦~~ [参考网站]OpenGL 编程指南MOZILA webGLWebGL中文教程three.js中文教程webgl with three.js WebGL (Web图形库)是一种JavaScript API，用于在任何兼容的Web浏览器中呈现交互式3D和2D图形，而无需使用插件。WebGL通过引入一个与OpenGL ES 2.0紧密相符合的API，可以在HTML5 &lt;canvas&gt;元素中使用。 和canvas的关系WebGL需要通过canvas来进行渲染，通过在getContext方法中传入，webgl相关字段，获取html中的画布。’webgl’ 或者 ‘experimental-webgl’ 都可以。 12var canvas = document.getElementById('my_canvas');var gl = canvas.getContext('experimental-webgl'); WebGL相关知识基础WebGL坐标系在WebGL的坐标被限制为(1,1,1)和(-1，-1，- 1)。坐标系如下： 坐标用显示器上单位度量出的数值起初叫做物理设备坐标或者叫设备坐标。对于光栅设备，我们使用的术语是窗口坐标或者屏幕坐标。屏幕坐标总是用某种整数类型来表示，因为帧缓存中任何像素中心都必须位于固定的网格点上。 WebGL颜色系统webgl采用rgba的四色系统来定义颜色。与我们平时所用的颜色系统不一样的是，RGBA四个分量使用0.0~0.1之间的数值来表示。前三个分量表示三原色的饱和度，最后一个表示不透明度。 清屏clearColor一般canvas都会使用一个颜色填充来清理画布。 WebGL也需要清屏，一般初始化步骤如下 12345678910// 设置清除颜色(蓝色，不透明)gl.clearColor(0.0, 1.0, 1.0, 1.0);// 深度清理gl.clearDepth(1.0);// 开启“深度测试”, Z-缓存gl.enable(gl.DEPTH_TEST);// 设置深度测试，近的物体遮挡远的物体gl.depthFunc(gl.LEQUAL);// 清理画布gl.clear(gl.COLOR_BUFFER_BIT); 基本图元在webgl中，所有的几何图元都是由点、线段和三角形这样的基本图元组成。webgl 提供了多种点和线段图元，相应的type参数如下 点（gl.POINTS）:每个顶点被显示的大小至少是一个像素。 线段（gl.LINES）:这种图元把相继的顶点配对后解释为线段的两个端点（两两配对）。 折线（gl.LINE_STRIP,gl.LINE_LOOP）想要让相继的顶点相连，可以使用折线图元。曲线可以通过合适的折线来近似。如果希望折线闭合，可以吧最后一个顶点设置与第一个顶点重合，也可以使用gl.LINE_LOOP类型，它会在最后一个顶点和第一个顶点之间画一条线，得到一个环路。 三角形（gl.TRIANGLE）:相继的三个顶点组合在一起 三角形条带和三角形扇（gl.TRIANGLE_STRIP,gl.TRIANGEL_FAN）: 前者就是每三个点连接成一个三角形。后面是每两个分别与0号点形成三角形。 多边形 (GL_POLYGON, GL_QUADS, GL_QUAD_STRIP) 着色器一旦创建WEBGL上下文成功，你就可以在这个上下文里渲染画图了。着色器使用ES SL(嵌入式系统着色语言）在GPU上运行，语言类似C语言。在js中，我们可以写成字符串交由底层处理。同样使用script标签保存这些代码字符也是可行的。着色器来渲染我们的简单场景并画出我们的物体。个人理解是，js存一些信息，将内容交给硬件去绘制和呈现。 分为顶点着色器，片元着色器。 片段着色器： 在 WebGL 多边形中的每一个像素都叫一个片段。这个片段着色器的工作就是建立每个像素的色彩。在这个案例中，我们会简单地给每个像素填上白色。gl_FragColor 是一个 GL 内置的特殊变量，用于片段的色彩填充。如下所示，设定它的值就是设定每个像素的颜色。 12345&lt;script id=\"shader-fs\" type=\"x-shader/x-fragment\"&gt; void main(void) &#123; gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0); &#125;&lt;/script&gt; 顶点着色器： 顶点着色器定义了每个顶点的位置和形状。 12345678910 &lt;script id=\"shader-vs\" type=\"x-shader/x-vertex\"&gt; attribute vec3 aVertexPosition; uniform mat4 uMVMatrix; uniform mat4 uPMatrix; void main(void) &#123; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); &#125;&lt;/script&gt; 简单实例mdn 官网上的例子， 戳这里写了150+行，还是缺少一些方法，很繁琐，而且基本都是重复性的内容，难道没有更容易写的3d代码？ duangduangduang~ three.js看了webgl的接口什么的，用它实现一个简单图形，太复杂繁琐了。赶紧使用three.js 吧。","tags":[{"name":"webGL","slug":"webGL","permalink":"https://akijiangrou.github.io/tags/webGL/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://akijiangrou.github.io/tags/学习笔记/"}]},{"title":"redux源码相关","date":"2017-10-26T13:19:25.000Z","path":"2017/10/26/redux源码相关/","text":"redux源码阅读redux源码很少，重点在思想。 createStore function createStore(reducer, preloadedState, enhancer) reducer是唯一必传的参数，它很重要，因为它决定了整个state。preloadedState就是state的初始值。第三个参数不是特别常用，它是个函数，如果它存在的情况下，会执行下面的语句： enhancer(createStore)(reducer, preloadedState) enhancer 增强createStore。 createStore内部维护： 12var currentReducer = reducervar currentState = preloadedState function subscribe(listener)在createStore内部维护了两个数组currentListeners、nextListeners。nextListeners的存在是为了避免在listeners执行过程中，listeners发生改变，导致错误。listeners的添加或删除都是对nextListeners进行操作的。nextListeners 初始等于 currentListeners = []; 每次subscribe 都会判定下nextListeners === currentListeners是否相等。 每次执行substribe 都会返回function unsubscribe()，取消监听。 function dispatch(action)currentState = currentReducer(currentState, action) 有dispatch，就一定执行currentReducer。以及 123456var listeners = currentListeners = nextListenersfor (var i = 0; i &lt; listeners.length; i++) &#123; listeners[i]()&#125;return action 调用subscribe传进来的listeners，按顺序执行它们，没有任何条件判断，也就是说只要执行dispatch，所有的listeners都会执行，不管state有没有发生改变，而且listeners执行的时候是没参数的。 而且，在创建store的时候，会 function getState()return currentState 每次都返回currentState dispatch({ type: ActionTypes.INIT }) function replaceReducer(nextReducer)currentReducer = nextReducerdispatch({ type: ActionTypes.INIT }) 直接拿nextReducer替换掉前面说很重要的currentReducer，后面再执行dispatch，action就会被nextReducer处理，处理的结果赋值给currentState。替换之后会执行一遍初始化action。 重点是：currentState，currentReducer，nextListeners； bindActionCreatorfunction bindActionCreators(actionCreators, dispatch) 如果actionCreators是函数，直接返回(...args) =&gt; dispatch(actionCreator(...args))； 如果是对象，则对每一个key，进行上面的转化，最后返回一个函数集合的对象。 combineReducersfunction combineReducers(reducers) 它接收的参数reducers是个对象，对象的value不能是undefined，必须是function。符合这个标准的reducer会被放入finalReducers中。然后再对finalReducers进行校验，reducer必须有default处理，不能处理Redux内部的action type，比如@@redux/INIT。然后返回一个函数combination(state = {}, action)，它也是一个reducer，可以被再次和其他reducer combine。一般combination等同于currentReducer，它的返回结果会赋给state，combination的关键代码如下： 123456789101112131415var hasChanged = false var nextState = &#123;&#125; for (var i = 0; i &lt; finalReducerKeys.length; i++) &#123; var key = finalReducerKeys[i] var reducer = finalReducers[key] var previousStateForKey = state[key] var nextStateForKey = reducer(previousStateForKey, action) if (typeof nextStateForKey === 'undefined') &#123; var errorMessage = getUndefinedStateErrorMessage(key, action) throw new Error(errorMessage) &#125; nextState[key] = nextStateForKey hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; return hasChanged ? nextState : state reducer从state中拿到对应的state，然后把返回的数据组装到state的对应位置(nextState[key] = nextStateForKey) applyMiddleware12345678910111213141516171819export default function applyMiddleware(...middlewares) &#123; return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; var store = createStore(reducer, preloadedState, enhancer) var dispatch = store.dispatch var chain = [] var middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch) return &#123; ...store, dispatch &#125; &#125;&#125; applyMiddleWARE, 返回的其实是createStore，来增强dispatch。常用的thunkMiddleware，强化dispatch，可以传递函数，不一定是object。 一般使用的时候，是如下调用的，以thunkmiddleware为例： thunkMiddleware 如下： 12345678910// 返回以 dispatch 和 getState 作为参数的actionexport default function thunkMiddleware(&#123; dispatch, getState &#125;) &#123; return next =&gt; action =&gt; &#123; if (typeof action === 'function') &#123; return action(dispatch, getState); &#125; return next(action); &#125;;&#125; 12345678910// usageimport &#123;createStore, applyMiddleware&#125; from 'redux';import thunkMiddleware from 'redux-thunk';const store = createStore( reducers, state, applyMiddleware(thunkMiddleware)); 相当于有了enhancer，上面store 会按如下执行： 1234567// createStore.jsif (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, initialState)&#125; ||\\/ applyMiddleware(thunkMiddleware)(createStore)(reducer, initialState) ||\\/ applyMiddleware(thunkMiddleware) 返回(createStore) =&gt; (reducer, initialState, enhancer) =&gt; {}的函数。 继续，把createStore这个函数，传给上面的函数，然后继续执行。 在中间件代码中的，map部分，开始执行thunkMiddleware，其实就是对dispatch的封装，因为倒数第二步是：chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));dispatch = compose(…chain)(store.dispatch); chain = [(next) =&gt; (action) =&gt; {…}]; dispatch = compose((next) =&gt; (action) =&gt; {…})(store.dispatch); dispatch = store.dispatch(action) =&gt; {…}; 最终{} 内部就是监测type是function的action 因此，如果dispatch的action返回的是一个function，则证明是中间件，则将(dispatch, getState)作为参数代入其中，进行action 内部下一步的操作。否则的话，认为只是一个普通的action，将通过next(也就是dispatch)进一步分发。","tags":[{"name":"js","slug":"js","permalink":"https://akijiangrou.github.io/tags/js/"},{"name":"redux","slug":"redux","permalink":"https://akijiangrou.github.io/tags/redux/"},{"name":"源码","slug":"源码","permalink":"https://akijiangrou.github.io/tags/源码/"}]},{"title":"child_process","date":"2017-10-25T11:45:20.000Z","path":"2017/10/25/child-process/","text":"子进程child_process，使node可以在进程中执行操作，应用系统命令等。nodejs创建子进程有四种方法,分别是 spawnforkexecexecFile。 后两个函数有回调函数。前两个没有。其中spawn 是最基本的函数，剩下三个其实都是不同程度的封装。 功能child_process 会在父进程和衍生的子进程中建立stdin、stdout和stderr的管道。数据能以非阻塞的方式在管道中流通。 四个api官网里对这四个指令的解释：spawn: 异步衍生一个子进程，不阻塞node.js 事件循环。 fork: 衍生一个新的 Node.js 进程，并通过建立一个 IPC 通讯通道来调用一个指定的模块，该通道允许父进程与子进程之间相互发送信息。 exec:衍生一个 shell 并在 shell 上运行命令，当完成时会传入 stdout 和 stderr 到回调函数。 execFile: 直接衍生命令，且无需先衍生一个 shell。 简单说说exec与spawn的区别： exec可以方便的使用复杂的shell命令，而spawn需要拆分shell指令，写在数组参数里。 exec是将进程输出结果放在buffer中，结果完全返回后，在一次性的将其以回调函数的形式返回给node，这个可能会因为返回过大，超过buffersize而报错。 相反的，spawn从子进程开始执行后，就开始不断将数据从子进程返回给主进程，它通过流的方式发数据传给主进程，从而实现了多进程之间的数据交换。 总结：如果只是想看运行结果，用exec；需要执行结果的数据，最好用spawn。 spawnchild_process.spawn(command, [args], [options]) command : 主命令args : 其他参数，以及副命令options: 见文档中的定义 // hellow.js 123456789101112131415 const &#123; spawn &#125; = require('child_process'); // 主命令ls为第一个参数，辅助命令以及路径等参数，都放在参数数组里。const ls = spawn('ls', ['-lh', '/usr']);ls.stdout.on('data', (data) =&gt; &#123; console.log(`stdout: $&#123;data&#125;`);&#125;);ls.stderr.on('data', (data) =&gt; &#123; console.log(`stderr: $&#123;data&#125;`);&#125;);ls.on('close', (code) =&gt; &#123; console.log(`child process exited with code $&#123;code&#125;`);&#125;); 运行：node hellow.js 等价于运行：ls -lh /usr 输出如下： 12345678910stdout: total 0drwxr-xr-x 1066 root wheel 35K 10 8 19:37 bin drwxr-xr-x 283 root wheel 9.4K 10 8 19:37 lib drwxr-xr-x 212 root wheel 7.0K 10 8 20:27 libexec drwxr-xr-x 23 root wheel 782B 3 25 2017 local drwxr-xr-x 246 root wheel 8.2K 10 8 19:36 sbin drwxr-xr-x 46 root wheel 1.5K 3 25 2017 share drwxr-xr-x 5 root wheel 170B 12 13 2016 standalone child process exited with code 0 example2 模拟ps ax | grep ssh 123456789101112131415161718192021222324252627282930313233const &#123; spawn &#125; = require('child_process');const ps = spawn('ps', ['ax']);const grep = spawn('grep', ['ssh']);ps.stdout.on('data', (data) =&gt; &#123; grep.stdin.write(data);&#125;);ps.stderr.on('data', (data) =&gt; &#123; console.log(`ps stderr: $&#123;data&#125;`);&#125;);ps.on('close', (code) =&gt; &#123; if (code !== 0) &#123; console.log(`wrong ps process exited with code $&#123;code&#125;`); &#125; grep.stdin.end();&#125;);grep.stdout.on('data', (data) =&gt; &#123; console.log(data.toString());&#125;);grep.stderr.on('data', (data) =&gt; &#123; console.log(`grep stderr: $&#123;data&#125;`);&#125;);grep.on('close', (code) =&gt; &#123; if (code !== 0) &#123; console.log(`wrong grep process exited with code $&#123;code&#125;`); &#125; console.log(`ps process exited with code $&#123;code&#125;`);&#125;); 输出 11915 ?? S 0:00.03 /usr/bin/ssh-agent -l 执行 ps ax | grep ssh 121915 ?? S 0:00.03 /usr/bin/ssh-agent -l57189 s009 S+ 0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude- shell这个会有两条，是因为后面这个是上面寻找的这条shell的进程 execchild_process.exec(command[, options][, callback])回调函数参数如下： error stdout stderr stdout &amp; stderr 就是shell执行后返回的内容，格式默认为utf-8编码的string，可以在options中设置编码方式{encoding: &#39;utf-8&#39;} 。注意maxBuffer: 200 * 1024, 所以如果返回的结果过大，请不要使用exec，会使语句执行错误。 在node v8版本中，可以使用util中的promisify对exec函数进行封装，如果出现error，则直接reject；其他两个作为promise的两个属性，如下代码： 123456789const util = require('util');const exec = util.promisify(require('child_process').exec);async function lsExample() &#123; const &#123; stdout, stderr &#125; = await exec('ls'); console.log('stdout:', stdout); console.log('stderr:', stderr);&#125;lsExample(); exec中写复杂的shell语句比较方便。与上面的 spawn进行ps方法的比较： 1234567exec('ps ax | grep ssh', (error, stdout, stderr) =&gt; &#123; if (error) &#123; console.error('exec error'); &#125; console.log(`stdout: $&#123;stdout&#125;`); console.log(`stderr: $&#123;stderr&#125;`);&#125;); 但是输出结果会多一条：应该是exec又新开了一个shell导致的。 123stdout: 1915 ?? S 0:00.03 /usr/bin/ssh-agent -l69597 s008 S+ 0:00.00 /bin/sh -c ps ax | grep ssh69599 s008 S+ 0:00.00 grep ssh execFilechild_process.execFile(file[, args][, options][, callback]) options，callback与exec一样，但是输入参数，比较费劲。和spawn一样麻烦了。回调函数都是当子进程停止的时候执行。 execFile是对spawn的封装，多了回调函数。而exec又是对execFile的封装，可以更便利的输入shell指令。 exec执行的时候，可能会遇到问题，这个时候多是maxBuffer 导致的，所以可以设大这个值。 forkchild_process.fork(modulePath[, args][, options]) 返回的 ChildProcess 会有一个额外的内置的通信通道，它允许消息在父进程和子进程之间来回传递。可以达到启动多个node进行处理的目的。 fork中的options有一些不一样的地方：silent： 默认是false，即子进程的stdio从父进程继承。如果是true，则直接pipe向子进程的child.stdin、child.stdout等。 stdio： 如果声明了stdio，则会覆盖silent选项的设置。默认继承父进程的stdio，其实就是父进程所在终端。 其中 stdio可以设置为文件，例如： 1234567891011121314151617181920212223// parent.jsconst child_process = require('child_process');const fs = require('fs');const out = fs.openSync('./out.log', 'a'); // out.log 中可以显示child.js 的输出。const err = fs.openSync('./err.log', 'a');const child = child_process.spawn('node', ['child.js'], &#123; detached: true, stdio: ['ignore', out, err]&#125;);// child.jsvar times = 0;const timer = setInterval(function()&#123; console.log(++times * 4); if (times &gt;1000) &#123;clearInterval(timer) &#125;&#125;, 1000); 如果子进程还在进行，父进程也会一直hold着，这个时候，可以调用子进程的unref()，释放出父进程（parent.js 最后加上 child.unref();注意stdio中参数第一个要设置为ignore, 如上child.js）。但是子进程仍在执行。验证可以在终端执行：ps aux | grep node, 发现会有子进程在进行：1zzz 70478 0.3 0.1 3094324 24244 ?? Ss 5:28下午 0:00.08 node child.js 方法：send：关于父子进程沟通，父进程中，可以调用子进程的send()方法，向子进程发送数据，对应的子进程程序中，调用process.send()方法向父进程发送数据。 code： 1234567891011121314151617181920212223242526// parent.jsconst cp = require('child_process');const n = cp.fork(`$&#123;__dirname&#125;/child.js`);console.log('1');n.on('message', (m) =&gt; &#123; console.log('PARENT got message:', m);&#125;);console.log('2');n.send(&#123; hello: 'world' &#125;);console.log('3');// child.jsconsole.log('4');process.on('message', (m) =&gt; &#123; console.log('CHILD got message:', m);&#125;);process.send(&#123; foo: 'bar' &#125;);console.log('5'); child先发送，parent收到结果，然后parent发送，child收到结果。结果如下： 12345678910111213141516node p.js 12345PARENT got message: &#123; foo: 'bar' &#125;CHILD got message: &#123; hello: 'world' &#125;``` `disconnect`：在父进程中调用 subprocess.disconnect() 或在子进程中调用 process.disconnect() 后会触发 'disconnect' 事件。 断开后就不能再发送或接收信息，且 subprocess.connected 属性会被设为 false。 code： // parent.jsconst cp = require(‘child_process’);const n = cp.fork(${__dirname}/child.js); console.log(‘1’); n.on(‘message’, (m) =&gt; { console.log(‘in Parent child is connect’, n.connected); console.log(‘PARENT got message:’, m);}); console.log(‘2’); n.send({ hello: ‘world’ });n.on(‘disconnect’, () =&gt; { console.log(‘in parent, child send disconnect signal’, n.connected);})console.log(‘3’); // child.js console.log(‘4’);process.on(‘message’, (m) =&gt; { console.log(‘CHILD got message:’, m); // console.log(‘in child, child send disconnect’); // process.disconnect(); }); process.send({ foo: ‘bar’ });console.log(‘5’); process.disconnect(); 1输出的是： 12345in Parent child is connect truePARENT got message: { foo: ‘bar’ }in parent, child send disconnect signal false 1234567891011121314151617181920如果把注释打开，最后的disconnect去掉，则会在parent接收到message后，先输出child这边的 `in child, child send disconnect`,在输出`in parent, child send disconnect signal false` ...注意如果child是一个会执行很久的函数，此时他依然是可以在执行的，只是父进程监控不到他了~~~，要注意！如果不想让子进程也执行了，调用kill既可。`kill`#### 事件：- message`on('message', func)` 分别用on方法来监听，对方发送的数据。- close- exit- disconnect close 和exit 当子进程退出的时候都会监控到，两者的结果基本相似。close，是当stdio流关闭时触发。 一般子进程退出了，stdio一定退出了。 对于exit，如果子进程是自己退出的，那么code就是退出码，否则为null；如果子进程是通过信号结束的，那么，signal就是结束进程的信号，否则为null。这两者中，一者肯定不为null。例子： // parent.js const cp = require(‘child_process’);const n = cp.fork(${__dirname}/child.js); console.log(‘1’); n.on(‘message’, (m) =&gt; { console.log(‘in Parent child is connect’, n.connected); console.log(‘PARENT got message:’, m);}); console.log(‘2’); n.send({ hello: ‘world’ });n.on(‘exit’, (cc, signal) =&gt; { console.log(‘in parent, child send exit signal’,cc, signal);}) n.on(‘close’, (cc, signal) =&gt; { console.log(‘in parent, child send close signal’, cc, signal);}) console.log(‘3’); 12 // child.js console.log(‘4’);process.on(‘message’, (m) =&gt; { console.log(‘CHILD got message:’, m); }); process.send({ foo: ‘bar’ });console.log(‘5’); 123终端运行：` node parent.js`输出： 12345in Parent child is connect truePARENT got message: { foo: ‘bar’ }CHILD got message: { hello: ‘world’ }12345此时，再开一个终端，使用`ps ax | grep node` 找到child.js 的进程，执行`kill -9 pid` 原来终端会显示 in parent, child send exit signal null SIGKILLin parent, child send close signal null SIGKILL 12如果是在child.js 中故意写一些错误，会监控到code 为1 ，输出： in parent, child send exit signal 1 nullin parent, child send close signal 1 null ` 参考官方文档 参考","tags":[{"name":"js","slug":"js","permalink":"https://akijiangrou.github.io/tags/js/"},{"name":"nodejs","slug":"nodejs","permalink":"https://akijiangrou.github.io/tags/nodejs/"},{"name":"shell","slug":"shell","permalink":"https://akijiangrou.github.io/tags/shell/"}]},{"title":"d3-scale","date":"2017-09-21T06:54:58.000Z","path":"2017/09/21/d3-scale/","text":"scale缩放也叫比例尺。是可视化的基本，使抽象的数据，转换成可视化的代表，比如宽高，位置或者颜色等。 输入 &amp; 输出scale缩放，其实是一种mapping。将输入的数据转换成对应的想要的输出的数据形式。 既然是转换，那就需要输入和输出。 输入是放入domain函数的参数。输出时放入range 函数的参数。 妙记 ID OR其实每个scale函数返回的都是函数，需要的参数就是实际展示的数据。 先举几个基本例子： 人口范围50万-130万 对应 输出长度为 500像素范围。 12345var newRamp = d3.scale.linear().domain([500000,13000000]).range([0, 500]);newRamp(1000000); // return 20;说明，人数为100万时对应长度为20像素newRamp(9000000);newRamp.invert(313); // 知道像素长度313px，想知道他对应的人口数。 人口范围50万-130万 对应 输出颜色 蓝色-红色 123456var newRamp = d3.scale.linear().domain([500000,13000000]).range([\"blue\",\"red\"]);newRamp(1000000); // return #ad0052;说明，人数为100万时对应颜色newRamp(9000000);newRamp.invert(#ad0052); //NaNinvert适应于输出为数字的比例转换。 示意： 离散型，将一组数据分为三类 12345var sampleArray = [423,124,66,424,58,10,900,44,1];var qScale = d3.scale.quantile().domain(sampleArray).range([0,1,2]);qScale(423); // 2qScale(20); // 0qScale(10000); //2 示意： scale 分类按照我个人的偏好分类如下： 输入输出都连续[linear, power, log]输出离散[quantize scale quantile]输入输出都离散[band, point, ordinal]颜色相关[scaleSequential, category]时间相关[scaleTime 属于连续型] 输入输出都连续 scaleLinear scalePower scaleLog scaleSqrt scaleTime scaleSequential 后两个单独做解释。线性scaleLinear， 没什么可说的，就是输出与输入呈线性相关。y = ax + b幂指数scalePower，输出与输入的幂指数呈正相关。y = m * x^k + b平方根缩放scaleLog，就是幂指数中k = 0.5。关于这个，一般用于使用面积来表达数据值的大小时。所以该scale函数的结果可以作为r的值。对数缩放scaleLog， 输出与输入的对数呈正相关。 y = m * log(x) + b 参考代码：d3-practice 关于连续型的缩放，还有其他几个参数： Clamp()：控制当输入超过range的情况。默认是false，如果超过range，则会自动按比例换算成domain以外的值。设为true则会严格控制结果在对应的domain中。 Nice()：主要用在使用真实数据来设置range的时候，d3.extent(data)会自动读取min&amp;max作为范围。但是如果作为坐标轴，可能数据看起来不是很好看，设置成nice()它会自动向上取整。 invert()：可以根据给出的输出值，来计算输入值。【注意】：domain必须是数字类型的 range: 支持多个value。同时domain也要输入多个参数。相互为边界，实现缩放。例子：（见下面的多段缩放） 12345678910111213141516171819202122// 位置缩放const firstScale = d3.scaleLinear() .domain([0, 10]) .range([0, 400]);// 面积缩放const sqrScale = d3.scaleSqrt() .domain([0, 10]) .range([0, 40]);// 多段缩放const fourthScale = d3.scaleLinear() .domain([0, 5, 10]) .range(['purple','white', 'lightgreen']);canvas.selectAll('.fourthScale') .data(testData) .enter() .append('circle') .attr('class', 'fourthScale') .attr('r', d =&gt; sqrScale(d)) .attr('cx', d =&gt; firstScale(d)) .attr('cy', 200) .attr('fill', d =&gt; fourthScale(d)); 结果如下： 输入连续，输出离散 scaleQuantize输入可以是连续范围，输出是离散的值，在range中规定。输入会按照输出数组的长度n分成n份。调用的时候，根据输入判定落在那个区间内，就输出对应的range中的值。例子: 1234567var quantizeScale = d3.scaleQuantize() .domain([0, 100]) .range(['purple', 'pink', 'lightgreen']);quantizeScale(10); // returns 'purple'quantizeScale(30); // returns 'purple'quantizeScale(90); // returns 'lightgreen' scaleQuantile与上面类似，但是输入可以是随机的数组，d3会主动将domain中的数组排序，然后按照range的参数长度n来将排序后的输入分成n组，然后，按照下标值将domain内容均分，然后分别对应range中的内容。（当数量不均分时，可通过quantileScale.quantiles()查看边界分类）。 例子： 1234567891011121314151617181920212223var myData = [0,4,6,9,10];var linearScale = d3.scaleLinear() .domain([0, 100]) .range([0, 600]);var quantileScale = d3.scaleQuantile() .domain(myData) .range(['lightblue', 'orange', 'lightgreen']);console.log(quantileScale.quantiles()) // [4.666666666666666, 8]d3.select('#wrapper') .selectAll('circle') .data([0, 3,5,6, 7, 8, 9,10, 20]) .enter() .append('circle') .attr('r', 3) .attr('cx', function(d) &#123; return linearScale(d); &#125;) .style('fill', function(d) &#123; return quantileScale(d); &#125;); scaleThreshold将domain中的数据映射到range中的颜色或者离散值。其实domain规定的数据的门限值，就是range中范围的分界点。domain中的数组长度要比range的少一位，这样才能将所有数据包含。看例子： 12345678var thresholdScale = d3.scaleThreshold() .domain([0, 50, 100]) .range(['#purple', 'lightblue', 'orange', '#red']);thresholdScale(-10); // returns '#purple'thresholdScale(20); // returns 'lightblue'thresholdScale(70); // returns 'orange'thresholdScale(110); // returns '#red' 输入输出都离散 scaleOrdinaldomain和range规定的内容是一一对应的。如果range长度不够，则重复range。如果输入的数据布在domain中，则会将range中的第一个值赋给他。这个可以通过设置.unknown(&#39;xxxx&#39;)来自定义。 scaleBanddomain规定每个band的值，range中规定整个柱形图的长度，也就是多个柱子和间隙的总和。当输入数据时，会返回对应的柱子的宽度以及起始位置。柱子宽度通过d3.scaleBand().bandwidth() bandwidth() 柱子宽度paddingInner() 每个band间的距离paddingOuter() 第一个子band前面的padding和最后一个子band后面padding 之和。常用在柱形图，条形图中。自动生成柱子和间隙的位置。 scalePoint按照给出的domain将range范围分为对应的n-1份。两边的间隔可以通过d3.scalePoint.padding()来计算。而间隔的值可通过step()获取 一般输入输出都离散，常用在坐标轴，颜色中。 颜色相关 scaleSequential这个和线性的类似，只不过range是不能配置的，而是通过interpolator()来对应的。其中，插值函数是接收0，1之间的输入，输出两个数字，颜色或者字符之间的插值。这个一般用于热力图等关于颜色的计算中，而且d3规定了一些内置的颜色插值。代码参考如下图： category Scales 用于 scaleOrdinal中根据预置的颜色集合，生成具体的颜色块。更多颜色参考：https://github.com/d3/d3-scale-chromatic使用方法： 123456789const color = d3.scaleOrdinal(d3.schemeCategory10);...canvas.selectAll('.test') .data(testData) .enter() .append('circle') .attr('class', 'test') .attr('fill', d =&gt; color(d)); 时间相关 scaleTime主要用于与时间相关的应用上。可以将连续的时间转换成range中的范围，可以是长度颜色等等。可以通过scaleTime获取一些数据，用ticks()。比如想要获取domain中每十天的值，可以使用如下代码： 12345const timescale = d3.scaleTime() .domain([new Date(2017, 7, 1), new Date(2017, 9, 1)]) .range([0, 600]);const infor = timescale.ticks(d3.timeDay.every(10)); 以上输出的是：August 01August 11August 21August 31September 01September 11September 21October 01更多时间tick可以参考：https://github.com/d3/d3-scale#time-scales时间格式输出，参考：https://github.com/d3/d3-time-format 参考一参考二","tags":[{"name":"d3","slug":"d3","permalink":"https://akijiangrou.github.io/tags/d3/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://akijiangrou.github.io/tags/学习笔记/"}]},{"title":"html5-小插件","date":"2017-09-21T02:56:33.000Z","path":"2017/09/21/html5-小插件/","text":"有些时候会遇到上传文件和下载的需求，一般原生html样式并不能满足要求。所以总结了一下平时常用的图片上传，问价上传下载等简单的小需求的实现。 包含图片上传，限制图片的大小。文件上传和下载（不用form 标签）之前做地图需求的，字符颜色转rgb的简单转化。 大部分的组件渲染是基于react，所以写法都是react相关的。 上传图片及检查大小本示例是限制了上传图片的大小，maxWidth: 600, maxHeight: 300, maxSize: 200, 上传前前端先做检查。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import React, &#123; Component, PropTypes &#125; from 'react';import imageStyles from '../styles/image.css';import &#123; imageSizeCheck, newImageSrc &#125; from '../utils/imgCheck.js';/** * Image 组件，支持上传图片 * * @props onImageChange 传回上传的图片的地址 * @props onError 上传失败的处理 */class Image extends Component &#123; constructor() &#123; super(...arguments); // 用于自动设置图片高度 this.state = &#123; imageHeight: 180, &#125;; &#125; componentDidMount() &#123; if (typeof window === 'undefined') return; const imageHeight = this.refs.imageContainer.offsetWidth * 0.618; this.setState(&#123; imageHeight &#125;); &#125; handleClick() &#123; // 模拟点击上传图片按钮 this.refs.file.click(); &#125; handleChange() &#123; const formData = new FormData(); formData.append('file', this.refs.file.files[0]); // 检验图片大小 this.imageCheck(this.props.subtype, this.refs.file.files[0], (err, res) =&gt; &#123; if (err) &#123; const msg = `请选择$&#123;res.maxWidth&#125;*$&#123;res.maxHeight&#125;像素且大小不超过$&#123;res.maxSize&#125;k的图片上传`; window.alert(`您的图片为$&#123;res.height&#125;*$&#123;res.width&#125;像素,大小为$&#123;res.size&#125;k. $&#123;msg&#125;`); &#125; else &#123; // 成功的操作 &#125; &#125;); &#125; imageCheck(subtype, file, cb) &#123; // 可修改图片检查的大小和尺寸。 const sixthree = &#123; imgFile: file, maxWidth: 600, maxHeight: 300, maxSize: 200, &#125;; imageSizeCheck(sixthree, (err, res) =&gt; &#123; if (err) &#123; return cb(err, res); &#125; imageSizeCheck(&#123; imgFile: file, maxWidth: 700, maxHeight: 350, maxSize: 200, &#125;, cb); &#125;); &#125; render() &#123; return ( &lt;div ref=\"imageContainer\" className=&#123;imageStyles.imageContainer&#125;&gt; &lt;div className=&#123;imageStyles.imageUpload&#125; onClick=&#123;this.handleClick.bind(this)&#125; style=&#123;&#123; height: this.state.imageHeight, lineHeight: this.state.imageHeight + 'px', &#125;&#125; &gt;点击上传图片 &lt;/div&gt; &lt;input ref=\"file\" className=&#123;imageStyles.inputFile&#125; onChange=&#123;this.handleChange.bind(this)&#125; type=\"file\" accept=\"image/*\"/&gt; &lt;/div&gt; ); &#125;&#125;export default Image; 123456789101112131415161718192021222324252627282930image.css.imageContainer &#123; position: relative; overflow: hidden;&#125;.imageContainerHasImg .imageUpload &#123; opacity: 0;&#125;.imageUpload &#123; opacity: 0.5; background: #999; position: absolute; top: 0; left: 0; width: 100%; color: white; text-align: center; font-size: 2em; cursor: pointer; transition: opacity 0.3s;&#125;.imageUpload:hover &#123; opacity: 0.6;&#125;input[type=\"file\"].inputFile &#123; display: none;&#125;.img &#123; width: 100%;&#125; 123456789101112131415161718192021222324252627imageCheck.jsexport function imageSizeCheck(&#123; imgFile, maxWidth, maxHeight, maxSize &#125;, cb) &#123; const res = &#123; maxWidth, maxHeight, maxSize, &#125;; const size = Math.floor(imgFile.size / 1024); const reader = new FileReader(); reader.onload = (e) =&gt; &#123; const data = e.target.result; const tempImg = document.createElement('img'); tempImg.onload = () =&gt; &#123; res.width = tempImg.width; res.height = tempImg.height; res.size = size; if (res.width &gt; maxWidth || res.height &gt; maxHeight || res.size &gt; maxSize) &#123; cb(new Error('上传失败'), res); &#125; else &#123; cb(null, null); &#125; &#125;; tempImg.src = data; &#125;; reader.readAsDataURL(imgFile);&#125; 文件上传文件上传有默认的样式，一般都是不满足的，所以用一下方式修改。后面的span用于展示文件内容。 12345&lt;div className=\"monitor-clickUploader\"&gt; &lt;span className=\"monitor-upload-btn\"&gt; + 上传商户id&lt;/span&gt; &lt;input type=\"file\" name=\"file\" ref=&#123;input =&gt; &#123; this.upload = input; &#125; &#125; onChange=&#123;() =&gt; this.handleFileChanged()&#125;/&gt; &lt;/div&gt; &lt;span&gt;&#123;this.state.fileName&#125;&lt;/span&gt; 1234567891011121314151617181920212223242526272829.monitor-clickUploader &#123; position: relative; overflow: hidden; display: inline-block; margin: 0px 10px 0px 20px; vertical-align: middle;&#125;.monitor-clickUploader input &#123; position: absolute; top: 0; left: 0; margin: 0; padding: 0; font-size: 20px; cursor: pointer; opacity: 0; filter: alpha(opacity=0);&#125;.monitor-upload-btn &#123; display: inline-block; border: 1px solid #3bb4f1; position: relative; color: #3bb4f1; padding: 4px 10px 4px 10px; font-size: 12px; border-radius: 3px; cursor: pointer;&#125; 1234567handleFileChanged() &#123; const fileList = this.upload.files; if (fileList.length &gt; 0) &#123; this.setState(&#123; fileName: fileList[0].name&#125;); &#125;&#125; 展示样式： 文件上传提交上传文件需要formdata格式，但是不用自己显式的写明content-type,有时会出问题。不需要写form，可以这样写。 文件上传的html同上。触发上传： 1234567&lt;button style=&#123;&#123; marginLeft: 70, marginTop: 20 &#125;&#125; type=\"button\" className=\"btn Btn\" disabled=&#123;startDate === \"\" || endDate === \"\" || poiResultList.length &lt;=0 || monitorIndexList.length &lt;= 0&#125; onClick=&#123;() =&gt; this.handleFileUpload()&#125;&gt;开始监控&lt;/button&gt; 1234567891011handleFileUpload() &#123; const formData = new FormData(); const fileList = this.upload.files; if (fileList.length &gt; 0) &#123; formData.append('uploadFile', fileList[0]); this.props.postMonitor(&#123; formData &#125; ) &#125; &#125; //postMonitor里发送formdata文件。xhr就行。 前端实现下载功能2进制文件12345678910111213141516171819202122232425262728293031323334// render部分：&lt;div style=&#123;&#123; display: canDownload ? 'inline-block' : 'none' &#125;&#125; className=&#123;listcss.download&#125; onClick=&#123;this.handleDownload&#125;&gt;导出数据&lt;/div&gt; // 处理：handleDownload() &#123; const &#123; download &#125; = this.props; if (download &amp;&amp; download.length &gt; 0) &#123; const u8arr = new Uint8Array(download.length); let length = download.length; while (length--) &#123; u8arr[length] = download[length]; &#125; const blob = new Blob([u8arr.buffer], &#123; type: 'application/vnd.ms-excel' &#125;); const fileName = 'orderData.xls'; downBinaryToExcel(blob, fileName); &#125; &#125; export const downBinaryToExcel = (blob, fileName) =&gt; &#123; if (window.navigator.msSaveOrOpenBlob) &#123; navigator.msSaveBlob(blob, fileName); &#125; else &#123; const link = document.createElement('a'); link.href = window.URL.createObjectURL(blob); link.download = fileName; link.click(); window.URL.revokeObjectURL(link.href); &#125;&#125;; 数组或者字符串内容下载主要是拼接成excel需要的格式, 然后放在blob的内容里。 1234567891011121314151617181920212223242526272829const headerInfo = `&lt;?xml version=\"1.0\"?&gt;&lt;ss:Workbook xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\"&gt;&lt;ss:Worksheet ss:Name=\"Sheet1\"&gt;&lt;ss:Table&gt;\\n`;const footerInfo = `&lt;/ss:Table&gt;&lt;/ss:Worksheet&gt;&lt;/ss:Workbook&gt;`;// 自己组织数据结构，包括一行表头，和每行的数据。const composeRow = R.compose( item =&gt; `&lt;ss:Row&gt;\\n$&#123;item&#125;&lt;/ss:Row&gt;\\n`, R.join(''), R.map( item =&gt; ` &lt;ss:Cell&gt; &lt;ss:Data ss:Type=\"$&#123;R.is(Number, item) ? 'Number' : 'String'&#125;\"&gt;$&#123;item&#125;&lt;/ss:Data&gt; &lt;/ss:Cell&gt;` ));const rows = FUNC（composeRow）// 具体的自己写吧const xml = `$&#123;headerInfo&#125;$&#123;rows&#125;$&#123;footerInfo&#125;`; HEX TO RGB12345678910export const hexToRgb = hex =&gt; &#123; const rgb = []; let letters = hex.substr(1); if (letters.length === 3) &#123; letters = letters.replace(/(.)/g, '$1$1'); &#125; letters.replace(/../g, color =&gt; &#123; rgb.push(parseInt(color, 0x10)); &#125;); return rgb;&#125;;","tags":[{"name":"html5","slug":"html5","permalink":"https://akijiangrou.github.io/tags/html5/"},{"name":"图片上传","slug":"图片上传","permalink":"https://akijiangrou.github.io/tags/图片上传/"},{"name":"文件上传","slug":"文件上传","permalink":"https://akijiangrou.github.io/tags/文件上传/"},{"name":"文件下载","slug":"文件下载","permalink":"https://akijiangrou.github.io/tags/文件下载/"}]},{"title":"D3-api-transition","date":"2017-09-18T08:45:41.000Z","path":"2017/09/18/D3-api-transition/","text":"D3的动效API-transitionD3的动效都是通过transition来实现的。 transition 是类似于selection的接口，它用于动画改变DOM界面。transition 通过 selection.transition 获得，他和d3.select(…)返回的内容是一样的。 常用api基本api： selection.transition([name])selection.interrupt([name])transition.duration()transition.delay(value|func)transition.ease(name)transition.each()transition.call()transition.filter()transition.merge()transition.remove() 高级： transition.on 监控控制流，几个状态：start，end，interrupt。这个只是transition对象有。 transition.attrTweentransition.styleTweentransition.tween(name[, value]) 最简单例子在需要变化的属性前加上transition()即可~~例子： 12345678910111213svg.selectAll(\"rect\") .data(dataset) .transition() // &lt;-- This is new! Everything else here is unchanged. .attr(\"y\", function(d) &#123; return h - yScale(d); &#125;) .attr(\"height\", function(d) &#123; return yScale(d); &#125;) .attr(\"fill\", function(d) &#123; return \"rgb(0, 0, \" + (d * 10) + \")\"; &#125;); 如果不加，则立即执行，加了则延迟一点点。默认：250ms 常用的transition写法123456.transition() .delay(function(d,i)&#123; return i * 150; &#125;) .duration(1500) .ease(d3.easeBack) 每个元素都会有自己的delay。 ease 函数&quot;easeElastic&quot;, &quot;easeBounce&quot;, &quot;easeLinear&quot;, &quot;easeSin&quot;, &quot;easeQuad&quot;, &quot;easeCubic&quot;, &quot;easePoly&quot;, &quot;easeCircle&quot;, &quot;easeExp&quot;, &quot;easeBack&quot; 调用：1selection.ease(d3.easeElastic) 链式调用连续添加多个transition,最简单的方法之一，就是在第一个transition完成后，继续调用transition。参考例子：https://codepen.io/akixiao/pen/BwNZRp d3.active(node, [name])返回具有指定名称（如果有）的指定节点上的active transition。如果未指定名称，则使用null。如果指定节点上没有这样的active transition，则返回null。此方法对于创建链接transition很有用。 tween 补间动画transition的变化详情，是通过interpolate实现的。默认有几个情况：如果attr中的value是数字，则使用interpolateNumber如果value是color或者字符颜色，则使用 interpolateRgb.其他情况：interpolateString style的属性也是一样的tween有自己的时间函数tween相关函数使用重点就是在，tween函数中设置自己的时间函数： 123456transition.tween(\"attr.fill\", function() &#123; var node = this, i = d3.interpolateRgb(node.getAttribute(\"fill\"), \"blue\"); return function(t) &#123; node.setAttribute(\"fill\", i(t)); &#125;;&#125;); 另一个数字补间应用： 12345678.tween('number', function() &#123; const that = d3.select(this); const i = d3.interpolateRound(0, 200); return function(t) &#123; that.style('color', `rgb($&#123;0 + i(t)&#125;, $&#123;80 + i(t)&#125;, 232)`); that.text(i(t)); &#125;&#125;); 演示：https://codepen.io/akixiao/pen/mBJqzO 循环变换一般通过是将transition写成一个函数。然后使用on监听end事件，实现递归调用。简单例子： 1234567891011121314function repeat() &#123; show.transition() .delay(800) .duration(2000) .tween('number', function() &#123; const that = d3.select(this); const i = d3.interpolateRound(0, 200); return function(t) &#123; that.style('color', `rgb($&#123;0 + i(t)&#125;, $&#123;80 + i(t)&#125;, 232)`); that.text(i(t)); &#125; &#125;) .on('end', repeat); &#125; 一些例子d3实现的smooth scroll高级玩法：https://bl.ocks.org/mbostock/70d5541b547cc222aa02 参考 d3 transitionworking with transitionsD3 Tips and Tricks V4.0D3 Transition Basics","tags":[{"name":"d3","slug":"d3","permalink":"https://akijiangrou.github.io/tags/d3/"},{"name":"transition","slug":"transition","permalink":"https://akijiangrou.github.io/tags/transition/"}]},{"title":"关于Object查缺补漏","date":"2017-09-18T08:09:48.000Z","path":"2017/09/18/关于Object查缺补漏/","text":"内置对象这些都是对象子类型，看起来与基础类型一样。如下： String Number Boolean Object Function Array Date RegExp Error 以上内置函数可以当做构造函数来使用。一些字面可以自动转换成对象类型进行一些方法的操作。 深复制 &amp; 浅复制对于对象和数组来说，浅复制是对对象地址的复制，并没有开辟新的栈，复制的结果是两个对象指向同一个地址，修改一个对象的属性，会改变另一个对象属性。深复制则开辟新的栈，两个对象对应两个不同的地址，属性隔离。 浅复制：拷贝引用深复制：拷贝实例深复制比较耗内存，而且可能出现死循环栈溢出的情况。深复制死循环的例子： const testArr = [];const myObj = { a: 2, b: testArr,}; testArr.push(myObj, true); 比如深复制myObj, 除了复制myObj外，还要复制testArr，而testArr引用了myObj,所以又要再次复制myObj，然后这两个开始循环引用导致死循环了。 Object.assign是es6里非常好用的一个方法，Object.assign() 属性描述符是从es5以后，对象属性有了属性描述符。一个对象的属性不仅包含属性值，还包含另外三个特性：writable，enumerable 和 configurable使用该函数，可以获取一个对象属性的配置信息。Object.getOwnPropertyDescriptor( myObject, “a” ); 使用下面的函数，可以配置对象属性Object.defineProperty(obj, ‘prop’, { value: 6, writable: true, configurable: true, enumerable: true,}); writable: 控制能否重写这个属性的值enumerable: 控制这个属性能否被遍历configurable: 控制这个属性的属性描述符是否可以修改，也就是控制这三个属性是否可以被修改。configurable:false 还会禁止删除这个属性 控制属性的不变性当我们想控制一些对象的属性，让他成为不可改变的，我们有如下几种方法： 结合writable &amp; configurablewritable:falseconfigurable:false 对应的属性将不会被更改。也不能被删除。 禁止扩展Object.preventExtensions可以禁止一个对象添加新属性，并且保留已有属性。 12345var obj = &#123; a: 2&#125;;Object.preventExtensions(obj);obj.b = 3;obj.b; // undefined // strict mode：typeError seal 密封Object.seal(..) 会创建一个“密封”的对象，等价于preventExtensions + 每个属性configurable: false;但是其实这个是可以修改属性值的。 freeze 冻结等价于对对象使用seal，并把每个属性标记为writable:false; 但是该属性可以修改深度的对象。 对象属性获取原理属性访问其实是通过对象的[[get]]获取的。对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性， 如果找到就会返回这个属性的值。如果本对象中没有，会遍历原型链进行寻找。如果都没有则返回undefined。 在es6中，我们可以进行这个内置操作的修改了。比如Proxy 代理对象。 对应的还有[[Put]]内置操作。主要用来设置对象的值。[[Put]] 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性(这是最重要的因素，没有则会去查原型链)。如果已经存在这个属性，[[Put]] 算法大致会检查下面这些内容。 属性是否是访问描述符?如果是并且存在setter就调用setter。 属性的数据描述符中writable是否是false?如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。 如果都不是，将该值设置为属性的值。 getter &amp; setter可以在对象的某个属性上进行修改默认的getter与setter函数。但是一般这两个要绑定在一起输出。两个方法： 123456789101112131415const obj = &#123; get c() &#123; return 1;&#125; &#125;;Object.definePropperty(obj, 'b', &#123; get: function() &#123; return 2;&#125;&#125;);obj.c // 1obj.b // 2 obj.b = 3;obj.b // 2// get set 经典搭配const myObj = &#123; get a() &#123; return this._a_; &#125; set a(val) &#123; this._a_ = val &#125;&#125; 属性存在性检验一个对象中是否有某个属性，可以用 in hasOwnProperty 。可以用于检测是属性值为undefined，还是为定义属性。但是这两个的区别是，in是对象本身和其原型链都查，后者则只查对象本身。 参考的是《你不知道的javascript》","tags":[{"name":"javascript","slug":"javascript","permalink":"https://akijiangrou.github.io/tags/javascript/"},{"name":"object","slug":"object","permalink":"https://akijiangrou.github.io/tags/object/"}]},{"title":"React生命周期","date":"2017-09-12T11:07:41.000Z","path":"2017/09/12/React生命周期/","text":"react生命周期在自定义React组件时，会根据需要在组件生命周期的不同阶段实现不同的逻辑。本文源码是【15.6.1】 生命周期而组件的生命周期在不同状态下的执行顺序如下： 首次挂载组件 getDefaultProps getInitialState componentWillMount render componentDidMount 重新挂载组件 getInitialState componentWillMount render componentDidMount 再次渲染组件-props CHANGE componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 再次渲染组件-state CHANGE shouldComponentUpdate componentWillUpdate render componentDidUpdate 下面就是揭秘React为何会按照上面这个执行生命周期。 生命周期详解自定义组件声明周期存在3个阶段：MOUNTING, RECEIVE_PROPS, UNMOUNTING 分别对应3种方法。 mountComponent， updateComponent unmountComponent 以上每个都提供了几种处理方法。will前缀的方法在进入状态之前调用，did在进入状态之后调用。 使用createClass创建自定义组件ES6编写React组件时： class MyComponent extends React.Component 是调用createClass创建组件，利用原型继承ReactClassComponent父类，合并mixins，初始化defaultProps，返回构造函数。下面是代码。 关于createClass：【isomorphic/class/createClass.js】 &apos;use strict&apos;; var {Component} = require(&apos;ReactBaseClasses&apos;); var {isValidElement} = require(&apos;ReactElement&apos;); var ReactNoopUpdateQueue = require(&apos;ReactNoopUpdateQueue&apos;); var factory = require(&apos;create-react-class/factory&apos;); module.exports = factory(Component, isValidElement, ReactNoopUpdateQueue); factory: [react/addons/create-react-class/factory.js]; component如上，但是createClass实际上导出的是由factory`包裹的函数。各种生命周期都是在factory里构造的。factory里定义了，ReactClassInterface`，里面规定了好多协议（如render等） // Helper function to allow the creation of anonymous functions which do not // have .name set to the name of the variable being assigned to. function identity(fn) { return fn; } function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) { var injectedMixins = []; // 定义reactclass中的协议（其实就是方法） var ReactClassInterface = { mixins: &apos;DEFINE_MANY&apos;, statics: &apos;DEFINE_MANY&apos;, propTypes: &apos;DEFINE_MANY&apos;, contextTypes: &apos;DEFINE_MANY&apos;, childContextTypes: &apos;DEFINE_MANY&apos;, getDefaultProps: &apos;DEFINE_MANY_MERGED&apos;, getInitialState: &apos;DEFINE_MANY_MERGED&apos;, getChildContext: &apos;DEFINE_MANY_MERGED&apos;, render: &apos;DEFINE_ONCE&apos;, componentWillMount: &apos;DEFINE_MANY&apos;, componentDidMount: &apos;DEFINE_MANY&apos;, componentWillReceiveProps: &apos;DEFINE_MANY&apos;, shouldComponentUpdate: &apos;DEFINE_ONCE&apos;, componentWillUpdate: &apos;DEFINE_MANY&apos;, componentDidUpdate: &apos;DEFINE_MANY&apos;, componentWillUnmount: &apos;DEFINE_MANY&apos;, updateComponent: &apos;OVERRIDE_BASE&apos; }; var ReactClassComponent = function() {}; _assign( ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin ); function createClass(spec) { // Constructor.name !== &apos;Constructor&apos;.确保不会将没有displayName的类识别为&apos;Constructor&apos;。重写了contructor函数~~~~ var Constructor = identity(function(props, context, updater) { // 自动绑定 if (this.__reactAutoBindPairs.length) { bindAutoBindMethods(this); } this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue; this.state = null; // reactClasses没有构造函数，通过getInitialState，与componentWillMount来进行初始化。 var initialState = this.getInitialState ? this.getInitialState() : null; // 原型继承自父类。 Constructor.prototype = new ReactClassComponent(); Constructor.prototype.constructor = Constructor; Constructor.prototype.__reactAutoBindPairs = []; injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor)); // 把didmount，willunmount赋给原型 mixSpecIntoComponent(Constructor, IsMountedPreMixin); mixSpecIntoComponent(Constructor, spec); mixSpecIntoComponent(Constructor, IsMountedPostMixin); // Initialize the defaultProps property after all mixins have been merged. // 所有mixin合并后，开始初始化defaultProps if (Constructor.getDefaultProps) { Constructor.defaultProps = Constructor.getDefaultProps(); } // 减少查找并设置原型的时间。 for (var methodName in ReactClassInterface) { if (!Constructor.prototype[methodName]) { Constructor.prototype[methodName] = null; } } return Constructor; } return createClass; } 以上是初始化的阶段，第一次mounting前，createClass返回Constructor函数。getDefaultProps 是在constructor阶段调用的，所以生成一个实例后，就不会再调用了。所以只有初次挂载的时候才会调用。。。 mountComponent阶段mountComponent负责管理生命周期的getInitialState，componentWillMount，render，和componentDidMount. mountComponent挂载组件，初始化序号，标记等参数，判断是否为无状态组件，以及初始化操作。使用getInitialState获取初始化state。在componentWillMount中调用setState，不触发re-render，而是merge state。这个状态的this.state并不是最新的。在render中才可以获取更新的this.state。 [代码里] // When mounting, calls to `setState` by `componentWillMount` will set // `this._pendingStateQueue` without triggering a re-render. if (this._pendingStateQueue) { inst.state = this._processPendingState(inst.props, inst.context); // merge state } 利用：this._pendingStateQueue , this._pendingReplaceState, this._pendingForceUpdate 实现setState的异步跟新机制。 render后，若存在didMount，则调用。 mountComponent通过递归渲染的，由于是递归，肯定是父的willMOUNT, 父的RENDER, 子的willMount，子render，子didMount，父didmount。 mountComponent,初始化state，执行initialMount，返回markup。 mountComponent: function( transaction, hostParent, hostContainerInfo, context, ){ ... var initialState = inst.state; if (initialState === undefined) { inst.state = initialState = null; } this._pendingStateQueue = null; this._pendingReplaceState = false; this._pendingForceUpdate = false; var markup; if (inst.unstable_handleError) { markup = this.performInitialMountWithErrorHandling( renderedElement, hostParent, hostContainerInfo, transaction, context, ); } else { markup = this.performInitialMount( renderedElement, hostParent, hostContainerInfo, transaction, context, ); } if (inst.componentDidMount) { if (__DEV__) { transaction.getReactMountReady().enqueue(() =&gt; { measureLifeCyclePerf( () =&gt; inst.componentDidMount(), this._debugID, &apos;componentDidMount&apos;, ); }); } else { transaction.getReactMountReady().enqueue(inst.componentDidMount, inst); } } return markup; } 在performInitialMount函数中, 使用ReactReconciler，进行递归渲染组件。 var markup = ReactReconciler.mountComponent( child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID, ); RECEIVE—props update的过程源码里面：updateComponent负责管理生命周期的 componentWillReceiveProps，shouldComponentUpdate, componentWillUpdate, componentDidUpdate; 首先通过updateComponent更新组件，如果元素不一致，说明要进行组件更新。代码继续向下执行，如果有componentWillReceiveProps执行，其中有setState会合并state，且在componentWillReceiveProps，shouldComponentUpdate，componentWillUpdate中不会获取到新的state。只能在render和did状态才能获取。剩下几个状态也是有就执行，且顺序为：shouldComponentUpdatecomponentWillUpdaterendercomponentDidUpdate 在updateComponent中 updateComponent: function( transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext, ) { var inst = this._instance; … var willReceive = false; // 判断context变化与否，设置willReceive。 if (this._context === nextUnmaskedContext) { nextContext = inst.context; } else { nextContext = this._processContext(nextUnmaskedContext); willReceive = true; } var prevProps = prevParentElement.props; var nextProps = nextParentElement.props; // 判断props变化与否，设置willReceive。 if (prevParentElement !== nextParentElement) { willReceive = true; } if (willReceive &amp;&amp; inst.componentWillReceiveProps) { ... 判断和执行componentWillReceiveProps } var nextState = this._processPendingState(nextProps, nextContext); var shouldUpdate = true; ... 下面是关于shouldupdate的判断和执行。 shouldComponentUpdate，如果用户自定义了，则按照自定义判断来返回shouldUpdate，否则执行默认操作： if (!this._pendingForceUpdate) { if (inst.shouldComponentUpdate) { if (__DEV__) { shouldUpdate = measureLifeCyclePerf( () =&gt; inst.shouldComponentUpdate(nextProps, nextState, nextContext), this._debugID, &apos;shouldComponentUpdate&apos;, ); } else { shouldUpdate = inst.shouldComponentUpdate( nextProps, nextState, nextContext, ); } } else { if (this._compositeType === CompositeTypes.PureClass) { shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState); } } } 后面render要根据shouldUpdate的状态来执行。 if (shouldUpdate) { this._pendingForceUpdate = false; // Will set `this.props`, `this.state` and `this.context`. this._performComponentUpdate( nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext, ); } else { // 如果确定不更新，也要设置props，state，context this._currentElement = nextParentElement; this._context = nextUnmaskedContext; inst.props = nextProps; inst.state = nextState; inst.context = nextContext; } 如果应该update则调用一下函数this._performComponentUpdate规定了如果有componentWillUpdate，调用。然后是_updateRenderedComponent，进行re-render，调动render方法更新dom接着，如果有hasComponentDidUpdate，调用。 _updateRenderedComponent: function(transaction, context) { // 如果需要更新，则调用ReactReconciler.receiveComponent跟新组件 if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) { ReactReconciler.receiveComponent( prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context), ); } else { // 渲染组件，render递归 var nextMarkup = ReactReconciler.mountComponent( child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID, ); } 也是递归render的，所以也是父的先willUpdate，然后子的willUpdate,子的didUpdate，父的DidUpdate unmounting负责管理componentWillUnmount 如果规定了componentWillUnmount，则执行并重置所有参数，更新队列以及状态。有setState，不会执行re-render。并清除了当前的这个实例。 无状态组件只是一个render方法，没有组件实例化过程。因为没有状态，没有生命周期，接收props生成dom结构。 setState 机制this.state 用来访问state，this.setState 用来更新state。但是我们在刚写react的时候，有些时候setState并不生效。原因慢慢来分析。 首先记住，setState是异步更新，这是通过监控一个state队列实现的，这也避免了频繁重复更新state。 调用setState的时候，会执行enqueueSetState方法，对partialState 和 _pendingStateQueue进行合并操作，最终通过enqueueUpdate执行state更新。这个也就是setState的时候，将需要更新的state进行合并，让后放到state 队列中，通过this.state = xxx 修改的state，并不会放入state队列中，也就不会更新。 源码在：src/isomorphic/modern/class/ReactBaseClasses.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556ReactComponent.prototype.setState = function(partialState, callback) &#123; invariant( typeof partialState === 'object' || typeof partialState === 'function' || partialState == null, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.', ); this.updater.enqueueSetState(this, partialState); if (callback) &#123; this.updater.enqueueCallback(this, callback, 'setState'); &#125;&#125;;src/renderers/shared/stack/reconciler/ReactUpdateQueue.js:enqueueSetState: function(publicInstance, partialState) &#123; var internalInstance = getInternalInstanceReadyForUpdate( publicInstance, 'setState', ); if (!internalInstance) &#123; return; &#125; var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []); queue.push(partialState); enqueueUpdate(internalInstance); &#125;,/src/renderers/shared/stack/reconciler/ReactUpdates.js:function enqueueUpdate(component) &#123; ensureInjected(); // Various parts of our code (such as ReactCompositeComponent's // _renderValidatedComponent) assume that calls to render aren't nested; // verify that that's the case. (This is called by each top-level update // function, like setState, forceUpdate, etc.; creation and // destruction of top-level components is guarded in ReactMount.)// 不处于批量更新模式，马上更新 if (!batchingStrategy.isBatchingUpdates) &#123; batchingStrategy.batchedUpdates(enqueueUpdate, component); return; &#125;// 处于批量更新模式，则放在dirtyComponent中，不能马上更新 dirtyComponents.push(component); if (component._updateBatchNumber == null) &#123; component._updateBatchNumber = updateBatchNumber + 1; &#125;&#125; 用如下例子解释：setSTATE: 1234567891011121314151617181920212223242526import React from 'react';class TestState extends React.Component &#123; constructor() &#123; super(); this.state = &#123; val : 0&#125;; &#125; componentDidMount() &#123; this.setState(&#123; val: this.state.val + 1&#125;); console.log(this.state.val); this.setState(&#123; val: this.state.val + 1&#125;); console.log(this.state.val); setTimeout(() =&gt; &#123; this.setState(&#123; val: this.state.val + 1&#125;); console.log(this.state.val); this.setState(&#123; val: this.state.val + 1&#125;); console.log(this.state.val); &#125;, 0); &#125; render() &#123; return (&lt;div&gt;&lt;/div&gt;); &#125;&#125;export default TestState; 输出 0 0 2 3 在componentDidMount中，this.setState({ val: this.state.val + 1}); 处于各种事务中，而事务的进行和结束，都需要一个一个的进行，而不是瞬时执行的，前两个setState语句运行时，isBatchingUpdates设为true了（这个应该是事务导致的），所以此时console.log state制并没有变。而setTimeout中，调用栈都发生变化了，变得很简单，并不处于事务中，也就没有bachedUpdate，所以isBatchingUpdate是false，马上就会更新state。","tags":[{"name":"react","slug":"react","permalink":"https://akijiangrou.github.io/tags/react/"},{"name":"生命周期","slug":"生命周期","permalink":"https://akijiangrou.github.io/tags/生命周期/"}]},{"title":"d3-basic-line","date":"2017-06-29T04:19:49.000Z","path":"2017/06/29/d3-basic-line/","text":"d3-折线图从一个最基本的折线图开始，看看d3是怎么实现的，以及用到哪些知识 需要的知识 scale extent transition line curve axis 步骤 获取svg容器 &lt;svg width=&quot;500&quot; height=&quot;270&quot; class=&quot;testline&quot;&gt;&lt;/svg&gt; const svg = d3.select(&apos;.testline&apos;); const margin = {top: 20, right: 20, bottom: 20, left: 20}; const width = +svg.attr(&quot;width&quot;) - margin.left - margin.right; const height = +svg.attr(&quot;height&quot;) - margin.top - margin.bottom; const g = svg.append(&quot;g&quot;).attr(&quot;transform&quot;, `translate(${margin.left},${margin.top})`); x，y轴缩放这里，如果x轴是与时间有关的，可以直接使用d3提供的scaleTime()来实现时间的转换。关于scale还有好多内容，待总结。这里需要确定两个轴，缩放的类型，以及xy轴图像在屏幕中的实际宽高值。这里的x, y 其实是函数（根据给出的数据，得出该数据的x，y坐标值）。 const x = d3.scaleTime().range([0, width]); const y = d3.scaleLinear().range([height, 0]); lineline的生成就需要上面的轴缩放函数。 这里是因为date函数可以接受ms的unix时间戳，所以乘以1000.这里也可以加一些点与点之间的连接方式。 curveMonotoneX平滑, curveLinear线性。需要两步，line函数生成。line呈现。关于line的展示，需要把数据绑定到path标签上，将line函数运用到path的d属性上。就可以绘制出线了，transition这里是为了实现简单的动画效果。注意，line展示的时候，data([data]) 也可应用datum(data)，前者删了数组标记是不可以的。不知道为什么 const line = d3.line() .x((d, i) =&gt; x(d.ts * 1000)) .y(d =&gt; y(d.y)) .curve(d3.curveMonotoneX); // line 的展示。 g.append(&apos;path&apos;) .data([data]).attr(&apos;fill&apos;, &apos;none&apos;).attr(&apos;d&apos;, line).attr(&apos;stroke&apos;, &apos;#f33155&apos;) .transition(500) .attr(&apos;stroke-width&apos;, 3); x坐标轴，y坐标轴domain是将坐标轴对应的真实数据连接起来，一般就是将坐标轴要展示的数据的最大最小值放进来。d3.extent可以自动的算出数组内的最小，最大值，很方便。如下x轴的计算。v4支持axisBottom，axisTop，axisRight，axisLeft等快捷操作，就是说明坐标轴的展现方式。规定好domain后，可以将轴展示在图像中了。给出selector然后调用call(如果是x轴，记得把上面x轴函数传进来，y轴同理)，同时，这里可以规定轴线样式和刻度的相关内容。下面的例子是规定了，最大最小值中间还可以有多少个刻度。 x.domain(d3.extent(data, d =&gt; d.ts * 1000)); y.domain([0, d3.max(data, d =&gt; d.y * 1.1 )]); // Add the X Axis g.append(&quot;g&quot;).attr(&quot;transform&quot;, `translate(0,${height})`) .call(d3.axisBottom(x).ticks(5)); // Add the Y Axis g.append(&quot;g&quot;).attr(&quot;transform&quot;, `translate(0,0)`) .call(d3.axisLeft(y).ticks(8)); 线上打点线上打点，主要是通过line函数，获取点的center位置。需要将data绑定到circle标签上，最后根据line函数绘制出来。 g.selectAll(&quot;.dot&quot;) .data(data).enter().append(&quot;circle&quot;).attr(&apos;class&apos;, &apos;.dot&apos;) .attr(&quot;cx&quot;, line.x()).attr(&quot;cy&quot;, line.y()) .transition(500) .attr(&quot;r&quot;, 3.5).attr(&apos;fill&apos;, &apos;white&apos;).attr(&apos;stroke&apos;, &apos;#f33155&apos;); 数据label类似的，label也是根据line函数获取位置，然后将要现实的值，用text属性显示出来。 g.selectAll(&quot;.text&quot;) .data(this.data).enter().append(&quot;text&quot;) .attr(&apos;class&apos;, &apos;.text&apos;).attr(&apos;font-size&apos;, 12) .attr(&quot;x&quot;, line.x()).attr(&quot;y&quot;, line.y()) .attr(&apos;dx&apos;, -15).attr(&apos;dy&apos;, 7) .text(function(d) { return d.y}) .transition(500) .attr(&apos;fill&apos;, &apos;#333&apos;).attr(&apos;stroke&apos;, &apos;#333&apos;); 当绑定了data数据后，x函数，y函数，会自动按顺序获取数据。 最后结果：参考","tags":[{"name":"d3","slug":"d3","permalink":"https://akijiangrou.github.io/tags/d3/"},{"name":"line","slug":"line","permalink":"https://akijiangrou.github.io/tags/line/"},{"name":"可视化","slug":"可视化","permalink":"https://akijiangrou.github.io/tags/可视化/"}]},{"title":"git实用指令","date":"2017-06-02T02:51:14.000Z","path":"2017/06/02/git实用指令/","text":"实用指令回滚相关最近又好好复习了下reset指令。一般这些回滚的操作最好不要用，尤其是在多人开发的时候，但是偶尔想用，还有点模糊了，这次在记录一下。 git reset步骤：readme中分别添加 test1tess2test3 每一句添加一个commit先看下log git log 暂存区有其他修改，但没有add。 此时，我改错了，想回退到test1的状态。用 git reset --hard 46670a 执行后，暂存区的内容也清空了，readme中，只有test1 了。查看git log前两个提交也不见了。 假如我后悔了，我又不想回退了，我还想在test3的情况下修改。 git reflog可以看到指令的log，从这里可以找回之前回退的相关commit这里会记录着还未被回收的commit号。此次，我把内容添加到暂存区了，也就是add过了，再次使用reset，回滚到原来的test3的状态 git reset --hard 9d91688 内容回到test3 处的commit，并且，之前add到暂存区的都没了 真想回滚，用reset就够了。 revert其实是取消某个提交的意思。revert 功能：revert是撤销某一次的提交，并不是回滚到这次提交时的状态！！！ revert 的历史保留在commit中 rebase用来合并多个commits场景，我们自己在本地改了好多乱七八糟的，但是并不想让所有的commit信息，比如fix之类的都提交，这个时候可以用rebase 配合 squash ，合并commit。 过程如下：先 git log： 我们想将0fad78ccc3到现在的commit都合并, 那么先rebase到那个不变动的commit git rebase -i 4c9bc3a7 如下： 需要留一个pick，其他都改成squash, 如下 esc :wq保存后，这样就把其他的提交都合并了。自动跳到如下界面(这里可以重写合并的commit内容了) 修改完毕，esc :wq 保存 最后，看下git log，干净了！！！！ 远端分支回滚如果远端对应的分支也想修改，必须要—force git push --force origin branch-name 刪除远端分支git push origin --delete target_branch","tags":[{"name":"git","slug":"git","permalink":"https://akijiangrou.github.io/tags/git/"}]},{"title":"前端页面-网络性能","date":"2017-05-25T02:48:54.000Z","path":"2017/05/25/网络优化/","text":"前端页面-网络性能一个网站从开始访问，发送请求，页面渲染，异步请求，到最终呈现，每个阶段都有各自不同的优化点。 前一段时间，自己项目的网站在加载和渲染的时候表现很奇怪，遂仔细用起chrome的network以及timeline面板，期待找到问题的根源。用的时候发现很多自己缺失的知识，于是就有这篇文章记录查缺补漏的内容。 这里先从网络性能角度来看，它将从初始阶段影响网站的性能。下面会以chrome中的network面板出发，从三点介绍网络性能相关内容，分别包括：主要网络属性，如何在chrome devtool中查看网络性能，如何优化 主要网络属性这里主要关注timing这个属性。某个请求的timing如下： 在network页面点击具体的请求url即可进入上述页面。 可以看到一条资源从列队、停滞、代理协议、初始化连接、SSL协议、发送request、等待及内容下载所耗的时间。 主要属性 Queueing时间：请求排队的时间，出现原因有：更高优先级的请求，或者在HTTP/1.0和HTTP/1.1中，已经有6个同源请求在进行中 Stalled阻塞时间：原因如上queueing DNS Lookup. 浏览器解析请求的ip地址需要的时间 Proxy negotiation. 与代理服务器通信需要的时间 Initial Connection / connecting: 建立连接的过程，包含TCP握手/重试，商定SSL SSL: 完成SSL握手阶段 Request sent：发送请求耗时，通常只要不到1ms的时间 ServiceWorker Preparation.浏览器启动服务worker的时间 Request to ServiceWorker.The request is being sent to the service worker. Waiting (TTFB). 收到首字节的时间。 Content Download. 浏览器接收响应数据的时间。 performance api上面这些资源数据是根据js的性能api计算的。window.performance.getEntries() 获取资源加载时间列表。每个performanceResourceTiming大概如下： connectEnd：浏览器与服务器完成建立用以检索资源的网络连接的时间戳 connectStart：浏览器与服务器开始建立用以检索资源的网络连接的时间戳 damainLookupEnd：浏览器完成资源的域名解析的时间戳 damainLookupStart：浏览器开始进行资源的域名解析的时间戳 duration：资源请求从开始到结束的时间差 entryType：PerformanceEntry对象的类型，该对象封装一个单一的性能指标作为性能表的一部分，此类型是frame, mark, measure, navigation, resource,server的其中一个。 fetchStart：浏览器开始获取资源的时间戳 initiatorType：资源文件的类型 name：资源的url redirectEnd：接收到重定向资源的最后一个响应字节的时间戳 redirectStart：启动重定向以获取资源的开始时间戳 requestStart：浏览器从服务器请求资源的开始时间戳 responseEnd：浏览器接收到资源最后一个字节的时间戳，或者关闭传输连接的时间戳 responseStart：浏览器接收到服务器的响应的第一个字节的时间戳 secureConnectionStart：浏览器开始握手协议，以保护当前连接的安全性，握手开始的时间 startTime：浏览器开始获取资源前的时间戳(整个过程的开始时间) workerStart：如果当前上下文是”worker”，返回开始获取资源的时间戳，否则返回0(应该是应用于双工通信的) 下面这张图定义了PerformanceResourceTiming 接口的各个时间属性： performance.timing() 获取页面整体的时间参数 这个api可以参考这个非正式的标准规范Resouce timing - w3c old one 该规范定义了一个用于Web应用程序的接口，这个接口可以访问文档需要的资源的完整时序信息。 接口的详细说明这里就不一一介绍了，细节了解需要自己去读标准。 下面只挑和我们相关的内容。 由上面这个图，我们可以获取到chrome网络面板中，timing的相关信息，举个例子： 页面整体的时间参数 （mta应该有用到以下参数） pageloadtime = t.loadEventStart - t.navigationStart, dns = t.domainLookupEnd - t.domainLookupStart, tcp = t.connectEnd - t.connectStart, ttfb = t.responseStart - t.navigationStart; 某个资源的时间参数 var r0 = performance.getEntriesByType(&quot;resource&quot;)[0], loadtime = r0.duration, dns = r0.domainLookupEnd - r0.domainLookupStart, tcp = r0.connectEnd - r0.connectStart, ttfb = r0.responseStart - r0.startTime; 参考还有一些其他的测量时间的问题，请参考performance的资源计时统计其他方法使用，参考初探performance-监控网页与程序性能 如何在chrome devtool中查看网络性能在chrome devtool中，我们可以模拟各种网络环境，可以过滤请求，查看http请求信息，了解dom加载时间，cookie信息，资源的上下游等等。 内容略多，参考这里，chrome developers 官网测量网络性能英文不好的可以看这个：Chrome DevTools 之 Network，网络加载分析利器 如何优化网站加载时间对用户的影响：0.1秒：秒开100-300 ：比较小的可察觉的延迟300-1s：Machine is working1秒：还能接受，但是已经不开心了10秒：什么破玩意，不想看了chrome developer里提到，目标是250ms 优化主要从四个属性入手，以下基本翻译自chrome devtool Queued or stalled requests这两个指标如果时间很长，说明很多资源等待造成的原因：访问同一个域名的请求太多，对于http1.1来说，每个host最多同时支持6个tcp连接。 解决： 域名分片：将资源放在不同的域名中，用来克服浏览器对同一个域名访问的限制，但是不能过多因为dns解析也需要时间 [备注]domain sharding (域名分片)（和cdn的不同域名分片是一种分布方式，是将资源分布在不同的域名中达到克服浏览器访问限制的目的；cdn则是在不同的服务器上托管世界各地的网站资源。） 使用http2.0让重要的请求先发起，不重要的remove或者推迟。 Slow Time To First Byte (TTFB)起因： client与server的连接慢；server响应太慢 解决： 连接慢， 使用cdn，或者换个服务商 如果server慢，优化数据库查询，用缓存，修改server配置等。 Slow content download原因：网络不好；内容过大 解决： 连接慢， 使用cdn，或者换个服务商； 优化请求使数据更少。 以上是关于网络层面的网站优化内容，与前端人员开发技术能力相关性不大，需要一些网络层面以及后台来支持。当我们发现网页加载过慢的时候，可以先从网络这边入手，把网络和连接的基础问题排查后，再从优化自己写的代码入手。","tags":[{"name":"timing","slug":"timing","permalink":"https://akijiangrou.github.io/tags/timing/"}]},{"title":"高德地图api使用总结","date":"2017-05-18T04:28:44.000Z","path":"2017/05/18/高德地图api使用总结/","text":"常用的高德地图api关于appkey，分为两种，一个是api调用的key，一个是地图服务的key，例如，获取门店信息，search功能等等。 脚本加载&lt;script type=&quot;text/javascript&quot; src=&quot;http://webapi.amap.com/maps?v=1.3&amp;key=您申请的key值&quot;&gt;&lt;/script&gt; 需要把这个脚本加载完成后，才能使用AMap。 可以使用map-div这个组件。 如果搭配react，需要在componentDidMount阶段，调用map-div 中的createMap函数。配套的，最好将该地图实例保存在一个对象中，并设置一个flag作为地图加载完成的标志位，以便react使用。 示例： mapInstance.js let __value = null; export default { getter: () =&gt; __value, setter: (val) =&gt; { __value = val; }, }; --------------------------------------- const mapConfig = { name: &apos;AMap&apos;, initOpts: { zoom: MAP_CONFIG.zoom, zooms: MAP_CONFIG.zooms, }, query: { plugin: &apos;AMap.Geocoder,AMap.CitySearch&apos;, }, }; componentDidMount() { (async () =&gt; { const mapIns = await createMap(mapConfig, &apos;mapComponent&apos;); mapInstance.setter(mapIns); this.props.setMapInstanceFlag(true); // 一些事件监听 mapEventHandler(mapIns, &apos;dragend&apos;, &apos;on&apos;, throttle(this.handleMapScale, 800)); mapEventHandler(mapIns, &apos;click&apos;, &apos;on&apos;, throttle(this.handleMapClick, 800)); ... })(); ... } 创建地图对象需要给出一个div作为地图的容器。 &lt;div id=&quot;container&quot; style=&quot;width:800px; height:500px&quot;&gt;&lt;/div&gt; var map = new AMap.Map(&apos;container&apos;,{ config }) 注意： 如果不加center，地图默认显示用户当前城市范围 config常用基本配置 options 说明 zoom 缩放级别 center 地图中心点坐标[lon, lat] zooms 地图可以缩放的范围 ，数组格式[max, min] zoomEnable 是否可缩放，默认为true dragEnable 是否可拖拽，默认为true mapStyle 地图显示样式，normal（默认样式）、dark（深色样式）、light（浅色样式）、fresh(osm清新风格样式)、blue_night features 地图上显示的元素种类， 默认都显示，支持’bg’（地图背景）、’point’（POI点）、’road’（道路）、’building’（建筑物） 常用的地图实例方法地图常用方法 方法 说明 getZoom()， setZoom() 缩放级别 getCenter(), setCenter() 获取地图中心点坐标[lon, lat] setZoomAndCenter 同时设定缩放级别和中心点坐标 setCity(city:String，callback:Functon) 通过设置城市名称来设置地图显示的中心点 zoomIn 地图放大一级 zoomOut 地图缩小一级 地图常用事件类型 click: 鼠标左键单击 mapmove: 地图平移时触发 movestart: 地图平移开始时触发 moveend: 地图移动结束后触发，包括平移和缩放(经试验，缩放并没有触发moveend)。 zoomchange: 地图缩放级别更改后触发 zoomstart: 缩放开始时触发 zoomend: 缩放停止时触发 dragstart: 开始拖拽地图时触发 dragend: 停止拖拽地图时触发 dragging: 拖拽地图过程中触发 如果地图操作后会有其他操作，一般监听 XXXend 方法。注意：setCity，setCenter等操作不会触发drag相关内容。 关于amap的事件绑定有两种方法： 针对Map、覆盖物等常用类直接使用on， off 方法来实现事件的简单绑定和移除 使用AMap.event命名空间addDomListener(domobj, eventName, handler, context(没用过，不清楚))addListener(obj, eventName, handler, context(没用过，不清楚))removeListener(listener): 可以移除dom和非dom事件。 参考 事件event中的内容 所有的CLICK事件点击位置的经纬度，对应在画布上的横纵坐标，事件target， 事件type 其他类型事件，如moveend，zoomevent中只有事件类型type 针对以上，我们可以对地图事件进行封装，一般需要的是事件发生的zoom，地图范围，点击位置的经纬度。🌰如下: const eventInjector = (ev, mapINS, cb) =&gt; { const bounds = mapINS.getBounds(); const param = { sw: bounds.getSouthWest(), ne: bounds.getNorthEast(), zoom: mapINS.getZoom(), type: ev.type, lng: ev.lnglat ? ev.lnglat.getLng() : &apos;&apos;, lat: ev.lnglat ? ev.lnglat.getLat() : &apos;&apos;, }; if (cb) cb(param); }; const mapEventHandler = (mapINS, type, opt, cb) =&gt; mapINS[opt](type, (ev) =&gt; eventInjector(ev, mapINS, cb)); //使用 mapEventHandler(mapIns, &apos;dragend&apos;, &apos;on&apos;, this.handleMapScale); mapEventHandler(mapIns, &apos;dragend&apos;, &apos;off&apos;,this.handleMapScale); //handleMapScale handleMapScale(ev) { console.log(ev); const { ne, sw, zoom, type } = ev; ... } 之后，如果在地图上发生dragend，event的结果如下： 常用地图基本类型LngLat ： 经纬度坐标，确定地图上的一个点构造函数： AMap.LngLat(lng: 119.78, lat: 39.99);生成一个经纬度为[119.78, 39.99]的地理坐标对象。常用方法： - getLng() 获取经度 - getLat() 获取纬度 - offset(w:2,s:-3) w经度，s纬度，参数为数字。将当前经纬度坐标值变化。经度是越向右越大，所以向右为正。同理，纬度越向上越大，所以向上为正。 - distance(lnglat: LngLat | [lng, lat]) 当前经纬度与传入的经纬度的连线的地面距离 - equals(lnglat:LngLat) Bounds：经纬度范围矩形框AMap.Bounds(southWest:LngLat1, northEast:LngLat2);生成一个东北角是LngLat2，西南角是LngLat1 的矩形地物框。常用方法： - contains(point: LngLat) 给出的经纬度点是否包含在矩形范围内 - getCenter() - getSouthWest() - getNorthEast() 常用覆盖物AMap.Marker 构造：AMap.Marker({ markeroptions }) 常用选项map:marker所在的地图position: LngLat类型，点在地图上的位置offset: 像素类型(-75，-75)，marker距离左上角的偏移content: string/object 这里可以自定义marker显示的内容，图片，svg等都可以。bubble: 将覆盖物的事件冒泡到地图上，默认falsezIndex: 叠加顺序title: 鼠标滑过时，点标记的文字提示。extData: 用户自定义属性draggable: 标记点是否可以拖拽移动 方法略多，这里就不写了，基本对应每个选项都会有个get，set方法。hide，show控制点标记的隐藏，还在map中。setMap比较有用，如果设为null，则在地图上移除当前Marker相关的div。还有一些移动类的应用，目前还没使用过，这里就不详述了，主要有：moveAlong, moveTo, stopMove, pauseMove, resumeMove。 事件与地图对象基本一致，少了个ready。多了一些move的行为，具体可参考 AMap.Polygon 构造：AMap.Polygon({ options }) 常用选项map:marker所在的地图path: 参数为，包含经纬度数组的数组. eg：[ [116.368904, 39.913423], [116.382122, 39.901176], [116.387271, 39.912501], [116.398258, 39.904600] ] bubble: 将覆盖物的事件冒泡到地图上，默认false。 zIndex: 叠加顺序, 默认比marker低。 类似svg的多边形属性: strokeColor，strokeOpacity， strokeWeight， fillColor， fillOpacity， strokeStyle， strokeDasharray。 extData: 自定义属性 方法。对应path，extData， options都会有个get，set方法。hide，show控制多边形的隐藏，多边形还在map中。setMap比较有用，如果设为null，则在地图上移除当前polygon相关的div。getBounds,矩形范围对象，返回Bounds类型。getArea,获取多边形面积。contains(point:LngLat)，点是否在polygon内。 事件很多，常用的又mouseover， click等。具体可参考 AMap.Circle 构造：AMap.Circle({ options }) 常用选项map:marker所在的地图center: LngLat类型，圆心在地图上的位置radius: 半径，number类型，单位是米bubble: 将覆盖物的事件冒泡到地图上，默认falsezIndex: 叠加顺序, 默认比marker低。extData: 用户自定义属性类似svg的多边形属性： 同上polygon 方法。对应center，extData， radius，options都会有个get，set方法。hide，show控制隐藏，还在map中。setMap同上。getBounds，圆外切矩形范围对象，返回Bounds类型。contains(point:LngLat)，点是否在圆内。 事件类型类似polygon 具体可参考 AMap.Polyline 构造：AMap.Marker({ markeroptions }) 常用选项，与polygon差不多。多一些线条相关的内容，具体可参考 方法和事件与polygon差不多 常用图层图层是位于最底层的模块，他可能在地图上的其他物件还没加载完就已经生成了。图层都需要地图以plugin的形式引进。 AMap.Heatmapheatmap是个plugin，需要添加plugin，在回调函数中生成AMap.Heatmap实例。 const heatmap; map.plugin([&quot;AMap.Heatmap&quot;], function() { heatmap = new AMap.Heatmap(map, { radius: 25, //给定半径 opacity: [0, 0.8] }); }); 上面的config，包含radius`gradientopacityzooms`(支持的缩放级别，不在范围内，就不显示热力图了)渐变可以按照如下设置 gradient: { 0.4: &apos;red&apos;, 0.8: &apos;yellow&apos;, 1: &apos;blue&apos;} 方法与覆盖物的差不多，除了， addDataPoint(lng: Lng, lat: Lat, count: number) setDataSet(data: obj, url:jsonp格式数据的服务地址，urlDataParser:可以传递函数进行数据转化) // 这两个可以配合zoom，不同的zoom，热力图对应的数据集不同。 其中，data格式为： { max: number, data: [ { lng: 116.7, lat: 39.9, count: 10 }, { lng: 116.7, lat: 39.9, count: 10 }], } AMap.CustomLayer同样需要plugin来引入。 给出的属性和方法很少，但是功能强大，需要自己开发，参考实例 一般是自己做一些canvas，然后挂载在map上即可。自定义图层有个render属性？使其等于绘制函数，就可以在地图上绘制出来。 搜索服务支持搜索服务脱离地图使用，即使用搜索服务不再需要先实例化地图。通过AMap.plugin方法，加载需要的服务 AMap.Autocomplete 常用选项：city:输入提示被限定的城市citylimit: 是否强制限制在设置的城市内搜索input:指定一个输入框，内容则作为input的id，在input输入文字后，会自动生成一个下拉选择列表。 search方法，可以结合他的search方法，获取数据，然后自己render样式~~ AutocompleteResult对象： { info： 状态说明, count: 输入提示条数, tips: [ { name: 名称, district: 所属区域, ,adcode: 区域编码}, { name: 名称, district: 所属区域, ,adcode: 区域编码}... ] } 通常autocomplete配合placeSearch进行使用的 AMap.PlaceSearch 常用选项：city:输入提示被限定的城市citylimit: 是否强制限制在设置的城市内搜索type:兴趣点类别，可以通过setType设置pageSize:单页显示结果条数extensions: ‘all’ 返回基本+详细信息panel&amp;renderStyle结果列表的html容器id，或者容器元素，结果列表将在给出的容器中进行展示，自己可以render样式。 可用方法见参考吧 上个search使用示例： html： &lt;img className={styles.searchIcon} src={searchIcon} alt=&quot;search&quot; onClick={() =&gt; this.handleSearch()} /&gt; js: handleSearch() { // this.state.placeSearch是个AMap.Autocomplete实例 this.state.placeSearch.search(this.refs.searchInput.value, this.handleSearchSelect); } handleSearchSelect(search, result) { if (result.info === &apos;OK&apos;) { // mapInstance是个封装了AMap的对象。 const mapIns = mapInstance.getter(); // 自定义搜索结果的marker样式。并绘制在地图上 this.generateSearchMarkers(result.poiList); if (result.poiList.pois.length &gt; 0) { const { lng, lat } = result.poiList.pois[0].location; // 将map的中心定位到获取到的第一个poi的位置上。 mapIns.setCenter([lng, lat]); mapIns.zoomIn(); } } } 如果查到结果searchResult有以下内容： 其他还有好多具体的搜索的服务。由于没有用到，就没看。。。 信息窗体AMap.InfoWindow用于在地图上弹出一个详细信息展示窗体，地图上只允许同时展示1个信息窗体 属性isCustom： 是否自定义窗体，true 则完全按照content中的规定来显示autoMove： 将窗体完全展现在视图中。closeWhenClickMap: 鼠标点击地图后是否关闭信息窗体position: 信息窗体显示位置，类型为经纬度对象 方法事件类似polygon，有一些属性的get，set方法，open，close方法。 定位AMap.CitySearch项目中用到这个api。它主要是根据ip返回对应的城市信息，根据输入ip或自动获取ip来获取城市信息。该api也是个plugin，可以在初始loader地图的时候，就将其配置进去，将脚本加载时的代码。 两个方法：getLocalCity((status, citySearchResult) =&gt; {…})getCityById(ip, (status, citySearchResult) =&gt; {}) 例子： // citysearch部分代码，省略地图实例了，用mapIns代替 citysearch.getLocalCity((status, result) =&gt; { if (status === &apos;complete&apos; &amp;&amp; result.info === &apos;OK&apos;) { if (result &amp;&amp; result.city &amp;&amp; result.bounds) { const city = R.slice(0, -1, result.city); const cindex = R.indexOf(city, R.pluck(&apos;cityName&apos;, cityList)); const ccode = R.pluck(&apos;cityCode&apos;, cityList); if (cindex !== -1 &amp;&amp; city !== &apos;北京&apos;) { mapIns.setCity(city); mapIns.setZoom(11); } } } }); citySearchResult 的属性：city， bounds 位置解析AMap.GeocoderGeocoder是进行地址描述与地理坐标间的相互转换。也就是，给出一个地址名称，转换为地理坐标的经纬度等信息。或者给出一个经纬度，确定这个点的地址名称信息。 相关方法： 获取地理编码：getLocation(address:String, (status:String,result:info/GeocodeResult) =&gt; {}) 逆地理编码：getAddress(location:LngLat|Array.,(status:String,result:info/ReGeocodeResult) =&gt; {})// 最多20个地址数组。 s用的比较多的是逆地理编码，比如自己做一个在地图上点击，然后找出该位置的相关信息。逆地理编码的返回结果属性：想展示什么，就从以下选择吧","tags":[{"name":"js","slug":"js","permalink":"https://akijiangrou.github.io/tags/js/"},{"name":"地图api","slug":"地图api","permalink":"https://akijiangrou.github.io/tags/地图api/"},{"name":"总结","slug":"总结","permalink":"https://akijiangrou.github.io/tags/总结/"}]},{"title":"css3实现3d效果","date":"2017-05-15T08:34:12.000Z","path":"2017/05/15/css3实现3d效果/","text":"css3实现3D效果相关属性 transform: rotateX(…) transfrom-origin: left center; transform-style: preserve-3d; perspective: 200px; perpective-origin: left center; backface-visibility: true; 3d效果基础知识一般是在旋转后才能表现出3d效果，css中规定的旋转规则如下： alt axis rotateX是以屏幕的水平方向为轴旋转，rotateY是以屏幕的垂直方向为轴，rotateZ是以与屏幕平面垂直的方向为轴。其实rotatex rotateY已经能实现3d效果了，但是不是很直观。搭配上perspective，perfect！ perspective含义：透视效果。指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。等同于绘画中的1点透视||平行透视。一个物体如果z-index为正，那么我们在画布中实际看到的就要偏大。如下第一个图。如果一个物体的z-index为负，那么显示在画布视图中，则偏小，如第二个图 alt perspective 两种写法:a：perspective：300px;b：transform: perspective(300px) rotateX(aa); 区别：第一个需要写在一个父级元素上，他规定了这个父级元素的透视点位置，换个角度说，当为元素规定perspective 属性时，其直接子元素会获得透视效果，而不是元素本身。第二个可以直接作用在当前元素上，也可以结合其他transform属性，规定了当前元素的透视点位置，对其他元素无影响。&nbsp;&nbsp;&nbsp;&nbsp;perspective 值越大，3d效果越不明显；越小越明显。想像成镜头到物体的距离，越近越能看出高低起伏，越远线条展示的越平缓。两种写法以及perspective对比，查看示例 -webkit-perspective-origin消失点的位置，语法：-webkit-perspective-origin: xpos yposxpos,ypos 可以选择关键字，left|right|center top|bottom|center 。如果是关键字，则是否对应xy无关紧要，浏览器会自己选择。如果是数值，百分比或者像素，则要按照x，y的顺序写。参考实例 backface-visibilitybackface-visibility 属性定义当元素不面向屏幕时是否可见。有些时候前面的div如果设置了透明度，就会看到后面的对象，这是可以将该属性设为hidden就可以了。默认：visible transform这里主要提和3d有关的几个属性 rotateX( angle ) rotateY( angle ) rotateZ( angle ) translateZ( tz ) scaleZ( sz ) translateZ，scaleZ会将对象在与屏幕平行的方向变化物体。会有失真。 也有综合的写法： translate3d( tx, ty, tz ) scale3d( sx, sy, sz ) rotate3d( rx, ry, rz, angle ) rotate3d这里，前三个规定旋转轴在空间中的方向，比如x轴，就是（1，0，0）rotate3d(1,0,0,90deg) === rotateX(90deg) transform-origin规定变化的中心点。一般都是对象的重心。可以修改成任意的值，以旋转为例: html &lt;div class=&quot;test1&quot;&gt;test&lt;/div&gt; &lt;div class=&quot;test2&quot;&gt;test2&lt;/div&gt; css div { width:200px; height: 200px; background: rgba(255, 0, 0,.5); margin: 20px auto; animation: mymove 3s infinite; } .test1{ transform: perspective(500px) rotateY(0deg); } .test2 { transform-origin: left; transform: perspective(500px) rotateY(0deg); } @keyframes mymove { from {transform: perspective(500px) rotateY(0deg);} to {transform:perspective(500px) rotateY(360deg);} } 表现是：test1将沿着div的宽度的一半为轴旋转。test2则沿着最左边的边框为轴旋转。参考实例 实例一：翻牌效果&lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;card&quot;&gt; &lt;div class=&quot;front&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;back&quot;&gt;2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; //css,设置一个container，他是个具有3d效果的box .container { width: 200px; height: 200px; position: relative; perspective: 800px; border: 1px solid #888; margin: 40px auto; } #card { width: 100%; height: 100%; position: absolute; transform-style: preserve-3d; animation: flip 2s infinite; transform-origin: left center; } #card figure { display: block; width: 100%; height: 100%; position: absolute; text-align: center; color: white; font-size: 40px; line-height: 200px; backface-visibility: hidden; } .front { background: tomato; } .back { background: lightblue; transform: rotateY( 180deg ); } @keyframes flip { 0% { transform: rotateY( 0deg ); } 50% { transform: rotateY( 180deg ) translateX(-100%); } 100% { transform: rotateY( 360deg ) } } container中的card div具有3d效果，如果想让card中的div等也有3d变化效果，可以通过对card设置： transform-style: preserve-3d; 将其父元素的3d透视集成下来，并使所有子元素保持在同一个3d空间中。背面那张牌需要翻到背面去，也就是rotateY( 180deg );参考示例 ###实例二：旋转的正方体参考示例六个div拼凑起来的。分别在xy方向上进行翻转，立到对应的方向。此时在添加一个translateZ才能显现出他们的效果。否则都是堆在zindex为0的位置，什么都看不见. 别的配置及思想同上面的翻牌 ###常见问题：1.设了transfrom-style:preserve-3d为什么还不好使。 这个时候需要查看父元素是否还设了，overflow，filter，clip，isolation，clip-path，mask-image，mask-box-image-source， mix-blend-mode，如果不是默认值的，会将transfrom-style:preserve-3d 失效。原因是前几个属性，会创造一个flatten的box，而preserve-3d是生成stacking context 的。","tags":[{"name":"css","slug":"css","permalink":"https://akijiangrou.github.io/tags/css/"},{"name":"perspective","slug":"perspective","permalink":"https://akijiangrou.github.io/tags/perspective/"},{"name":"3D效果","slug":"3D效果","permalink":"https://akijiangrou.github.io/tags/3D效果/"}]},{"title":"读书笔记-闭包","date":"2017-05-08T03:11:08.000Z","path":"2017/05/08/读书笔记-闭包/","text":"经典闭包闭包是一个函数（引用），即使他是在当前词法作用域之外执行，他也可以记住并访问所在的词法作用域。就是用这个引用来访问。参考 function foo () { const a = 9; const bar = () =&gt; {return a;} return bar; } const aa = foo(); console.log(aa()); 返回9； 解析在foo()执行后，其返回值赋值给变量aa，并执行aa()，其实是通过不同的标识符引用调用了内部函数bar()。bar在其词法作用域外被正常执行了。而且foo函数执行后，通常整个foo内部作用域都被销毁，但是由于bar的存在，是的内部作用域依然存在，组织了垃圾回收。bar() 拥有涵盖foo()内部作用域的闭包，使得该作用域能一直存活。bar()依然持有对该作用域的饮用，这个引用就叫做闭包。 如果将函数当作第一级的值类型进行传递，其实就会有闭包的存在。一些异步或者同步操作中，使用了回调函数，也是在使用闭包。 无处不在 本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax请求、跨窗口通信、Web Workers或者任何其他的异步(或者同步)任务中，只要使用了回调函数，实际上就是在使用闭包. 最常见的考题 for (var i = 1; i&lt;= 5; i++) { setTimeout(() =&gt;console.log(i), 1000*i); } 输出是：五个6 原因：i是全局变量，setTimeout是等待执行。延迟函数的回调会在循环结束时才执行,执行的时候i已经跳出循环，第一个满足的值就是6.所以输出5个6. 修改：将var 改为let。只在当时的循环中生效。可以每秒输出12345 另外一个应用：模块 从方便观察的角度看，一个从函数调用 所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。 实例： function CoolModule() { var something = &quot;cool&quot;; var another = [1, 2, 3]; function doSomething() { console.log( something ); } function doAnother() { console.log( another.join( &quot; ! &quot; ) ); } return { doSomething: doSomething, doAnother: doAnother }; } var foo = CoolModule(); foo.doSomething(); // cool foo.doAnother(); // 1 ! 2 ! 3 上一个示例代码中有一个叫作 CoolModule() 的独立的模块创建器，可以被调用任意多次， 每次调用都会创建一个新的模块实例。如果想实现单例模式：就是将coolmodule 转换为iife，并赋予一个标识符： var foo = (...)(); foo.doSomething(); foo.doAnother(); 结果同上 模块有两个主要特征:(1)为创建内部作用域而调用了一个包装函数;(2)包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。 词法作用域function foo() { console.log( a ); // 2 } function bar() { var a = 3; foo(); } var a = 2; bar(); 输出结果：2。词法作用域，运行bar，到foo的时候，这里的a是全局变量的a，所以为2.","tags":[{"name":"js","slug":"js","permalink":"https://akijiangrou.github.io/tags/js/"},{"name":"闭包","slug":"闭包","permalink":"https://akijiangrou.github.io/tags/闭包/"}]},{"title":"linux 目录结构","date":"2017-05-08T02:46:56.000Z","path":"2017/05/08/linux文件目录/","text":"原来学linux的时候，不上心，现在后悔莫及，开始补基础。首先是最基本的目录结构。linux是树状结构 标橘色为重要目录 目录 描述 ／ 根目录，整个文件系统层次结构的根目录，一般只放目录 /bin/ 类似 /usr/bin 可执行的二进制文件的目录，常用的ls，tar，mv， cat等 /boot/ 引导程序文件，放置linux系统启动时用到的一些文件 /dev/ 存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备 /etc/ 系统配置文件存放的目录,不建议在此目录下存放可执行文件，重要的配置文件 /home/ 系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下, 建议单独分区，并设置较大的磁盘空间 /lib/,/usr/lib/, /usr/local/lib/ 系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为/lib/modules /lost+fount/ 系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。 /mnt/ 临时挂载的文件系统。比如cdrom,u盘等，直接插入光驱无法使用，要先挂载后使用 /opt/ 给主机额外安装软件所摆放的目录, 可选应用软件包。 /proc/ 此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间.比较重要的目录有/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*等 /root/ 超级权限用户的家目录 /sbin:/usr/sbin:/usr/local/sbin 放置系统管理员使用的可执行命令，如fdisk、shutdown、mount等。sbin目录下的命令，普通用户都执行不了。 /tmp/ 一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下,在系统重启时目录中文件不会被保留。 /srv/ 服务启动之后需要访问的数据目录，如www服务需要访问的网页数据存放在/srv/www内 /usr/ 默认软件都会存于该目录下。用于存储只读用户数据的第二层次；包含绝大多数的(多)用户工具和应用程序。 /var/ 变量文件——在正常运行的系统中其内容不断变化的文件，如随时更改的日志文件 /var/log，/var/log/message： 所有的登录文件存放目录，/var/spool/mail： 邮件存放的目录， /var/run: 程序或服务启动 /etc/目录未完待续。。。参考参考二","tags":[{"name":"linux","slug":"linux","permalink":"https://akijiangrou.github.io/tags/linux/"}]},{"title":"export相关","date":"2017-04-18T03:01:45.000Z","path":"2017/04/18/exports/","text":"exports 和 module.exports 的区别exports 是引用 module.exports 的值。module.exports 被改变的时候，exports不会被改变，而模块导出的时候，真正导出的执行是module.exports，而不是exports。 有以几点需要记住： module.exports 初始值为一个空对象 {}exports 是指向的 module.exports 的引用require() 返回的是 module.exports 而不是 exports如果module.exports 当前没有任何属性的话，exports会把属性收集起来赋给module.exports。如果module.exports 有属性的话, exports中的所有内容都会被忽略。 foo.js exports.a = function(){ console.log(&apos;a&apos;) } module.exports = {a: 2} exports.a = 1 test.js var x = require(&apos;./foo&apos;); console.log(x.a); 输出 ：2 如果：foo.js 为： exports.a = function(){ console.log(&apos;a&apos;) } exports.a = 1 test.js 输出：1 如果：foo.js为： exports.a = function(){ console.log(&apos;a&apos;) } test.js 输出：[Function] 首先，node中的require 引进的是module.exports。。。见第一个实例。如果没有显式的写module.exports，则自动连接exports与module.exports。如果显示的写了module.exports，则会断开module.exports 与 exports 的联系。 应用的话，如果只是导出某个变量或者某个功能，用exports.属性|方法。如果是导出多个属性或方法或使用对象构造方法，module.module 比较好。 export default 和 export 区别1.export与export default均可用于导出常量、函数、文件、模块等2.你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用3.在一个文件或模块中，export、import可以有多个，export default仅有一个4.通过export方式导出，在导入时要加{ }，export default则不需要 引入时：加了default的变量，可以起任意名字，非default的需要与export时的名字相同。 module.exports vs exportcommonjs：module.exports 搭配的引入： requirees6: export 搭配的引入： import 普通js环境下是不支持es6的语法的，如果想这么用，需要用babel等进行转译。 es6 default export 其实是与exports 等价的，只不过 default 只是一个保留的名称，可以想象为，exports 一个属性，属性名为default。所以如果是在node.js环境下，用的export default， 引用的时候用require的话，需要这么写： var bar = require(‘./input’).default; export vs export default这两个在import的时候，前者需要用{} 扩起来，有种解构的感觉。后者不需要{}扩。","tags":[{"name":"node.js","slug":"node-js","permalink":"https://akijiangrou.github.io/tags/node-js/"},{"name":"js","slug":"js","permalink":"https://akijiangrou.github.io/tags/js/"}]},{"title":"Visual-Formatting-Model","date":"2017-04-17T04:00:00.000Z","path":"2017/04/17/Visual-Formatting-Model/","text":"1.视觉格式化模型 introduction视觉格式化模型：User Agent 如何在 Visual Media下处理文档树。 视觉格式化模型中，文档树中的每一个元素根据盒模型 Box Model 产生零个或多个盒。这些盒的布局由以下内容控制： 盒的尺寸和类型 定位体系 Positioning Scheme （常规流，浮动和绝对定位） 文档树中元素之间的关系 外部信息（如：视口大小，图片的固有尺寸等） 1.1 视口 viewport连续媒体 Continuous Media 上工作的user agent一般会向用户提供一个viewport（屏幕上的一个窗口或其它可视区域）来帮助用户访问文档。user agent可以在调整视口大小的同时改变文档的布局 1.2 包含块 containing blocksCSS2.1中，许多盒的定位和大小都根据一个名为包含块 Containing Block 的矩形盒的边缘来计算。生成的盒会充当其后代盒的包含块；我们称盒为其后代“创建”了包含块。说“盒的包含块”即是说“盒所处的包含块”，而不是盒所产生的包含块。 2 盒的生成 Controlling Box Generationdisplay指定盒的类型 有几个概念： block-level box: display：block|table|list-item block box: 除了table块盒和可替换元素，其他的都是块容器盒。也是块盒。 block container box: 一个块容器盒要么只包含块级盒，要么创建一个行内格式化上下文 Inline Formatting Context 并只包含行内级盒 Inline-level Boxes。不一定是block的才是，行内也是。所以和块级盒只是一部分有交集。 3 定位体系 Position schemes在css2.1中，一个box有三种机制来布局 normal flow：块级formatting, 行级formatting，相对定位 float：box先按照normal flow放置，然后从流中脱离出来，可能会对后面的排序有影响 absolute position：完全脱离出文档流，对之后的元素没有影响 [脱离文档流] float， absolutely positioned， 根元素。 3.1 position 属性属性： static：top right等并不生效 relative：盒的定位根据常规流计算（盒被成为常规流内定位）。盒相对其常规位置移动。当B盒相对定位，B盒之后的盒定位时就当B没有移动一样来计算。table相关的内盒并没有relative属性 absolute：位置大小通过top，right等定义。脱离文档流了，即便绝对定位盒有外边距，也不同其他任何外边距折叠。 fixed：盒的定位根据 absolute 模型来计算，但除此之外，盒相对某些参照物保持固定。【用户代理不可将固定盒的内容分页显示。注意用户代理可能用其他方法打印不可见内容。参见第13章“页盒外的内容”】 4 常规流 Normal Flow常规流中的盒子都属于某个格式化上下文，要么块格式化上下文BFC，要么行内格式化上下文LFC，总之不能二者得兼。 ###4.1 bfc 浮动 绝对定位元素、 非块盒的块容器（如：行内块 inline-block 、表格单元格 table-cell 以及表格标题 table-caption ） 以及 overflow 属性不为 visible 的块盒（除了该值被传播到视口的情况） 将为其内容创建一个新的块级格式化上下文。 在块格式化上下文中: 盒从包含块顶部一个接一个地垂直摆放。 两个同胞盒间的垂直距离取决于 margin 属性。 同一个块格式化上下文中的相邻块级盒的垂直外边距将折叠。 每个盒的左外边缘紧贴包含块的左边缘。 ###4.2 lfc 盒从包含块顶部一个接一个的水平摆放。盒的垂直对齐方式则不一：可能按底部或者顶部对齐，又或者按它们内容文本的基线对齐。 行盒的宽度取决于包含块以及浮动。 行盒的高总是足以容纳其包含的所有盒，当一个盒（ B ）的高度小于包含它的行盒的高度时， B 的垂直对齐方式由 vertical-align 属性决定。 当一行不能包含所有时，它们会被分配到两个或者多个垂直摆放的行盒中，变成垂直堆叠。行盒的堆叠没有垂直间距（除非有特别声明）并且从不重叠。 一般行内盒超过行盒宽度是，行内盒会被分在多个行盒中。 如果一个行内盒不可切割（比如，行内盒包含的是单个字符或者语言指定的断字规则不允许断字，又或者行内盒的 white-space 属性值为 nowrap 或 pre ），那么该【行内盒将溢出行盒】。 ###4.3 相对定位对于相对定位而言，left 和right使其发生水平位移。而且满足：left = - right。所以如果两个都定义了，则必有一个被忽略。top bottom同理，top胜。 5 浮动 floats浮动盒将被移动至左侧或右侧直至其外侧紧贴包含盒的边缘或另外一个浮动的外边缘。如果存在行盒，浮动盒的顶部外边缘将与行盒的顶部对齐。 float内元素的margin不会与包含他的发生垂直边距折叠。 clear 清除浮动 https://segmentfault.com/a/1190000003096320#articleHeader5 [link]https://www.w3.org/TR/CSS2/visuren.html#block-formatting","tags":[{"name":"css","slug":"css","permalink":"https://akijiangrou.github.io/tags/css/"}]},{"title":"thinking-with-join","date":"2017-03-09T14:16:48.000Z","path":"2017/03/09/thinking-with-join/","text":"下面这段代码是我们最常用的，为每个数据生成一个circle，调用数据里的x，y来定位。但是我们selectAll的元素，此时并不存在，那d3是如何工作的呢? svg.selectAll(“circle”) .data(data) .enter().append(“circle”) .attr(“cx”, function(d) { return d.x; }) .attr(“cy”, function(d) { return d.y; }) .attr(“r”, 2.5); 在d3中，告诉d3你想要什么，而不是告诉d3怎样做什么。对于上面这个需求，我们要做的就是，我想要circle对应于数据，每个circle对应于一个数据，而不是告诉d3，你应该给我创造一个circle，然后告诉d3选择的circle应该和数据对应好。这个原则就叫做data join Data Enter Update &lt;circle r=”110” style=”fill: rgba(230, 85, 13,.2);”stroke=”black”&gt; Elements Exit 连接到现有元素的数据点生成update（内部）选择。剩余未绑定数据生成enter选择（左），表示缺少的元素。同样，任何剩余的未绑定元素会生成exit选择（右），表示要删除的元素。 现在，我们可以通过data join 来揭开enter-append序列的谜团了 svg.selectAll(&quot;circle&quot;) 返回一个新的空selection，因为SVG容器是空的，所以该selection的父节点是SVG容器 然后此selection连接到数据数组，生成三个新selection分别表示三种可能的状态：enter，update和exit。由于selection为空，所以update和exit选择为空，而enter selection包含每个新数据的占位符。 update selection通过selection.data返回,而enter和exit selection挂起update selection; selection.enter返回enter selection。 通过在enter selection上调用selection.append，将缺少的元素添加到SVG容器。这会为每个数据点向SVG容器添加一个新圆。 Thinking with joins 意味着在一个selection和数据集中声明一种关系，然后通过enter, update, exit实现这个关系. 但是为什么会这么麻烦呢？为什么不一开始就创建多个元素呢？data join的美丽在于它的泛化。虽然上述代码只处理enter selection,这就可以处理静态可视化了，但是你可以将其扩展为支持动态可视化，只需对update和exit进行少量修改。这意味着您可以对实时数据进行可视化，允许交互式探索，以及在数据集之间平滑过渡！ 看下包含三个状态的例子： var circle = svg.selectAll(“circle”) .data(data);circle.exit().remove();circle.enter().append(“circle”) .attr(“r”, 2.5) .merge(circle) .attr(“cx”, function(d) { return d.x; }) .attr(“cy”, function(d) { return d.y; }); 无论何时运行此代码，它都会重新计算数据连接并保持元素和数据之间的所需对应关系。如果新数据集小于旧数据集，则剩余元素将在退出选择中结束并被删除。如果新数据集较大，剩余数据将在输入选择中结束，并添加新节点。如果新数据集的大小完全相同，那么所有元素都将使用新位置进行更新，并且不会添加或删除任何元素。 thinking with join用连接来思考意味着你的代码更具声明性：你处理这三个状态没有任何分支（if）或迭代（for）。而是描述元素应如何对应数据。如果给定的enter，update或exit selection恰好是空的，则相应的代码是无操作 连接还允许将操作定向到特定状态（如果需要）。例如，你可以在enter而不是update上设置常量属性（例如由“r”属性定义的圆的半径）。通过重新选择元素和最小化DOM更改，您大大提高了渲染性能！同样，您可以将动画过渡指定为特定状态。例如，在entering状态，加入动画圆圈展开 大致翻译自：thinking with join","tags":[{"name":"d3","slug":"d3","permalink":"https://akijiangrou.github.io/tags/d3/"},{"name":"translate","slug":"translate","permalink":"https://akijiangrou.github.io/tags/translate/"}]},{"title":"博客搭建","date":"2016-10-27T04:00:00.000Z","path":"2016/10/27/blog-publish/","text":"适用于macOS 1.需要安装git，npm，node升级本地npm npm install npm@latest -g 如果有权限问题，前面加上sudo就可以了 2.安装hexosudo npm install -g hexo 全局安装了 3.hexo管理一个网站hexo init blog 名字随自己喜欢，这里起的事blog 4.进入该文件，进行管理cd blog hexo server //启动你的本地网站，访问localhost:4000，就可以看到雏形了 hexo new &quot;hello world&quot; //生成一个hello world.md文件，新新文章，添加到网站中 5.部署到github上git上建立仓库先在自己的库里创建一个新的repo,作为网站的远端库，一般命名为自己的账号名，例如： 我的账号missSweety，新建的repo为Akijiangrou.github.io 修改hexo配置文件回到hexo中，为了部署到github上，我们需要修改_config.yml文件如下： deploy: type: git repository: https://github.com/MissSweety/Akijiangrou.github.io.git branch: master 安装hexo deployer gitnpm install hexo-deployer-git --save 如果不安装这个，deploy的时候会报错的 hexo deployhexo deploy 如果没配过ssh，还是会报错的解决方法： ssh-keygen -t rsa -b 4096 -C ‘email’ 按照提示，输入账号，密码，就会生成文件了回到github网站，在setting中把公钥放进去 ssh -T git@github.com 用该指令可以查看是否已经鉴权了 如果以上都好了，这次在用hexo deploy,就会自动push代码，并发布了，可以查看你的网站了 大功告成!!!","tags":[{"name":"hexo","slug":"hexo","permalink":"https://akijiangrou.github.io/tags/hexo/"}]}]