[{"title":"d3-basic-line","date":"2017-06-29T04:19:49.000Z","path":"2017/06/29/d3-basic-line/","text":"d3-折线图从一个最基本的折线图开始，看看d3是怎么实现的，以及用到哪些知识 需要的知识 scale extent transition line curve axis 步骤 获取svg容器 &lt;svg width=&quot;500&quot; height=&quot;270&quot; class=&quot;testline&quot;&gt;&lt;/svg&gt; const svg = d3.select(&apos;.testline&apos;); const margin = {top: 20, right: 20, bottom: 20, left: 20}; const width = +svg.attr(&quot;width&quot;) - margin.left - margin.right; const height = +svg.attr(&quot;height&quot;) - margin.top - margin.bottom; const g = svg.append(&quot;g&quot;).attr(&quot;transform&quot;, `translate(${margin.left},${margin.top})`); x，y轴缩放这里，如果x轴是与时间有关的，可以直接使用d3提供的scaleTime()来实现时间的转换。关于scale还有好多内容，待总结。这里需要确定两个轴，缩放的类型，以及xy轴图像在屏幕中的实际宽高值。这里的x, y 其实是函数（根据给出的数据，得出该数据的x，y坐标值）。 const x = d3.scaleTime().range([0, width]); const y = d3.scaleLinear().range([height, 0]); lineline的生成就需要上面的轴缩放函数。 这里是因为date函数可以接受ms的unix时间戳，所以乘以1000.这里也可以加一些点与点之间的连接方式。 curveMonotoneX平滑, curveLinear线性。需要两步，line函数生成。line呈现。关于line的展示，需要把数据绑定到path标签上，将line函数运用到path的d属性上。就可以绘制出线了，transition这里是为了实现简单的动画效果。注意，line展示的时候，data([data]) 也可应用datum(data)，前者删了数组标记是不可以的。不知道为什么 const line = d3.line() .x((d, i) =&gt; x(d.ts * 1000)) .y(d =&gt; y(d.y)) .curve(d3.curveMonotoneX); // line 的展示。 g.append(&apos;path&apos;) .data([data]).attr(&apos;fill&apos;, &apos;none&apos;).attr(&apos;d&apos;, line).attr(&apos;stroke&apos;, &apos;#f33155&apos;) .transition(500) .attr(&apos;stroke-width&apos;, 3); x坐标轴，y坐标轴domain是将坐标轴对应的真实数据连接起来，一般就是将坐标轴要展示的数据的最大最小值放进来。d3.extent可以自动的算出数组内的最小，最大值，很方便。如下x轴的计算。v4支持axisBottom，axisTop，axisRight，axisLeft等快捷操作，就是说明坐标轴的展现方式。规定好domain后，可以将轴展示在图像中了。给出selector然后调用call(如果是x轴，记得把上面x轴函数传进来，y轴同理)，同时，这里可以规定轴线样式和刻度的相关内容。下面的例子是规定了，最大最小值中间还可以有多少个刻度。 x.domain(d3.extent(data, d =&gt; d.ts * 1000)); y.domain([0, d3.max(data, d =&gt; d.y * 1.1 )]); // Add the X Axis g.append(&quot;g&quot;).attr(&quot;transform&quot;, `translate(0,${height})`) .call(d3.axisBottom(x).ticks(5)); // Add the Y Axis g.append(&quot;g&quot;).attr(&quot;transform&quot;, `translate(0,0)`) .call(d3.axisLeft(y).ticks(8)); 线上打点线上打点，主要是通过line函数，获取点的center位置。需要将data绑定到circle标签上，最后根据line函数绘制出来。 g.selectAll(&quot;.dot&quot;) .data(data).enter().append(&quot;circle&quot;).attr(&apos;class&apos;, &apos;.dot&apos;) .attr(&quot;cx&quot;, line.x()).attr(&quot;cy&quot;, line.y()) .transition(500) .attr(&quot;r&quot;, 3.5).attr(&apos;fill&apos;, &apos;white&apos;).attr(&apos;stroke&apos;, &apos;#f33155&apos;); 数据label类似的，label也是根据line函数获取位置，然后将要现实的值，用text属性显示出来。 g.selectAll(&quot;.text&quot;) .data(this.data).enter().append(&quot;text&quot;) .attr(&apos;class&apos;, &apos;.text&apos;).attr(&apos;font-size&apos;, 12) .attr(&quot;x&quot;, line.x()).attr(&quot;y&quot;, line.y()) .attr(&apos;dx&apos;, -15).attr(&apos;dy&apos;, 7) .text(function(d) { return d.y}) .transition(500) .attr(&apos;fill&apos;, &apos;#333&apos;).attr(&apos;stroke&apos;, &apos;#333&apos;); 当绑定了data数据后，x函数，y函数，会自动按顺序获取数据。 最后结果：参考","tags":[{"name":"d3","slug":"d3","permalink":"https://misssweety.github.io/tags/d3/"},{"name":"line","slug":"line","permalink":"https://misssweety.github.io/tags/line/"},{"name":"可视化","slug":"可视化","permalink":"https://misssweety.github.io/tags/可视化/"}]},{"title":"git实用指令","date":"2017-06-02T02:51:14.000Z","path":"2017/06/02/git实用指令/","text":"实用指令回滚相关最近又好好复习了下reset指令。一般这些回滚的操作最好不要用，尤其是在多人开发的时候，但是偶尔想用，还有点模糊了，这次在记录一下。 git reset步骤：readme中分别添加 test1tess2test3 每一句添加一个commit先看下log git log 暂存区有其他修改，但没有add。 此时，我改错了，想回退到test1的状态。用 git reset --hard 46670a 执行后，暂存区的内容也清空了，readme中，只有test1 了。查看git log前两个提交也不见了。 假如我后悔了，我又不想回退了，我还想在test3的情况下修改。 git reflog可以看到指令的log，从这里可以找回之前回退的相关commit这里会记录着还未被回收的commit号。此次，我把内容添加到暂存区了，也就是add过了，再次使用reset，回滚到原来的test3的状态 git reset --hard 9d91688 内容回到test3 处的commit，并且，之前add到暂存区的都没了 真想回滚，用reset就够了。 revert其实是取消某个提交的意思。revert 功能：revert是撤销某一次的提交，并不是回滚到这次提交时的状态！！！ revert 的历史保留在commit中 rebase用来合并多个commits场景，我们自己在本地改了好多乱七八糟的，但是并不想让所有的commit信息，比如fix之类的都提交，这个时候可以用rebase 配合 squash ，合并commit。 过程如下：先 git log： 我们想将0fad78ccc3到现在的commit都合并, 那么先rebase到那个不变动的commit git rebase -i 4c9bc3a7 如下： 需要留一个pick，其他都改成squash, 如下 esc :wq保存后，这样就把其他的提交都合并了。自动跳到如下界面(这里可以重写合并的commit内容了) 修改完毕，esc :wq 保存 最后，看下git log，干净了！！！！ 远端分支回滚如果远端对应的分支也想修改，必须要—force git push --force origin branch-name 刪除远端分支git push origin --delete target_branch","tags":[{"name":"git","slug":"git","permalink":"https://misssweety.github.io/tags/git/"}]},{"title":"前端页面-网络性能","date":"2017-05-25T02:48:54.000Z","path":"2017/05/25/网络优化/","text":"前端页面-网络性能一个网站从开始访问，发送请求，页面渲染，异步请求，到最终呈现，每个阶段都有各自不同的优化点。 前一段时间，自己项目的网站在加载和渲染的时候表现很奇怪，遂仔细用起chrome的network以及timeline面板，期待找到问题的根源。用的时候发现很多自己缺失的知识，于是就有这篇文章记录查缺补漏的内容。 这里先从网络性能角度来看，它将从初始阶段影响网站的性能。下面会以chrome中的network面板出发，从三点介绍网络性能相关内容，分别包括：主要网络属性，如何在chrome devtool中查看网络性能，如何优化 主要网络属性这里主要关注timing这个属性。某个请求的timing如下： 在network页面点击具体的请求url即可进入上述页面。 可以看到一条资源从列队、停滞、代理协议、初始化连接、SSL协议、发送request、等待及内容下载所耗的时间。 主要属性 Queueing时间：请求排队的时间，出现原因有：更高优先级的请求，或者在HTTP/1.0和HTTP/1.1中，已经有6个同源请求在进行中 Stalled阻塞时间：原因如上queueing DNS Lookup. 浏览器解析请求的ip地址需要的时间 Proxy negotiation. 与代理服务器通信需要的时间 Initial Connection / connecting: 建立连接的过程，包含TCP握手/重试，商定SSL SSL: 完成SSL握手阶段 Request sent：发送请求耗时，通常只要不到1ms的时间 ServiceWorker Preparation.浏览器启动服务worker的时间 Request to ServiceWorker.The request is being sent to the service worker. Waiting (TTFB). 收到首字节的时间。 Content Download. 浏览器接收响应数据的时间。 performance api上面这些资源数据是根据js的性能api计算的。window.performance.getEntries() 获取资源加载时间列表。每个performanceResourceTiming大概如下： connectEnd：浏览器与服务器完成建立用以检索资源的网络连接的时间戳 connectStart：浏览器与服务器开始建立用以检索资源的网络连接的时间戳 damainLookupEnd：浏览器完成资源的域名解析的时间戳 damainLookupStart：浏览器开始进行资源的域名解析的时间戳 duration：资源请求从开始到结束的时间差 entryType：PerformanceEntry对象的类型，该对象封装一个单一的性能指标作为性能表的一部分，此类型是frame, mark, measure, navigation, resource,server的其中一个。 fetchStart：浏览器开始获取资源的时间戳 initiatorType：资源文件的类型 name：资源的url redirectEnd：接收到重定向资源的最后一个响应字节的时间戳 redirectStart：启动重定向以获取资源的开始时间戳 requestStart：浏览器从服务器请求资源的开始时间戳 responseEnd：浏览器接收到资源最后一个字节的时间戳，或者关闭传输连接的时间戳 responseStart：浏览器接收到服务器的响应的第一个字节的时间戳 secureConnectionStart：浏览器开始握手协议，以保护当前连接的安全性，握手开始的时间 startTime：浏览器开始获取资源前的时间戳(整个过程的开始时间) workerStart：如果当前上下文是”worker”，返回开始获取资源的时间戳，否则返回0(应该是应用于双工通信的) 下面这张图定义了PerformanceResourceTiming 接口的各个时间属性： performance.timing() 获取页面整体的时间参数 这个api可以参考这个非正式的标准规范Resouce timing - w3c old one 该规范定义了一个用于Web应用程序的接口，这个接口可以访问文档需要的资源的完整时序信息。 接口的详细说明这里就不一一介绍了，细节了解需要自己去读标准。 下面只挑和我们相关的内容。 由上面这个图，我们可以获取到chrome网络面板中，timing的相关信息，举个例子： 页面整体的时间参数 （mta应该有用到以下参数） pageloadtime = t.loadEventStart - t.navigationStart, dns = t.domainLookupEnd - t.domainLookupStart, tcp = t.connectEnd - t.connectStart, ttfb = t.responseStart - t.navigationStart; 某个资源的时间参数 var r0 = performance.getEntriesByType(&quot;resource&quot;)[0], loadtime = r0.duration, dns = r0.domainLookupEnd - r0.domainLookupStart, tcp = r0.connectEnd - r0.connectStart, ttfb = r0.responseStart - r0.startTime; 参考还有一些其他的测量时间的问题，请参考performance的资源计时统计其他方法使用，参考初探performance-监控网页与程序性能 如何在chrome devtool中查看网络性能在chrome devtool中，我们可以模拟各种网络环境，可以过滤请求，查看http请求信息，了解dom加载时间，cookie信息，资源的上下游等等。 内容略多，参考这里，chrome developers 官网测量网络性能英文不好的可以看这个：Chrome DevTools 之 Network，网络加载分析利器 如何优化网站加载时间对用户的影响：0.1秒：秒开100-300 ：比较小的可察觉的延迟300-1s：Machine is working1秒：还能接受，但是已经不开心了10秒：什么破玩意，不想看了chrome developer里提到，目标是250ms 优化主要从四个属性入手，以下基本翻译自chrome devtool Queued or stalled requests这两个指标如果时间很长，说明很多资源等待造成的原因：访问同一个域名的请求太多，对于http1.1来说，每个host最多同时支持6个tcp连接。 解决： 域名分片：将资源放在不同的域名中，用来克服浏览器对同一个域名访问的限制，但是不能过多因为dns解析也需要时间 [备注]domain sharding (域名分片)（和cdn的不同域名分片是一种分布方式，是将资源分布在不同的域名中达到克服浏览器访问限制的目的；cdn则是在不同的服务器上托管世界各地的网站资源。） 使用http2.0让重要的请求先发起，不重要的remove或者推迟。 Slow Time To First Byte (TTFB)起因： client与server的连接慢；server响应太慢 解决： 连接慢， 使用cdn，或者换个服务商 如果server慢，优化数据库查询，用缓存，修改server配置等。 Slow content download原因：网络不好；内容过大 解决： 连接慢， 使用cdn，或者换个服务商； 优化请求使数据更少。 以上是关于网络层面的网站优化内容，与前端人员开发技术能力相关性不大，需要一些网络层面以及后台来支持。当我们发现网页加载过慢的时候，可以先从网络这边入手，把网络和连接的基础问题排查后，再从优化自己写的代码入手。","tags":[{"name":"timing","slug":"timing","permalink":"https://misssweety.github.io/tags/timing/"}]},{"title":"高德地图api使用总结","date":"2017-05-18T04:28:44.000Z","path":"2017/05/18/高德地图api使用总结/","text":"常用的高德地图api关于appkey，分为两种，一个是api调用的key，一个是地图服务的key，例如，获取门店信息，search功能等等。 脚本加载&lt;script type=&quot;text/javascript&quot; src=&quot;http://webapi.amap.com/maps?v=1.3&amp;key=您申请的key值&quot;&gt;&lt;/script&gt; 需要把这个脚本加载完成后，才能使用AMap。 可以使用map-div这个组件。 如果搭配react，需要在componentDidMount阶段，调用map-div 中的createMap函数。配套的，最好将该地图实例保存在一个对象中，并设置一个flag作为地图加载完成的标志位，以便react使用。 示例： mapInstance.js let __value = null; export default { getter: () =&gt; __value, setter: (val) =&gt; { __value = val; }, }; --------------------------------------- const mapConfig = { name: &apos;AMap&apos;, initOpts: { zoom: MAP_CONFIG.zoom, zooms: MAP_CONFIG.zooms, }, query: { plugin: &apos;AMap.Geocoder,AMap.CitySearch&apos;, }, }; componentDidMount() { (async () =&gt; { const mapIns = await createMap(mapConfig, &apos;mapComponent&apos;); mapInstance.setter(mapIns); this.props.setMapInstanceFlag(true); // 一些事件监听 mapEventHandler(mapIns, &apos;dragend&apos;, &apos;on&apos;, throttle(this.handleMapScale, 800)); mapEventHandler(mapIns, &apos;click&apos;, &apos;on&apos;, throttle(this.handleMapClick, 800)); ... })(); ... } 创建地图对象需要给出一个div作为地图的容器。 &lt;div id=&quot;container&quot; style=&quot;width:800px; height:500px&quot;&gt;&lt;/div&gt; var map = new AMap.Map(&apos;container&apos;,{ config }) 注意： 如果不加center，地图默认显示用户当前城市范围 config常用基本配置 options 说明 zoom 缩放级别 center 地图中心点坐标[lon, lat] zooms 地图可以缩放的范围 ，数组格式[max, min] zoomEnable 是否可缩放，默认为true dragEnable 是否可拖拽，默认为true mapStyle 地图显示样式，normal（默认样式）、dark（深色样式）、light（浅色样式）、fresh(osm清新风格样式)、blue_night features 地图上显示的元素种类， 默认都显示，支持’bg’（地图背景）、’point’（POI点）、’road’（道路）、’building’（建筑物） 常用的地图实例方法地图常用方法 方法 说明 getZoom()， setZoom() 缩放级别 getCenter(), setCenter() 获取地图中心点坐标[lon, lat] setZoomAndCenter 同时设定缩放级别和中心点坐标 setCity(city:String，callback:Functon) 通过设置城市名称来设置地图显示的中心点 zoomIn 地图放大一级 zoomOut 地图缩小一级 地图常用事件类型 click: 鼠标左键单击 mapmove: 地图平移时触发 movestart: 地图平移开始时触发 moveend: 地图移动结束后触发，包括平移和缩放(经试验，缩放并没有触发moveend)。 zoomchange: 地图缩放级别更改后触发 zoomstart: 缩放开始时触发 zoomend: 缩放停止时触发 dragstart: 开始拖拽地图时触发 dragend: 停止拖拽地图时触发 dragging: 拖拽地图过程中触发 如果地图操作后会有其他操作，一般监听 XXXend 方法。注意：setCity，setCenter等操作不会触发drag相关内容。 关于amap的事件绑定有两种方法： 针对Map、覆盖物等常用类直接使用on， off 方法来实现事件的简单绑定和移除 使用AMap.event命名空间addDomListener(domobj, eventName, handler, context(没用过，不清楚))addListener(obj, eventName, handler, context(没用过，不清楚))removeListener(listener): 可以移除dom和非dom事件。 参考 事件event中的内容 所有的CLICK事件点击位置的经纬度，对应在画布上的横纵坐标，事件target， 事件type 其他类型事件，如moveend，zoomevent中只有事件类型type 针对以上，我们可以对地图事件进行封装，一般需要的是事件发生的zoom，地图范围，点击位置的经纬度。🌰如下: const eventInjector = (ev, mapINS, cb) =&gt; { const bounds = mapINS.getBounds(); const param = { sw: bounds.getSouthWest(), ne: bounds.getNorthEast(), zoom: mapINS.getZoom(), type: ev.type, lng: ev.lnglat ? ev.lnglat.getLng() : &apos;&apos;, lat: ev.lnglat ? ev.lnglat.getLat() : &apos;&apos;, }; if (cb) cb(param); }; const mapEventHandler = (mapINS, type, opt, cb) =&gt; mapINS[opt](type, (ev) =&gt; eventInjector(ev, mapINS, cb)); //使用 mapEventHandler(mapIns, &apos;dragend&apos;, &apos;on&apos;, this.handleMapScale); mapEventHandler(mapIns, &apos;dragend&apos;, &apos;off&apos;,this.handleMapScale); //handleMapScale handleMapScale(ev) { console.log(ev); const { ne, sw, zoom, type } = ev; ... } 之后，如果在地图上发生dragend，event的结果如下： 常用地图基本类型LngLat ： 经纬度坐标，确定地图上的一个点构造函数： AMap.LngLat(lng: 119.78, lat: 39.99);生成一个经纬度为[119.78, 39.99]的地理坐标对象。常用方法： - getLng() 获取经度 - getLat() 获取纬度 - offset(w:2,s:-3) w经度，s纬度，参数为数字。将当前经纬度坐标值变化。经度是越向右越大，所以向右为正。同理，纬度越向上越大，所以向上为正。 - distance(lnglat: LngLat | [lng, lat]) 当前经纬度与传入的经纬度的连线的地面距离 - equals(lnglat:LngLat) Bounds：经纬度范围矩形框AMap.Bounds(southWest:LngLat1, northEast:LngLat2);生成一个东北角是LngLat2，西南角是LngLat1 的矩形地物框。常用方法： - contains(point: LngLat) 给出的经纬度点是否包含在矩形范围内 - getCenter() - getSouthWest() - getNorthEast() 常用覆盖物AMap.Marker 构造：AMap.Marker({ markeroptions }) 常用选项map:marker所在的地图position: LngLat类型，点在地图上的位置offset: 像素类型(-75，-75)，marker距离左上角的偏移content: string/object 这里可以自定义marker显示的内容，图片，svg等都可以。bubble: 将覆盖物的事件冒泡到地图上，默认falsezIndex: 叠加顺序title: 鼠标滑过时，点标记的文字提示。extData: 用户自定义属性draggable: 标记点是否可以拖拽移动 方法略多，这里就不写了，基本对应每个选项都会有个get，set方法。hide，show控制点标记的隐藏，还在map中。setMap比较有用，如果设为null，则在地图上移除当前Marker相关的div。还有一些移动类的应用，目前还没使用过，这里就不详述了，主要有：moveAlong, moveTo, stopMove, pauseMove, resumeMove。 事件与地图对象基本一致，少了个ready。多了一些move的行为，具体可参考 AMap.Polygon 构造：AMap.Polygon({ options }) 常用选项map:marker所在的地图path: 参数为，包含经纬度数组的数组. eg：[ [116.368904, 39.913423], [116.382122, 39.901176], [116.387271, 39.912501], [116.398258, 39.904600] ] bubble: 将覆盖物的事件冒泡到地图上，默认false。 zIndex: 叠加顺序, 默认比marker低。 类似svg的多边形属性: strokeColor，strokeOpacity， strokeWeight， fillColor， fillOpacity， strokeStyle， strokeDasharray。 extData: 自定义属性 方法。对应path，extData， options都会有个get，set方法。hide，show控制多边形的隐藏，多边形还在map中。setMap比较有用，如果设为null，则在地图上移除当前polygon相关的div。getBounds,矩形范围对象，返回Bounds类型。getArea,获取多边形面积。contains(point:LngLat)，点是否在polygon内。 事件很多，常用的又mouseover， click等。具体可参考 AMap.Circle 构造：AMap.Circle({ options }) 常用选项map:marker所在的地图center: LngLat类型，圆心在地图上的位置radius: 半径，number类型，单位是米bubble: 将覆盖物的事件冒泡到地图上，默认falsezIndex: 叠加顺序, 默认比marker低。extData: 用户自定义属性类似svg的多边形属性： 同上polygon 方法。对应center，extData， radius，options都会有个get，set方法。hide，show控制隐藏，还在map中。setMap同上。getBounds，圆外切矩形范围对象，返回Bounds类型。contains(point:LngLat)，点是否在圆内。 事件类型类似polygon 具体可参考 AMap.Polyline 构造：AMap.Marker({ markeroptions }) 常用选项，与polygon差不多。多一些线条相关的内容，具体可参考 方法和事件与polygon差不多 常用图层图层是位于最底层的模块，他可能在地图上的其他物件还没加载完就已经生成了。图层都需要地图以plugin的形式引进。 AMap.Heatmapheatmap是个plugin，需要添加plugin，在回调函数中生成AMap.Heatmap实例。 const heatmap; map.plugin([&quot;AMap.Heatmap&quot;], function() { heatmap = new AMap.Heatmap(map, { radius: 25, //给定半径 opacity: [0, 0.8] }); }); 上面的config，包含radius``gradient``opacity``zooms(支持的缩放级别，不在范围内，就不显示热力图了)渐变可以按照如下设置 gradient: { 0.4: &apos;red&apos;, 0.8: &apos;yellow&apos;, 1: &apos;blue&apos;} 方法与覆盖物的差不多，除了， addDataPoint(lng: Lng, lat: Lat, count: number) setDataSet(data: obj, url:jsonp格式数据的服务地址，urlDataParser:可以传递函数进行数据转化) // 这两个可以配合zoom，不同的zoom，热力图对应的数据集不同。 其中，data格式为： { max: number, data: [ { lng: 116.7, lat: 39.9, count: 10 }, { lng: 116.7, lat: 39.9, count: 10 }], } AMap.CustomLayer同样需要plugin来引入。 给出的属性和方法很少，但是功能强大，需要自己开发，参考实例 一般是自己做一些canvas，然后挂载在map上即可。自定义图层有个render属性？使其等于绘制函数，就可以在地图上绘制出来。 搜索服务支持搜索服务脱离地图使用，即使用搜索服务不再需要先实例化地图。通过AMap.plugin方法，加载需要的服务 AMap.Autocomplete 常用选项：city:输入提示被限定的城市citylimit: 是否强制限制在设置的城市内搜索input:指定一个输入框，内容则作为input的id，在input输入文字后，会自动生成一个下拉选择列表。 search方法，可以结合他的search方法，获取数据，然后自己render样式~~ AutocompleteResult对象： { info： 状态说明, count: 输入提示条数, tips: [ { name: 名称, district: 所属区域, ,adcode: 区域编码}, { name: 名称, district: 所属区域, ,adcode: 区域编码}... ] } 通常autocomplete配合placeSearch进行使用的 AMap.PlaceSearch 常用选项：city:输入提示被限定的城市citylimit: 是否强制限制在设置的城市内搜索type:兴趣点类别，可以通过setType设置pageSize:单页显示结果条数extensions: ‘all’ 返回基本+详细信息panel&amp;renderStyle结果列表的html容器id，或者容器元素，结果列表将在给出的容器中进行展示，自己可以render样式。 可用方法见参考吧 上个search使用示例： html： &lt;img className={styles.searchIcon} src={searchIcon} alt=&quot;search&quot; onClick={() =&gt; this.handleSearch()} /&gt; js: handleSearch() { // this.state.placeSearch是个AMap.Autocomplete实例 this.state.placeSearch.search(this.refs.searchInput.value, this.handleSearchSelect); } handleSearchSelect(search, result) { if (result.info === &apos;OK&apos;) { // mapInstance是个封装了AMap的对象。 const mapIns = mapInstance.getter(); // 自定义搜索结果的marker样式。并绘制在地图上 this.generateSearchMarkers(result.poiList); if (result.poiList.pois.length &gt; 0) { const { lng, lat } = result.poiList.pois[0].location; // 将map的中心定位到获取到的第一个poi的位置上。 mapIns.setCenter([lng, lat]); mapIns.zoomIn(); } } } 如果查到结果searchResult有以下内容： 其他还有好多具体的搜索的服务。由于没有用到，就没看。。。 信息窗体AMap.InfoWindow用于在地图上弹出一个详细信息展示窗体，地图上只允许同时展示1个信息窗体 属性isCustom： 是否自定义窗体，true 则完全按照content中的规定来显示autoMove： 将窗体完全展现在视图中。closeWhenClickMap: 鼠标点击地图后是否关闭信息窗体position: 信息窗体显示位置，类型为经纬度对象 方法事件类似polygon，有一些属性的get，set方法，open，close方法。 定位AMap.CitySearch项目中用到这个api。它主要是根据ip返回对应的城市信息，根据输入ip或自动获取ip来获取城市信息。该api也是个plugin，可以在初始loader地图的时候，就将其配置进去，将脚本加载时的代码。 两个方法：getLocalCity((status, citySearchResult) =&gt; {…})getCityById(ip, (status, citySearchResult) =&gt; {}) 例子： // citysearch部分代码，省略地图实例了，用mapIns代替 citysearch.getLocalCity((status, result) =&gt; { if (status === &apos;complete&apos; &amp;&amp; result.info === &apos;OK&apos;) { if (result &amp;&amp; result.city &amp;&amp; result.bounds) { const city = R.slice(0, -1, result.city); const cindex = R.indexOf(city, R.pluck(&apos;cityName&apos;, cityList)); const ccode = R.pluck(&apos;cityCode&apos;, cityList); if (cindex !== -1 &amp;&amp; city !== &apos;北京&apos;) { mapIns.setCity(city); mapIns.setZoom(11); } } } }); citySearchResult 的属性：city， bounds 位置解析AMap.GeocoderGeocoder是进行地址描述与地理坐标间的相互转换。也就是，给出一个地址名称，转换为地理坐标的经纬度等信息。或者给出一个经纬度，确定这个点的地址名称信息。 相关方法： 获取地理编码：getLocation(address:String, (status:String,result:info/GeocodeResult) =&gt; {}) 逆地理编码：getAddress(location:LngLat|Array.,(status:String,result:info/ReGeocodeResult) =&gt; {})// 最多20个地址数组。 s用的比较多的是逆地理编码，比如自己做一个在地图上点击，然后找出该位置的相关信息。逆地理编码的返回结果属性：想展示什么，就从以下选择吧","tags":[{"name":"js","slug":"js","permalink":"https://misssweety.github.io/tags/js/"},{"name":"地图api","slug":"地图api","permalink":"https://misssweety.github.io/tags/地图api/"},{"name":"总结","slug":"总结","permalink":"https://misssweety.github.io/tags/总结/"}]},{"title":"css3实现3d效果","date":"2017-05-15T08:34:12.000Z","path":"2017/05/15/css3实现3d效果/","text":"css3实现3D效果相关属性 transform: rotateX(…) transfrom-origin: left center; transform-style: preserve-3d; perspective: 200px; perpective-origin: left center; backface-visibility: true; 3d效果基础知识一般是在旋转后才能表现出3d效果，css中规定的旋转规则如下： alt axis rotateX是以屏幕的水平方向为轴旋转，rotateY是以屏幕的垂直方向为轴，rotateZ是以与屏幕平面垂直的方向为轴。其实rotatex rotateY已经能实现3d效果了，但是不是很直观。搭配上perspective，perfect！ perspective含义：透视效果。指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。等同于绘画中的1点透视||平行透视。一个物体如果z-index为正，那么我们在画布中实际看到的就要偏大。如下第一个图。如果一个物体的z-index为负，那么显示在画布视图中，则偏小，如第二个图 alt perspective 两种写法:a：perspective：300px;b：transform: perspective(300px) rotateX(aa); 区别：第一个需要写在一个父级元素上，他规定了这个父级元素的透视点位置，换个角度说，当为元素规定perspective 属性时，其直接子元素会获得透视效果，而不是元素本身。第二个可以直接作用在当前元素上，也可以结合其他transform属性，规定了当前元素的透视点位置，对其他元素无影响。&nbsp;&nbsp;&nbsp;&nbsp;perspective 值越大，3d效果越不明显；越小越明显。想像成镜头到物体的距离，越近越能看出高低起伏，越远线条展示的越平缓。两种写法以及perspective对比，查看示例 -webkit-perspective-origin消失点的位置，语法：-webkit-perspective-origin: xpos yposxpos,ypos 可以选择关键字，left|right|center top|bottom|center 。如果是关键字，则是否对应xy无关紧要，浏览器会自己选择。如果是数值，百分比或者像素，则要按照x，y的顺序写。参考实例 backface-visibilitybackface-visibility 属性定义当元素不面向屏幕时是否可见。有些时候前面的div如果设置了透明度，就会看到后面的对象，这是可以将该属性设为hidden就可以了。默认：visible transform这里主要提和3d有关的几个属性 rotateX( angle ) rotateY( angle ) rotateZ( angle ) translateZ( tz ) scaleZ( sz ) translateZ，scaleZ会将对象在与屏幕平行的方向变化物体。会有失真。 也有综合的写法： translate3d( tx, ty, tz ) scale3d( sx, sy, sz ) rotate3d( rx, ry, rz, angle ) rotate3d这里，前三个规定旋转轴在空间中的方向，比如x轴，就是（1，0，0）rotate3d(1,0,0,90deg) === rotateX(90deg) transform-origin规定变化的中心点。一般都是对象的重心。可以修改成任意的值，以旋转为例: html &lt;div class=&quot;test1&quot;&gt;test&lt;/div&gt; &lt;div class=&quot;test2&quot;&gt;test2&lt;/div&gt; css div { width:200px; height: 200px; background: rgba(255, 0, 0,.5); margin: 20px auto; animation: mymove 3s infinite; } .test1{ transform: perspective(500px) rotateY(0deg); } .test2 { transform-origin: left; transform: perspective(500px) rotateY(0deg); } @keyframes mymove { from {transform: perspective(500px) rotateY(0deg);} to {transform:perspective(500px) rotateY(360deg);} } 表现是：test1将沿着div的宽度的一半为轴旋转。test2则沿着最左边的边框为轴旋转。参考实例 实例一：翻牌效果&lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;card&quot;&gt; &lt;div class=&quot;front&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;back&quot;&gt;2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; //css,设置一个container，他是个具有3d效果的box .container { width: 200px; height: 200px; position: relative; perspective: 800px; border: 1px solid #888; margin: 40px auto; } #card { width: 100%; height: 100%; position: absolute; transform-style: preserve-3d; animation: flip 2s infinite; transform-origin: left center; } #card figure { display: block; width: 100%; height: 100%; position: absolute; text-align: center; color: white; font-size: 40px; line-height: 200px; backface-visibility: hidden; } .front { background: tomato; } .back { background: lightblue; transform: rotateY( 180deg ); } @keyframes flip { 0% { transform: rotateY( 0deg ); } 50% { transform: rotateY( 180deg ) translateX(-100%); } 100% { transform: rotateY( 360deg ) } } container中的card div具有3d效果，如果想让card中的div等也有3d变化效果，可以通过对card设置： transform-style: preserve-3d; 将其父元素的3d透视集成下来，并使所有子元素保持在同一个3d空间中。背面那张牌需要翻到背面去，也就是rotateY( 180deg );参考示例 ###实例二：旋转的正方体参考示例六个div拼凑起来的。分别在xy方向上进行翻转，立到对应的方向。此时在添加一个translateZ才能显现出他们的效果。否则都是堆在zindex为0的位置，什么都看不见. 别的配置及思想同上面的翻牌 ###常见问题：1.设了transfrom-style:preserve-3d为什么还不好使。 这个时候需要查看父元素是否还设了，overflow，filter，clip，isolation，clip-path，mask-image，mask-box-image-source， mix-blend-mode，如果不是默认值的，会将transfrom-style:preserve-3d 失效。原因是前几个属性，会创造一个flatten的box，而preserve-3d是生成stacking context 的。","tags":[{"name":"css","slug":"css","permalink":"https://misssweety.github.io/tags/css/"},{"name":"perspective","slug":"perspective","permalink":"https://misssweety.github.io/tags/perspective/"},{"name":"3D效果","slug":"3D效果","permalink":"https://misssweety.github.io/tags/3D效果/"}]},{"title":"读书笔记-闭包","date":"2017-05-08T03:11:08.000Z","path":"2017/05/08/读书笔记-闭包/","text":"经典闭包闭包是一个函数（引用），即使他是在当前词法作用域之外执行，他也可以记住并访问所在的词法作用域。就是用这个引用来访问。参考 function foo () { const a = 9; const bar = () =&gt; {return a;} return bar; } const aa = foo(); console.log(aa()); 返回9； 解析在foo()执行后，其返回值赋值给变量aa，并执行aa()，其实是通过不同的标识符引用调用了内部函数bar()。bar在其词法作用域外被正常执行了。而且foo函数执行后，通常整个foo内部作用域都被销毁，但是由于bar的存在，是的内部作用域依然存在，组织了垃圾回收。bar() 拥有涵盖foo()内部作用域的闭包，使得该作用域能一直存活。bar()依然持有对该作用域的饮用，这个引用就叫做闭包。 如果将函数当作第一级的值类型进行传递，其实就会有闭包的存在。一些异步或者同步操作中，使用了回调函数，也是在使用闭包。 无处不在 本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax请求、跨窗口通信、Web Workers或者任何其他的异步(或者同步)任务中，只要使用了回调函数，实际上就是在使用闭包. 最常见的考题 for (var i = 1; i&lt;= 5; i++) { setTimeout(() =&gt;console.log(i), 1000*i); } 输出是：五个6 原因：i是全局变量，setTimeout是等待执行。延迟函数的回调会在循环结束时才执行,执行的时候i已经跳出循环，第一个满足的值就是6.所以输出5个6. 修改：将var 改为let。只在当时的循环中生效。可以每秒输出12345 另外一个应用：模块 从方便观察的角度看，一个从函数调用 所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。 实例： function CoolModule() { var something = &quot;cool&quot;; var another = [1, 2, 3]; function doSomething() { console.log( something ); } function doAnother() { console.log( another.join( &quot; ! &quot; ) ); } return { doSomething: doSomething, doAnother: doAnother }; } var foo = CoolModule(); foo.doSomething(); // cool foo.doAnother(); // 1 ! 2 ! 3 上一个示例代码中有一个叫作 CoolModule() 的独立的模块创建器，可以被调用任意多次， 每次调用都会创建一个新的模块实例。如果想实现单例模式：就是将coolmodule 转换为iife，并赋予一个标识符： var foo = (...)(); foo.doSomething(); foo.doAnother(); 结果同上 模块有两个主要特征:(1)为创建内部作用域而调用了一个包装函数;(2)包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。 词法作用域function foo() { console.log( a ); // 2 } function bar() { var a = 3; foo(); } var a = 2; bar(); 输出结果：2。词法作用域，运行bar，到foo的时候，这里的a是全局变量的a，所以为2.","tags":[{"name":"js","slug":"js","permalink":"https://misssweety.github.io/tags/js/"},{"name":"闭包","slug":"闭包","permalink":"https://misssweety.github.io/tags/闭包/"}]},{"title":"linux 目录结构","date":"2017-05-08T02:46:56.000Z","path":"2017/05/08/linux文件目录/","text":"原来学linux的时候，不上心，现在后悔莫及，开始补基础。首先是最基本的目录结构。linux是树状结构 标橘色为重要目录 目录 描述 ／ 根目录，整个文件系统层次结构的根目录，一般只放目录 /bin/ 类似 /usr/bin 可执行的二进制文件的目录，常用的ls，tar，mv， cat等 /boot/ 引导程序文件，放置linux系统启动时用到的一些文件 /dev/ 存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备 /etc/ 系统配置文件存放的目录,不建议在此目录下存放可执行文件，重要的配置文件 /home/ 系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下, 建议单独分区，并设置较大的磁盘空间 /lib/,/usr/lib/, /usr/local/lib/ 系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为/lib/modules /lost+fount/ 系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。 /mnt/ 临时挂载的文件系统。比如cdrom,u盘等，直接插入光驱无法使用，要先挂载后使用 /opt/ 给主机额外安装软件所摆放的目录, 可选应用软件包。 /proc/ 此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间.比较重要的目录有/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*等 /root/ 超级权限用户的家目录 /sbin:/usr/sbin:/usr/local/sbin 放置系统管理员使用的可执行命令，如fdisk、shutdown、mount等。sbin目录下的命令，普通用户都执行不了。 /tmp/ 一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下,在系统重启时目录中文件不会被保留。 /srv/ 服务启动之后需要访问的数据目录，如www服务需要访问的网页数据存放在/srv/www内 /usr/ 默认软件都会存于该目录下。用于存储只读用户数据的第二层次；包含绝大多数的(多)用户工具和应用程序。 /var/ 变量文件——在正常运行的系统中其内容不断变化的文件，如随时更改的日志文件 /var/log，/var/log/message： 所有的登录文件存放目录，/var/spool/mail： 邮件存放的目录， /var/run: 程序或服务启动 /etc/目录未完待续。。。参考参考二","tags":[{"name":"linux","slug":"linux","permalink":"https://misssweety.github.io/tags/linux/"}]},{"title":"export相关","date":"2017-04-18T03:01:45.000Z","path":"2017/04/18/exports/","text":"exports 和 module.exports 的区别exports 是引用 module.exports 的值。module.exports 被改变的时候，exports不会被改变，而模块导出的时候，真正导出的执行是module.exports，而不是exports。 有以几点需要记住： module.exports 初始值为一个空对象 {}exports 是指向的 module.exports 的引用require() 返回的是 module.exports 而不是 exports如果module.exports 当前没有任何属性的话，exports会把属性收集起来赋给module.exports。如果module.exports 有属性的话, exports中的所有内容都会被忽略。 foo.js exports.a = function(){ console.log(&apos;a&apos;) } module.exports = {a: 2} exports.a = 1 test.js var x = require(&apos;./foo&apos;); console.log(x.a); 输出 ：2 如果：foo.js 为： exports.a = function(){ console.log(&apos;a&apos;) } exports.a = 1 test.js 输出：1 如果：foo.js为： exports.a = function(){ console.log(&apos;a&apos;) } test.js 输出：[Function] 首先，node中的require 引进的是module.exports。。。见第一个实例。如果没有显式的写module.exports，则自动连接exports与module.exports。如果显示的写了module.exports，则会断开module.exports 与 exports 的联系。 应用的话，如果只是导出某个变量或者某个功能，用exports.属性|方法。如果是导出多个属性或方法或使用对象构造方法，module.module 比较好。 export default 和 export 区别1.export与export default均可用于导出常量、函数、文件、模块等2.你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用3.在一个文件或模块中，export、import可以有多个，export default仅有一个4.通过export方式导出，在导入时要加{ }，export default则不需要 引入时：加了default的变量，可以起任意名字，非default的需要与export时的名字相同。 module.exports vs exportcommonjs：module.exports 搭配的引入： requirees6: export 搭配的引入： import 普通js环境下是不支持es6的语法的，如果想这么用，需要用babel等进行转译。 es6 default export 其实是与exports 等价的，只不过 default 只是一个保留的名称，可以想象为，exports 一个属性，属性名为default。所以如果是在node.js环境下，用的export default， 引用的时候用require的话，需要这么写： var bar = require(‘./input’).default; export vs export default这两个在import的时候，前者需要用{} 扩起来，有种解构的感觉。后者不需要{}扩。","tags":[{"name":"node.js","slug":"node-js","permalink":"https://misssweety.github.io/tags/node-js/"},{"name":"js","slug":"js","permalink":"https://misssweety.github.io/tags/js/"}]},{"title":"Visual-Formatting-Model","date":"2017-04-17T04:00:00.000Z","path":"2017/04/17/Visual-Formatting-Model/","text":"1.视觉格式化模型 introduction视觉格式化模型：User Agent 如何在 Visual Media下处理文档树。 视觉格式化模型中，文档树中的每一个元素根据盒模型 Box Model 产生零个或多个盒。这些盒的布局由以下内容控制： 盒的尺寸和类型 定位体系 Positioning Scheme （常规流，浮动和绝对定位） 文档树中元素之间的关系 外部信息（如：视口大小，图片的固有尺寸等） 1.1 视口 viewport连续媒体 Continuous Media 上工作的user agent一般会向用户提供一个viewport（屏幕上的一个窗口或其它可视区域）来帮助用户访问文档。user agent可以在调整视口大小的同时改变文档的布局 1.2 包含块 containing blocksCSS2.1中，许多盒的定位和大小都根据一个名为包含块 Containing Block 的矩形盒的边缘来计算。生成的盒会充当其后代盒的包含块；我们称盒为其后代“创建”了包含块。说“盒的包含块”即是说“盒所处的包含块”，而不是盒所产生的包含块。 2 盒的生成 Controlling Box Generationdisplay指定盒的类型 有几个概念： block-level box: display：block|table|list-item block box: 除了table块盒和可替换元素，其他的都是块容器盒。也是块盒。 block container box: 一个块容器盒要么只包含块级盒，要么创建一个行内格式化上下文 Inline Formatting Context 并只包含行内级盒 Inline-level Boxes。不一定是block的才是，行内也是。所以和块级盒只是一部分有交集。 3 定位体系 Position schemes在css2.1中，一个box有三种机制来布局 normal flow：块级formatting, 行级formatting，相对定位 float：box先按照normal flow放置，然后从流中脱离出来，可能会对后面的排序有影响 absolute position：完全脱离出文档流，对之后的元素没有影响 [脱离文档流] float， absolutely positioned， 根元素。 3.1 position 属性属性： static：top right等并不生效 relative：盒的定位根据常规流计算（盒被成为常规流内定位）。盒相对其常规位置移动。当B盒相对定位，B盒之后的盒定位时就当B没有移动一样来计算。table相关的内盒并没有relative属性 absolute：位置大小通过top，right等定义。脱离文档流了，即便绝对定位盒有外边距，也不同其他任何外边距折叠。 fixed：盒的定位根据 absolute 模型来计算，但除此之外，盒相对某些参照物保持固定。【用户代理不可将固定盒的内容分页显示。注意用户代理可能用其他方法打印不可见内容。参见第13章“页盒外的内容”】 4 常规流 Normal Flow常规流中的盒子都属于某个格式化上下文，要么块格式化上下文BFC，要么行内格式化上下文LFC，总之不能二者得兼。 ###4.1 bfc 浮动 绝对定位元素、 非块盒的块容器（如：行内块 inline-block 、表格单元格 table-cell 以及表格标题 table-caption ） 以及 overflow 属性不为 visible 的块盒（除了该值被传播到视口的情况） 将为其内容创建一个新的块级格式化上下文。 在块格式化上下文中: 盒从包含块顶部一个接一个地垂直摆放。 两个同胞盒间的垂直距离取决于 margin 属性。 同一个块格式化上下文中的相邻块级盒的垂直外边距将折叠。 每个盒的左外边缘紧贴包含块的左边缘。 ###4.2 lfc 盒从包含块顶部一个接一个的水平摆放。盒的垂直对齐方式则不一：可能按底部或者顶部对齐，又或者按它们内容文本的基线对齐。 行盒的宽度取决于包含块以及浮动。 行盒的高总是足以容纳其包含的所有盒，当一个盒（ B ）的高度小于包含它的行盒的高度时， B 的垂直对齐方式由 vertical-align 属性决定。 当一行不能包含所有时，它们会被分配到两个或者多个垂直摆放的行盒中，变成垂直堆叠。行盒的堆叠没有垂直间距（除非有特别声明）并且从不重叠。 一般行内盒超过行盒宽度是，行内盒会被分在多个行盒中。 如果一个行内盒不可切割（比如，行内盒包含的是单个字符或者语言指定的断字规则不允许断字，又或者行内盒的 white-space 属性值为 nowrap 或 pre ），那么该【行内盒将溢出行盒】。 ###4.3 相对定位对于相对定位而言，left 和right使其发生水平位移。而且满足：left = - right。所以如果两个都定义了，则必有一个被忽略。top bottom同理，top胜。 5 浮动 floats浮动盒将被移动至左侧或右侧直至其外侧紧贴包含盒的边缘或另外一个浮动的外边缘。如果存在行盒，浮动盒的顶部外边缘将与行盒的顶部对齐。 float内元素的margin不会与包含他的发生垂直边距折叠。 clear 清除浮动 https://segmentfault.com/a/1190000003096320#articleHeader5 [link]https://www.w3.org/TR/CSS2/visuren.html#block-formatting","tags":[{"name":"css","slug":"css","permalink":"https://misssweety.github.io/tags/css/"}]},{"title":"thinking-with-join","date":"2017-03-09T14:16:48.000Z","path":"2017/03/09/thinking-with-join/","text":"下面这段代码是我们最常用的，为每个数据生成一个circle，调用数据里的x，y来定位。但是我们selectAll的元素，此时并不存在，那d3是如何工作的呢? svg.selectAll(“circle”) .data(data) .enter().append(“circle”) .attr(“cx”, function(d) { return d.x; }) .attr(“cy”, function(d) { return d.y; }) .attr(“r”, 2.5); 在d3中，告诉d3你想要什么，而不是告诉d3怎样做什么。对于上面这个需求，我们要做的就是，我想要circle对应于数据，每个circle对应于一个数据，而不是告诉d3，你应该给我创造一个circle，然后告诉d3选择的circle应该和数据对应好。这个原则就叫做data join Data Enter Update Elements Exit 连接到现有元素的数据点生成update（内部）选择。剩余未绑定数据生成enter选择（左），表示缺少的元素。同样，任何剩余的未绑定元素会生成exit选择（右），表示要删除的元素。 现在，我们可以通过data join 来揭开enter-append序列的谜团了 svg.selectAll(&quot;circle&quot;) 返回一个新的空selection，因为SVG容器是空的，所以该selection的父节点是SVG容器 然后此selection连接到数据数组，生成三个新selection分别表示三种可能的状态：enter，update和exit。由于selection为空，所以update和exit选择为空，而enter selection包含每个新数据的占位符。 update selection通过selection.data返回,而enter和exit selection挂起update selection; selection.enter返回enter selection。 通过在enter selection上调用selection.append，将缺少的元素添加到SVG容器。这会为每个数据点向SVG容器添加一个新圆。 Thinking with joins 意味着在一个selection和数据集中声明一种关系，然后通过enter, update, exit实现这个关系. 但是为什么会这么麻烦呢？为什么不一开始就创建多个元素呢？data join的美丽在于它的泛化。虽然上述代码只处理enter selection,这就可以处理静态可视化了，但是你可以将其扩展为支持动态可视化，只需对update和exit进行少量修改。这意味着您可以对实时数据进行可视化，允许交互式探索，以及在数据集之间平滑过渡！ 看下包含三个状态的例子： var circle = svg.selectAll(“circle”) .data(data);circle.exit().remove();circle.enter().append(“circle”) .attr(“r”, 2.5) .merge(circle) .attr(“cx”, function(d) { return d.x; }) .attr(“cy”, function(d) { return d.y; }); 无论何时运行此代码，它都会重新计算数据连接并保持元素和数据之间的所需对应关系。如果新数据集小于旧数据集，则剩余元素将在退出选择中结束并被删除。如果新数据集较大，剩余数据将在输入选择中结束，并添加新节点。如果新数据集的大小完全相同，那么所有元素都将使用新位置进行更新，并且不会添加或删除任何元素。 thinking with join用连接来思考意味着你的代码更具声明性：你处理这三个状态没有任何分支（if）或迭代（for）。而是描述元素应如何对应数据。如果给定的enter，update或exit selection恰好是空的，则相应的代码是无操作 连接还允许将操作定向到特定状态（如果需要）。例如，你可以在enter而不是update上设置常量属性（例如由“r”属性定义的圆的半径）。通过重新选择元素和最小化DOM更改，您大大提高了渲染性能！同样，您可以将动画过渡指定为特定状态。例如，在entering状态，加入动画圆圈展开 大致翻译自：thinking with join","tags":[{"name":"d3","slug":"d3","permalink":"https://misssweety.github.io/tags/d3/"},{"name":"translate","slug":"translate","permalink":"https://misssweety.github.io/tags/translate/"}]},{"title":"博客搭建","date":"2016-10-27T04:00:00.000Z","path":"2016/10/27/blog-publish/","text":"适用于macOS ###1.需要安装git，npm，node升级本地npm npm install npm@latest -g 如果有权限问题，前面加上sudo就可以了 ###2.安装hexo sudo npm install -g hexo 全局安装了 ###3.hexo管理一个网站 hexo init blog 名字随自己喜欢，这里起的事blog ###4.进入该文件，进行管理 cd blog hexo server //启动你的本地网站，访问localhost:4000，就可以看到雏形了 hexo new &quot;hello world&quot; //生成一个hello world.md文件，新新文章，添加到网站中 ###5.部署到github上 ####git上建立仓库先在自己的库里创建一个新的repo,作为网站的远端库，一般命名为自己的账号名，例如： 我的账号missSweety，新建的repo为missSweety.github.io ####修改hexo配置文件回到hexo中，为了部署到github上，我们需要修改_config.yml文件如下： deploy: type: git repository: https://github.com/MissSweety/MissSweety.github.io.git branch: master ####安装hexo deployer git npm install hexo-deployer-git –save如果不安装这个，deploy的时候会报错的 ####hexo deploy hexo deploy如果没配过ssh，还是会报错的解决方法： ssh-keygen -t rsa -b 4096 -C ‘email’ 按照提示，输入账号，密码，就会生成文件了回到github网站，在setting中把公钥放进去 ssh -T git@github.com 用该指令可以查看是否已经鉴权了 如果以上都好了，这次在用hexo deploy,就会自动push代码，并发布了，可以查看你的网站了 ###大功告成!!!","tags":[{"name":"hexo","slug":"hexo","permalink":"https://misssweety.github.io/tags/hexo/"}]}]