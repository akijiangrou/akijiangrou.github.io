[{"title":"d3-scale","date":"2017-09-21T06:54:58.000Z","path":"2017/09/21/d3-scale/","text":"scale缩放也叫比例尺。是可视化的基本，使抽象的数据，转换成可视化的代表，比如宽高，位置或者颜色等。 输入 &amp; 输出scale缩放，其实是一种mapping。将输入的数据转换成对应的想要的输出的数据形式。 既然是转换，那就需要输入和输出。 输入是放入domain函数的参数。输出时放入range 函数的参数。 妙记 ID OR其实每个scale函数返回的都是函数，需要的参数就是数据。 先举几个基本例子： 人口范围50万-130万 对应 输出长度为 500像素范围。 12345var newRamp = d3.scale.linear().domain([500000,13000000]).range([0, 500]);newRamp(1000000); // return 20;说明，人数为100万时对应长度为20像素newRamp(9000000);newRamp.invert(313); // 知道像素长度313px，想知道他对应的人口数。 人口范围50万-130万 对应 输出颜色 蓝色-红色 123456var newRamp = d3.scale.linear().domain([500000,13000000]).range([\"blue\",\"red\"]);newRamp(1000000); // return #ad0052;说明，人数为100万时对应颜色newRamp(9000000);newRamp.invert(#ad0052); //NaNinvert适应于输出为数字的比例转换。 示意： 离散型，将一组数据分为三类 12345var sampleArray = [423,124,66,424,58,10,900,44,1];var qScale = d3.scale.quantile().domain(sampleArray).range([0,1,2]);qScale(423); // 2qScale(20); // 0qScale(10000); //2 示意： scale 分类按照我个人的偏好分类如下： 输入输出都连续[linear, power, log] 输出离散[quantize scale] 输入输出都离散[band, point] 颜色相关[顺序比例尺(),categorical color scale,] 时间相关[scaleTime 属于连续型] 输入输出都连续 scaleLinear scalePower scaleLog scaleSqrt scaleTime scaleSequential 后两个单独做解释。线性scaleLinear， 没什么可说的，就是输出与输入呈线性相关。y = ax + b幂指数scalePower，输出与输入的幂指数呈正相关。y = m * x^k + b平方根缩放scaleLog，就是幂指数中k = 0.5。关于这个，一般用于使用面积来表达数据值的大小时。所以该scale函数的结果可以作为r的值。对数缩放scaleLog， 输出与输入的对数呈正相关。 y = m * log(x) + b 参考代码：d3-practice 关于连续型的缩放，还有其他几个参数： Clamp()：控制当输入超过range的情况。默认是false，如果超过range，则会自动按比例换算成domain以外的值。设为true则会严格控制结果在对应的domain中。 Nice()：主要用在使用真实数据来设置range的时候，d3.extent(data)会自动读取min&amp;max作为范围。但是如果作为坐标轴，可能数据看起来不是很好看，设置成nice()它会自动向上取整。 invert()：可以根据给出的输出值，来计算输入值。【注意】：domain必须是数字类型的 range: 支持多个value。同时domain也要输入多个参数。相互为边界，实现缩放。例子：（见下面的多段缩放） 12345678910111213141516171819202122// 位置缩放const firstScale = d3.scaleLinear() .domain([0, 10]) .range([0, 400]);// 面积缩放const sqrScale = d3.scaleSqrt() .domain([0, 10]) .range([0, 40]);// 多段缩放const fourthScale = d3.scaleLinear() .domain([0, 5, 10]) .range(['purple','white', 'lightgreen']);canvas.selectAll('.fourthScale') .data(testData) .enter() .append('circle') .attr('class', 'fourthScale') .attr('r', d =&gt; sqrScale(d)) .attr('cx', d =&gt; firstScale(d)) .attr('cy', 200) .attr('fill', d =&gt; fourthScale(d)); 结果如下： 输入连续，输出离散 scaleQuantize scaleQuantile scaleThreshold 输入输出都离散 scaleOrdinal scaleBand常用在柱形图，条形图中。自动生成柱子和间隙的位置。 scalePoint 颜色相关 scaleSequential这个和线性的类似，只不过range是不能配置的，而是通过interpolator()来对应的。其中，插值函数是接收0，1之间的输入，输出两个数字，颜色或者字符之间的插值。这个一般用于热力图等关于颜色的计算中，而且d3规定了一些内置的颜色插值。代码参考如下图： category Scales 用于 scaleOrdinal中 时间相关 scaleTime 参考","tags":[{"name":"d3","slug":"d3","permalink":"https://misssweety.github.io/tags/d3/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://misssweety.github.io/tags/学习笔记/"}]},{"title":"html5-小插件","date":"2017-09-21T02:56:33.000Z","path":"2017/09/21/html5-小插件/","text":"有些时候会遇到上传文件和下载的需求，一般原生html样式并不能满足要求。所以总结了一下平时常用的图片上传，问价上传下载等简单的小需求的实现。 包含图片上传，限制图片的大小。文件上传和下载（不用form 标签）之前做地图需求的，字符颜色转rgb的简单转化。 大部分的组件渲染是基于react，所以写法都是react相关的。 上传图片及检查大小本示例是限制了上传图片的大小，maxWidth: 600, maxHeight: 300, maxSize: 200, 上传前前端先做检查。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import React, &#123; Component, PropTypes &#125; from 'react';import imageStyles from '../styles/image.css';import &#123; imageSizeCheck, newImageSrc &#125; from '../utils/imgCheck.js';/** * Image 组件，支持上传图片 * * @props onImageChange 传回上传的图片的地址 * @props onError 上传失败的处理 */class Image extends Component &#123; constructor() &#123; super(...arguments); // 用于自动设置图片高度 this.state = &#123; imageHeight: 180, &#125;; &#125; componentDidMount() &#123; if (typeof window === 'undefined') return; const imageHeight = this.refs.imageContainer.offsetWidth * 0.618; this.setState(&#123; imageHeight &#125;); &#125; handleClick() &#123; // 模拟点击上传图片按钮 this.refs.file.click(); &#125; handleChange() &#123; const formData = new FormData(); formData.append('file', this.refs.file.files[0]); // 检验图片大小 this.imageCheck(this.props.subtype, this.refs.file.files[0], (err, res) =&gt; &#123; if (err) &#123; const msg = `请选择$&#123;res.maxWidth&#125;*$&#123;res.maxHeight&#125;像素且大小不超过$&#123;res.maxSize&#125;k的图片上传`; window.alert(`您的图片为$&#123;res.height&#125;*$&#123;res.width&#125;像素,大小为$&#123;res.size&#125;k. $&#123;msg&#125;`); &#125; else &#123; // 成功的操作 &#125; &#125;); &#125; imageCheck(subtype, file, cb) &#123; // 可修改图片检查的大小和尺寸。 const sixthree = &#123; imgFile: file, maxWidth: 600, maxHeight: 300, maxSize: 200, &#125;; imageSizeCheck(sixthree, (err, res) =&gt; &#123; if (err) &#123; return cb(err, res); &#125; imageSizeCheck(&#123; imgFile: file, maxWidth: 700, maxHeight: 350, maxSize: 200, &#125;, cb); &#125;); &#125; render() &#123; return ( &lt;div ref=\"imageContainer\" className=&#123;imageStyles.imageContainer&#125;&gt; &lt;div className=&#123;imageStyles.imageUpload&#125; onClick=&#123;this.handleClick.bind(this)&#125; style=&#123;&#123; height: this.state.imageHeight, lineHeight: this.state.imageHeight + 'px', &#125;&#125; &gt;点击上传图片 &lt;/div&gt; &lt;input ref=\"file\" className=&#123;imageStyles.inputFile&#125; onChange=&#123;this.handleChange.bind(this)&#125; type=\"file\" accept=\"image/*\"/&gt; &lt;/div&gt; ); &#125;&#125;export default Image; 123456789101112131415161718192021222324252627282930image.css.imageContainer &#123; position: relative; overflow: hidden;&#125;.imageContainerHasImg .imageUpload &#123; opacity: 0;&#125;.imageUpload &#123; opacity: 0.5; background: #999; position: absolute; top: 0; left: 0; width: 100%; color: white; text-align: center; font-size: 2em; cursor: pointer; transition: opacity 0.3s;&#125;.imageUpload:hover &#123; opacity: 0.6;&#125;input[type=\"file\"].inputFile &#123; display: none;&#125;.img &#123; width: 100%;&#125; 123456789101112131415161718192021222324252627imageCheck.jsexport function imageSizeCheck(&#123; imgFile, maxWidth, maxHeight, maxSize &#125;, cb) &#123; const res = &#123; maxWidth, maxHeight, maxSize, &#125;; const size = Math.floor(imgFile.size / 1024); const reader = new FileReader(); reader.onload = (e) =&gt; &#123; const data = e.target.result; const tempImg = document.createElement('img'); tempImg.onload = () =&gt; &#123; res.width = tempImg.width; res.height = tempImg.height; res.size = size; if (res.width &gt; maxWidth || res.height &gt; maxHeight || res.size &gt; maxSize) &#123; cb(new Error('上传失败'), res); &#125; else &#123; cb(null, null); &#125; &#125;; tempImg.src = data; &#125;; reader.readAsDataURL(imgFile);&#125; 文件上传文件上传有默认的样式，一般都是不满足的，所以用一下方式修改。后面的span用于展示文件内容。 12345&lt;div className=\"monitor-clickUploader\"&gt; &lt;span className=\"monitor-upload-btn\"&gt; + 上传商户id&lt;/span&gt; &lt;input type=\"file\" name=\"file\" ref=&#123;input =&gt; &#123; this.upload = input; &#125; &#125; onChange=&#123;() =&gt; this.handleFileChanged()&#125;/&gt; &lt;/div&gt; &lt;span&gt;&#123;this.state.fileName&#125;&lt;/span&gt; 1234567891011121314151617181920212223242526272829.monitor-clickUploader &#123; position: relative; overflow: hidden; display: inline-block; margin: 0px 10px 0px 20px; vertical-align: middle;&#125;.monitor-clickUploader input &#123; position: absolute; top: 0; left: 0; margin: 0; padding: 0; font-size: 20px; cursor: pointer; opacity: 0; filter: alpha(opacity=0);&#125;.monitor-upload-btn &#123; display: inline-block; border: 1px solid #3bb4f1; position: relative; color: #3bb4f1; padding: 4px 10px 4px 10px; font-size: 12px; border-radius: 3px; cursor: pointer;&#125; 1234567handleFileChanged() &#123; const fileList = this.upload.files; if (fileList.length &gt; 0) &#123; this.setState(&#123; fileName: fileList[0].name&#125;); &#125;&#125; 展示样式： 文件上传提交上传文件需要formdata格式，但是不用自己显式的写明content-type,有时会出问题。不需要写form，可以这样写。 文件上传的html同上。触发上传： 1234567&lt;button style=&#123;&#123; marginLeft: 70, marginTop: 20 &#125;&#125; type=\"button\" className=\"btn Btn\" disabled=&#123;startDate === \"\" || endDate === \"\" || poiResultList.length &lt;=0 || monitorIndexList.length &lt;= 0&#125; onClick=&#123;() =&gt; this.handleFileUpload()&#125;&gt;开始监控&lt;/button&gt; 1234567891011handleFileUpload() &#123; const formData = new FormData(); const fileList = this.upload.files; if (fileList.length &gt; 0) &#123; formData.append('uploadFile', fileList[0]); this.props.postMonitor(&#123; formData &#125; ) &#125; &#125; //postMonitor里发送formdata文件。xhr就行。 前端实现下载功能2进制文件12345678910111213141516171819202122232425262728293031323334// render部分：&lt;div style=&#123;&#123; display: canDownload ? 'inline-block' : 'none' &#125;&#125; className=&#123;listcss.download&#125; onClick=&#123;this.handleDownload&#125;&gt;导出数据&lt;/div&gt; // 处理：handleDownload() &#123; const &#123; download &#125; = this.props; if (download &amp;&amp; download.length &gt; 0) &#123; const u8arr = new Uint8Array(download.length); let length = download.length; while (length--) &#123; u8arr[length] = download[length]; &#125; const blob = new Blob([u8arr.buffer], &#123; type: 'application/vnd.ms-excel' &#125;); const fileName = 'orderData.xls'; downBinaryToExcel(blob, fileName); &#125; &#125; export const downBinaryToExcel = (blob, fileName) =&gt; &#123; if (window.navigator.msSaveOrOpenBlob) &#123; navigator.msSaveBlob(blob, fileName); &#125; else &#123; const link = document.createElement('a'); link.href = window.URL.createObjectURL(blob); link.download = fileName; link.click(); window.URL.revokeObjectURL(link.href); &#125;&#125;; 数组或者字符串内容下载主要是拼接成excel需要的格式, 然后放在blob的内容里。 1234567891011121314151617181920212223242526272829const headerInfo = `&lt;?xml version=\"1.0\"?&gt;&lt;ss:Workbook xmlns:ss=\"urn:schemas-microsoft-com:office:spreadsheet\"&gt;&lt;ss:Worksheet ss:Name=\"Sheet1\"&gt;&lt;ss:Table&gt;\\n`;const footerInfo = `&lt;/ss:Table&gt;&lt;/ss:Worksheet&gt;&lt;/ss:Workbook&gt;`;// 自己组织数据结构，包括一行表头，和每行的数据。const composeRow = R.compose( item =&gt; `&lt;ss:Row&gt;\\n$&#123;item&#125;&lt;/ss:Row&gt;\\n`, R.join(''), R.map( item =&gt; ` &lt;ss:Cell&gt; &lt;ss:Data ss:Type=\"$&#123;R.is(Number, item) ? 'Number' : 'String'&#125;\"&gt;$&#123;item&#125;&lt;/ss:Data&gt; &lt;/ss:Cell&gt;` ));const rows = FUNC（composeRow）// 具体的自己写吧const xml = `$&#123;headerInfo&#125;$&#123;rows&#125;$&#123;footerInfo&#125;`; HEX TO RGB12345678910export const hexToRgb = hex =&gt; &#123; const rgb = []; let letters = hex.substr(1); if (letters.length === 3) &#123; letters = letters.replace(/(.)/g, '$1$1'); &#125; letters.replace(/../g, color =&gt; &#123; rgb.push(parseInt(color, 0x10)); &#125;); return rgb;&#125;;","tags":[{"name":"html5","slug":"html5","permalink":"https://misssweety.github.io/tags/html5/"},{"name":"图片上传","slug":"图片上传","permalink":"https://misssweety.github.io/tags/图片上传/"},{"name":"文件上传","slug":"文件上传","permalink":"https://misssweety.github.io/tags/文件上传/"},{"name":"文件下载","slug":"文件下载","permalink":"https://misssweety.github.io/tags/文件下载/"}]},{"title":"D3-api-transition","date":"2017-09-18T08:45:41.000Z","path":"2017/09/18/D3-api-transition/","text":"D3的动效API-transitionD3的动效都是通过transition来实现的。 transition 是类似于selection的接口，它用于动画改变DOM界面。transition 通过 selection.transition 获得，他和d3.select(…)返回的内容是一样的。 常用api基本api： selection.transition([name])selection.interrupt([name])transition.duration()transition.delay(value|func)transition.ease(name)transition.each()transition.call()transition.filter()transition.merge()transition.remove() 高级： transition.on 监控控制流，几个状态：start，end，interrupt。这个只是transition对象有。 transition.attrTweentransition.styleTweentransition.tween(name[, value]) 最简单例子在需要变化的属性前加上transition()即可~~例子： 12345678910111213svg.selectAll(\"rect\") .data(dataset) .transition() // &lt;-- This is new! Everything else here is unchanged. .attr(\"y\", function(d) &#123; return h - yScale(d); &#125;) .attr(\"height\", function(d) &#123; return yScale(d); &#125;) .attr(\"fill\", function(d) &#123; return \"rgb(0, 0, \" + (d * 10) + \")\"; &#125;); 如果不加，则立即执行，加了则延迟一点点。默认：250ms 常用的transition写法123456.transition() .delay(function(d,i)&#123; return i * 150; &#125;) .duration(1500) .ease(d3.easeBack) 每个元素都会有自己的delay。 ease 函数&quot;easeElastic&quot;, &quot;easeBounce&quot;, &quot;easeLinear&quot;, &quot;easeSin&quot;, &quot;easeQuad&quot;, &quot;easeCubic&quot;, &quot;easePoly&quot;, &quot;easeCircle&quot;, &quot;easeExp&quot;, &quot;easeBack&quot; 调用：1selection.ease(d3.easeElastic) 链式调用连续添加多个transition,最简单的方法之一，就是在第一个transition完成后，继续调用transition。参考例子：https://codepen.io/akixiao/pen/BwNZRp d3.active(node, [name])返回具有指定名称（如果有）的指定节点上的active transition。如果未指定名称，则使用null。如果指定节点上没有这样的active transition，则返回null。此方法对于创建链接transition很有用。 tween 补间动画transition的变化详情，是通过interpolate实现的。默认有几个情况：如果attr中的value是数字，则使用interpolateNumber如果value是color或者字符颜色，则使用 interpolateRgb.其他情况：interpolateString style的属性也是一样的tween有自己的时间函数tween相关函数使用重点就是在，tween函数中设置自己的时间函数： 123456transition.tween(\"attr.fill\", function() &#123; var node = this, i = d3.interpolateRgb(node.getAttribute(\"fill\"), \"blue\"); return function(t) &#123; node.setAttribute(\"fill\", i(t)); &#125;;&#125;); 另一个数字补间应用： 12345678.tween('number', function() &#123; const that = d3.select(this); const i = d3.interpolateRound(0, 200); return function(t) &#123; that.style('color', `rgb($&#123;0 + i(t)&#125;, $&#123;80 + i(t)&#125;, 232)`); that.text(i(t)); &#125;&#125;); 演示：https://codepen.io/akixiao/pen/mBJqzO 循环变换一般通过是将transition写成一个函数。然后使用on监听end事件，实现递归调用。简单例子： 1234567891011121314function repeat() &#123; show.transition() .delay(800) .duration(2000) .tween('number', function() &#123; const that = d3.select(this); const i = d3.interpolateRound(0, 200); return function(t) &#123; that.style('color', `rgb($&#123;0 + i(t)&#125;, $&#123;80 + i(t)&#125;, 232)`); that.text(i(t)); &#125; &#125;) .on('end', repeat); &#125; 一些例子d3实现的smooth scroll高级玩法：https://bl.ocks.org/mbostock/70d5541b547cc222aa02 参考 d3 transitionworking with transitionsD3 Tips and Tricks V4.0D3 Transition Basics","tags":[{"name":"d3","slug":"d3","permalink":"https://misssweety.github.io/tags/d3/"},{"name":"transition","slug":"transition","permalink":"https://misssweety.github.io/tags/transition/"}]},{"title":"关于Object查缺补漏","date":"2017-09-18T08:09:48.000Z","path":"2017/09/18/关于Object查缺补漏/","text":"内置对象这些都是对象子类型，看起来与基础类型一样。如下： String Number Boolean Object Function Array Date RegExp Error 以上内置函数可以当做构造函数来使用。一些字面可以自动转换成对象类型进行一些方法的操作。 深复制 &amp; 浅复制对于对象和数组来说，浅复制是对对象地址的复制，并没有开辟新的栈，复制的结果是两个对象指向同一个地址，修改一个对象的属性，会改变另一个对象属性。深复制则开辟新的栈，两个对象对应两个不同的地址，属性隔离。 浅复制：拷贝引用深复制：拷贝实例深复制比较耗内存，而且可能出现死循环栈溢出的情况。深复制死循环的例子： const testArr = [];const myObj = { a: 2, b: testArr,}; testArr.push(myObj, true); 比如深复制myObj, 除了复制myObj外，还要复制testArr，而testArr引用了myObj,所以又要再次复制myObj，然后这两个开始循环引用导致死循环了。 Object.assign是es6里非常好用的一个方法，Object.assign() 属性描述符是从es5以后，对象属性有了属性描述符。一个对象的属性不仅包含属性值，还包含另外三个特性：writable，enumerable 和 configurable使用该函数，可以获取一个对象属性的配置信息。Object.getOwnPropertyDescriptor( myObject, “a” ); 使用下面的函数，可以配置对象属性Object.defineProperty(obj, ‘prop’, { value: 6, writable: true, configurable: true, enumerable: true,}); writable: 控制能否重写这个属性的值enumerable: 控制这个属性能否被遍历configurable: 控制这个属性的属性描述符是否可以修改，也就是控制这三个属性是否可以被修改。configurable:false 还会禁止删除这个属性 控制属性的不变性当我们想控制一些对象的属性，让他成为不可改变的，我们有如下几种方法： 结合writable &amp; configurablewritable:falseconfigurable:false 对应的属性将不会被更改。也不能被删除。 禁止扩展Object.preventExtensions可以禁止一个对象添加新属性，并且保留已有属性。 12345var obj = &#123; a: 2&#125;;Object.preventExtensions(obj);obj.b = 3;obj.b; // undefined // strict mode：typeError seal 密封Object.seal(..) 会创建一个“密封”的对象，等价于preventExtensions + 每个属性configurable: false;但是其实这个是可以修改属性值的。 freeze 冻结等价于对对象使用seal，并把每个属性标记为writable:false; 但是该属性可以修改深度的对象。 对象属性获取原理属性访问其实是通过对象的[[get]]获取的。对象默认的内置 [[Get]] 操作首先在对象中查找是否有名称相同的属性， 如果找到就会返回这个属性的值。如果本对象中没有，会遍历原型链进行寻找。如果都没有则返回undefined。 在es6中，我们可以进行这个内置操作的修改了。比如Proxy 代理对象。 对应的还有[[Put]]内置操作。主要用来设置对象的值。[[Put]] 被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性(这是最重要的因素，没有则会去查原型链)。如果已经存在这个属性，[[Put]] 算法大致会检查下面这些内容。 属性是否是访问描述符?如果是并且存在setter就调用setter。 属性的数据描述符中writable是否是false?如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。 如果都不是，将该值设置为属性的值。 getter &amp; setter可以在对象的某个属性上进行修改默认的getter与setter函数。但是一般这两个要绑定在一起输出。两个方法： 123456789101112131415const obj = &#123; get c() &#123; return 1;&#125; &#125;;Object.definePropperty(obj, 'b', &#123; get: function() &#123; return 2;&#125;&#125;);obj.c // 1obj.b // 2 obj.b = 3;obj.b // 2// get set 经典搭配const myObj = &#123; get a() &#123; return this._a_; &#125; set a(val) &#123; this._a_ = val &#125;&#125; 属性存在性检验一个对象中是否有某个属性，可以用 in hasOwnProperty 。可以用于检测是属性值为undefined，还是为定义属性。但是这两个的区别是，in是对象本身和其原型链都查，后者则只查对象本身。 参考的是《你不知道的javascript》","tags":[{"name":"javascript","slug":"javascript","permalink":"https://misssweety.github.io/tags/javascript/"},{"name":"object","slug":"object","permalink":"https://misssweety.github.io/tags/object/"}]},{"title":"React生命周期","date":"2017-09-12T11:07:41.000Z","path":"2017/09/12/React生命周期/","text":"react生命周期在自定义React组件时，会根据需要在组件生命周期的不同阶段实现不同的逻辑。本文源码是【15.6.1】 生命周期而组件的生命周期在不同状态下的执行顺序如下： 首次挂载组件 getDefaultProps getInitialState componentWillMount render componentDidMount 重新挂载组件 getInitialState componentWillMount render componentDidMount 再次渲染组件-props CHANGE componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 再次渲染组件-state CHANGE shouldComponentUpdate componentWillUpdate render componentDidUpdate 下面就是揭秘React为何会按照上面这个执行生命周期。 生命周期详解自定义组件声明周期存在3个阶段：MOUNTING, RECEIVE_PROPS, UNMOUNTING 分别对应3种方法。 mountComponent， updateComponent unmountComponent 以上每个都提供了几种处理方法。will前缀的方法在进入状态之前调用，did在进入状态之后调用。 使用createClass创建自定义组件ES6编写React组件时： class MyComponent extends React.Component 是调用createClass创建组件，利用原型继承ReactClassComponent父类，合并mixins，初始化defaultProps，返回构造函数。下面是代码。 关于createClass：【isomorphic/class/createClass.js】 &apos;use strict&apos;; var {Component} = require(&apos;ReactBaseClasses&apos;); var {isValidElement} = require(&apos;ReactElement&apos;); var ReactNoopUpdateQueue = require(&apos;ReactNoopUpdateQueue&apos;); var factory = require(&apos;create-react-class/factory&apos;); module.exports = factory(Component, isValidElement, ReactNoopUpdateQueue); factory: [react/addons/create-react-class/factory.js]; component如上，但是createClass实际上导出的是由factory``包裹的函数。各种生命周期都是在factory里构造的。factory里定义了，ReactClassInterface，里面规定了好多协议（如render等） // Helper function to allow the creation of anonymous functions which do not // have .name set to the name of the variable being assigned to. function identity(fn) { return fn; } function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) { var injectedMixins = []; // 定义reactclass中的协议（其实就是方法） var ReactClassInterface = { mixins: &apos;DEFINE_MANY&apos;, statics: &apos;DEFINE_MANY&apos;, propTypes: &apos;DEFINE_MANY&apos;, contextTypes: &apos;DEFINE_MANY&apos;, childContextTypes: &apos;DEFINE_MANY&apos;, getDefaultProps: &apos;DEFINE_MANY_MERGED&apos;, getInitialState: &apos;DEFINE_MANY_MERGED&apos;, getChildContext: &apos;DEFINE_MANY_MERGED&apos;, render: &apos;DEFINE_ONCE&apos;, componentWillMount: &apos;DEFINE_MANY&apos;, componentDidMount: &apos;DEFINE_MANY&apos;, componentWillReceiveProps: &apos;DEFINE_MANY&apos;, shouldComponentUpdate: &apos;DEFINE_ONCE&apos;, componentWillUpdate: &apos;DEFINE_MANY&apos;, componentDidUpdate: &apos;DEFINE_MANY&apos;, componentWillUnmount: &apos;DEFINE_MANY&apos;, updateComponent: &apos;OVERRIDE_BASE&apos; }; var ReactClassComponent = function() {}; _assign( ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin ); function createClass(spec) { // Constructor.name !== &apos;Constructor&apos;.确保不会将没有displayName的类识别为&apos;Constructor&apos;。重写了contructor函数~~~~ var Constructor = identity(function(props, context, updater) { // 自动绑定 if (this.__reactAutoBindPairs.length) { bindAutoBindMethods(this); } this.props = props; this.context = context; this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue; this.state = null; // reactClasses没有构造函数，通过getInitialState，与componentWillMount来进行初始化。 var initialState = this.getInitialState ? this.getInitialState() : null; // 原型继承自父类。 Constructor.prototype = new ReactClassComponent(); Constructor.prototype.constructor = Constructor; Constructor.prototype.__reactAutoBindPairs = []; injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor)); // 把didmount，willunmount赋给原型 mixSpecIntoComponent(Constructor, IsMountedPreMixin); mixSpecIntoComponent(Constructor, spec); mixSpecIntoComponent(Constructor, IsMountedPostMixin); // Initialize the defaultProps property after all mixins have been merged. // 所有mixin合并后，开始初始化defaultProps if (Constructor.getDefaultProps) { Constructor.defaultProps = Constructor.getDefaultProps(); } // 减少查找并设置原型的时间。 for (var methodName in ReactClassInterface) { if (!Constructor.prototype[methodName]) { Constructor.prototype[methodName] = null; } } return Constructor; } return createClass; } 以上是初始化的阶段，第一次mounting前，createClass返回Constructor函数。getDefaultProps 是在constructor阶段调用的，所以生成一个实例后，就不会再调用了。所以只有初次挂载的时候才会调用。。。 mountComponent阶段mountComponent负责管理生命周期的getInitialState，componentWillMount，render，和componentDidMount. mountComponent挂载组件，初始化序号，标记等参数，判断是否为无状态组件，以及初始化操作。使用getInitialState获取初始化state。在componentWillMount中调用setState，不触发re-render，而是merge state。这个状态的this.state并不是最新的。在render中才可以获取更新的this.state。 [代码里] // When mounting, calls to `setState` by `componentWillMount` will set // `this._pendingStateQueue` without triggering a re-render. if (this._pendingStateQueue) { inst.state = this._processPendingState(inst.props, inst.context); // merge state } 利用：this._pendingStateQueue , this._pendingReplaceState, this._pendingForceUpdate 实现setState的异步跟新机制。 render后，若存在didMount，则调用。 mountComponent通过递归渲染的，由于是递归，肯定是父的willMOUNT, 父的RENDER, 子的willMount，子render，子didMount，父didmount。 mountComponent,初始化state，执行initialMount，返回markup。 mountComponent: function( transaction, hostParent, hostContainerInfo, context, ){ ... var initialState = inst.state; if (initialState === undefined) { inst.state = initialState = null; } this._pendingStateQueue = null; this._pendingReplaceState = false; this._pendingForceUpdate = false; var markup; if (inst.unstable_handleError) { markup = this.performInitialMountWithErrorHandling( renderedElement, hostParent, hostContainerInfo, transaction, context, ); } else { markup = this.performInitialMount( renderedElement, hostParent, hostContainerInfo, transaction, context, ); } if (inst.componentDidMount) { if (__DEV__) { transaction.getReactMountReady().enqueue(() =&gt; { measureLifeCyclePerf( () =&gt; inst.componentDidMount(), this._debugID, &apos;componentDidMount&apos;, ); }); } else { transaction.getReactMountReady().enqueue(inst.componentDidMount, inst); } } return markup; } 在performInitialMount函数中, 使用ReactReconciler，进行递归渲染组件。 var markup = ReactReconciler.mountComponent( child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID, ); RECEIVE—props update的过程源码里面：updateComponent负责管理生命周期的 componentWillReceiveProps，shouldComponentUpdate, componentWillUpdate, componentDidUpdate; 首先通过updateComponent更新组件，如果元素不一致，说明要进行组件更新。代码继续向下执行，如果有componentWillReceiveProps执行，其中有setState会合并state，且在componentWillReceiveProps，shouldComponentUpdate，componentWillUpdate中不会获取到新的state。只能在render和did状态才能获取。剩下几个状态也是有就执行，且顺序为：shouldComponentUpdatecomponentWillUpdaterendercomponentDidUpdate 在updateComponent中 updateComponent: function( transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext, ) { var inst = this._instance; … var willReceive = false; // 判断context变化与否，设置willReceive。 if (this._context === nextUnmaskedContext) { nextContext = inst.context; } else { nextContext = this._processContext(nextUnmaskedContext); willReceive = true; } var prevProps = prevParentElement.props; var nextProps = nextParentElement.props; // 判断props变化与否，设置willReceive。 if (prevParentElement !== nextParentElement) { willReceive = true; } if (willReceive &amp;&amp; inst.componentWillReceiveProps) { ... 判断和执行componentWillReceiveProps } var nextState = this._processPendingState(nextProps, nextContext); var shouldUpdate = true; ... 下面是关于shouldupdate的判断和执行。 shouldComponentUpdate，如果用户自定义了，则按照自定义判断来返回shouldUpdate，否则执行默认操作： if (!this._pendingForceUpdate) { if (inst.shouldComponentUpdate) { if (__DEV__) { shouldUpdate = measureLifeCyclePerf( () =&gt; inst.shouldComponentUpdate(nextProps, nextState, nextContext), this._debugID, &apos;shouldComponentUpdate&apos;, ); } else { shouldUpdate = inst.shouldComponentUpdate( nextProps, nextState, nextContext, ); } } else { if (this._compositeType === CompositeTypes.PureClass) { shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState); } } } 后面render要根据shouldUpdate的状态来执行。 if (shouldUpdate) { this._pendingForceUpdate = false; // Will set `this.props`, `this.state` and `this.context`. this._performComponentUpdate( nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext, ); } else { // 如果确定不更新，也要设置props，state，context this._currentElement = nextParentElement; this._context = nextUnmaskedContext; inst.props = nextProps; inst.state = nextState; inst.context = nextContext; } 如果应该update则调用一下函数this._performComponentUpdate规定了如果有componentWillUpdate，调用。然后是_updateRenderedComponent，进行re-render，调动render方法更新dom接着，如果有hasComponentDidUpdate，调用。 _updateRenderedComponent: function(transaction, context) { // 如果需要更新，则调用ReactReconciler.receiveComponent跟新组件 if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) { ReactReconciler.receiveComponent( prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context), ); } else { // 渲染组件，render递归 var nextMarkup = ReactReconciler.mountComponent( child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID, ); } 也是递归render的，所以也是父的先willUpdate，然后子的willUpdate,子的didUpdate，父的DidUpdate unmounting负责管理componentWillUnmount 如果规定了componentWillUnmount，则执行并重置所有参数，更新队列以及状态。有setState，不会执行re-render。并清除了当前的这个实例。 无状态组件只是一个render方法，没有组件实例化过程。因为没有状态，没有生命周期，接收props生成dom结构。","tags":[{"name":"react","slug":"react","permalink":"https://misssweety.github.io/tags/react/"},{"name":"生命周期","slug":"生命周期","permalink":"https://misssweety.github.io/tags/生命周期/"}]},{"title":"d3-basic-line","date":"2017-06-29T04:19:49.000Z","path":"2017/06/29/d3-basic-line/","text":"d3-折线图从一个最基本的折线图开始，看看d3是怎么实现的，以及用到哪些知识 需要的知识 scale extent transition line curve axis 步骤 获取svg容器 &lt;svg width=&quot;500&quot; height=&quot;270&quot; class=&quot;testline&quot;&gt;&lt;/svg&gt; const svg = d3.select(&apos;.testline&apos;); const margin = {top: 20, right: 20, bottom: 20, left: 20}; const width = +svg.attr(&quot;width&quot;) - margin.left - margin.right; const height = +svg.attr(&quot;height&quot;) - margin.top - margin.bottom; const g = svg.append(&quot;g&quot;).attr(&quot;transform&quot;, `translate(${margin.left},${margin.top})`); x，y轴缩放这里，如果x轴是与时间有关的，可以直接使用d3提供的scaleTime()来实现时间的转换。关于scale还有好多内容，待总结。这里需要确定两个轴，缩放的类型，以及xy轴图像在屏幕中的实际宽高值。这里的x, y 其实是函数（根据给出的数据，得出该数据的x，y坐标值）。 const x = d3.scaleTime().range([0, width]); const y = d3.scaleLinear().range([height, 0]); lineline的生成就需要上面的轴缩放函数。 这里是因为date函数可以接受ms的unix时间戳，所以乘以1000.这里也可以加一些点与点之间的连接方式。 curveMonotoneX平滑, curveLinear线性。需要两步，line函数生成。line呈现。关于line的展示，需要把数据绑定到path标签上，将line函数运用到path的d属性上。就可以绘制出线了，transition这里是为了实现简单的动画效果。注意，line展示的时候，data([data]) 也可应用datum(data)，前者删了数组标记是不可以的。不知道为什么 const line = d3.line() .x((d, i) =&gt; x(d.ts * 1000)) .y(d =&gt; y(d.y)) .curve(d3.curveMonotoneX); // line 的展示。 g.append(&apos;path&apos;) .data([data]).attr(&apos;fill&apos;, &apos;none&apos;).attr(&apos;d&apos;, line).attr(&apos;stroke&apos;, &apos;#f33155&apos;) .transition(500) .attr(&apos;stroke-width&apos;, 3); x坐标轴，y坐标轴domain是将坐标轴对应的真实数据连接起来，一般就是将坐标轴要展示的数据的最大最小值放进来。d3.extent可以自动的算出数组内的最小，最大值，很方便。如下x轴的计算。v4支持axisBottom，axisTop，axisRight，axisLeft等快捷操作，就是说明坐标轴的展现方式。规定好domain后，可以将轴展示在图像中了。给出selector然后调用call(如果是x轴，记得把上面x轴函数传进来，y轴同理)，同时，这里可以规定轴线样式和刻度的相关内容。下面的例子是规定了，最大最小值中间还可以有多少个刻度。 x.domain(d3.extent(data, d =&gt; d.ts * 1000)); y.domain([0, d3.max(data, d =&gt; d.y * 1.1 )]); // Add the X Axis g.append(&quot;g&quot;).attr(&quot;transform&quot;, `translate(0,${height})`) .call(d3.axisBottom(x).ticks(5)); // Add the Y Axis g.append(&quot;g&quot;).attr(&quot;transform&quot;, `translate(0,0)`) .call(d3.axisLeft(y).ticks(8)); 线上打点线上打点，主要是通过line函数，获取点的center位置。需要将data绑定到circle标签上，最后根据line函数绘制出来。 g.selectAll(&quot;.dot&quot;) .data(data).enter().append(&quot;circle&quot;).attr(&apos;class&apos;, &apos;.dot&apos;) .attr(&quot;cx&quot;, line.x()).attr(&quot;cy&quot;, line.y()) .transition(500) .attr(&quot;r&quot;, 3.5).attr(&apos;fill&apos;, &apos;white&apos;).attr(&apos;stroke&apos;, &apos;#f33155&apos;); 数据label类似的，label也是根据line函数获取位置，然后将要现实的值，用text属性显示出来。 g.selectAll(&quot;.text&quot;) .data(this.data).enter().append(&quot;text&quot;) .attr(&apos;class&apos;, &apos;.text&apos;).attr(&apos;font-size&apos;, 12) .attr(&quot;x&quot;, line.x()).attr(&quot;y&quot;, line.y()) .attr(&apos;dx&apos;, -15).attr(&apos;dy&apos;, 7) .text(function(d) { return d.y}) .transition(500) .attr(&apos;fill&apos;, &apos;#333&apos;).attr(&apos;stroke&apos;, &apos;#333&apos;); 当绑定了data数据后，x函数，y函数，会自动按顺序获取数据。 最后结果：参考","tags":[{"name":"d3","slug":"d3","permalink":"https://misssweety.github.io/tags/d3/"},{"name":"line","slug":"line","permalink":"https://misssweety.github.io/tags/line/"},{"name":"可视化","slug":"可视化","permalink":"https://misssweety.github.io/tags/可视化/"}]},{"title":"git实用指令","date":"2017-06-02T02:51:14.000Z","path":"2017/06/02/git实用指令/","text":"实用指令回滚相关最近又好好复习了下reset指令。一般这些回滚的操作最好不要用，尤其是在多人开发的时候，但是偶尔想用，还有点模糊了，这次在记录一下。 git reset步骤：readme中分别添加 test1tess2test3 每一句添加一个commit先看下log git log 暂存区有其他修改，但没有add。 此时，我改错了，想回退到test1的状态。用 git reset --hard 46670a 执行后，暂存区的内容也清空了，readme中，只有test1 了。查看git log前两个提交也不见了。 假如我后悔了，我又不想回退了，我还想在test3的情况下修改。 git reflog可以看到指令的log，从这里可以找回之前回退的相关commit这里会记录着还未被回收的commit号。此次，我把内容添加到暂存区了，也就是add过了，再次使用reset，回滚到原来的test3的状态 git reset --hard 9d91688 内容回到test3 处的commit，并且，之前add到暂存区的都没了 真想回滚，用reset就够了。 revert其实是取消某个提交的意思。revert 功能：revert是撤销某一次的提交，并不是回滚到这次提交时的状态！！！ revert 的历史保留在commit中 rebase用来合并多个commits场景，我们自己在本地改了好多乱七八糟的，但是并不想让所有的commit信息，比如fix之类的都提交，这个时候可以用rebase 配合 squash ，合并commit。 过程如下：先 git log： 我们想将0fad78ccc3到现在的commit都合并, 那么先rebase到那个不变动的commit git rebase -i 4c9bc3a7 如下： 需要留一个pick，其他都改成squash, 如下 esc :wq保存后，这样就把其他的提交都合并了。自动跳到如下界面(这里可以重写合并的commit内容了) 修改完毕，esc :wq 保存 最后，看下git log，干净了！！！！ 远端分支回滚如果远端对应的分支也想修改，必须要—force git push --force origin branch-name 刪除远端分支git push origin --delete target_branch","tags":[{"name":"git","slug":"git","permalink":"https://misssweety.github.io/tags/git/"}]},{"title":"前端页面-网络性能","date":"2017-05-25T02:48:54.000Z","path":"2017/05/25/网络优化/","text":"前端页面-网络性能一个网站从开始访问，发送请求，页面渲染，异步请求，到最终呈现，每个阶段都有各自不同的优化点。 前一段时间，自己项目的网站在加载和渲染的时候表现很奇怪，遂仔细用起chrome的network以及timeline面板，期待找到问题的根源。用的时候发现很多自己缺失的知识，于是就有这篇文章记录查缺补漏的内容。 这里先从网络性能角度来看，它将从初始阶段影响网站的性能。下面会以chrome中的network面板出发，从三点介绍网络性能相关内容，分别包括：主要网络属性，如何在chrome devtool中查看网络性能，如何优化 主要网络属性这里主要关注timing这个属性。某个请求的timing如下： 在network页面点击具体的请求url即可进入上述页面。 可以看到一条资源从列队、停滞、代理协议、初始化连接、SSL协议、发送request、等待及内容下载所耗的时间。 主要属性 Queueing时间：请求排队的时间，出现原因有：更高优先级的请求，或者在HTTP/1.0和HTTP/1.1中，已经有6个同源请求在进行中 Stalled阻塞时间：原因如上queueing DNS Lookup. 浏览器解析请求的ip地址需要的时间 Proxy negotiation. 与代理服务器通信需要的时间 Initial Connection / connecting: 建立连接的过程，包含TCP握手/重试，商定SSL SSL: 完成SSL握手阶段 Request sent：发送请求耗时，通常只要不到1ms的时间 ServiceWorker Preparation.浏览器启动服务worker的时间 Request to ServiceWorker.The request is being sent to the service worker. Waiting (TTFB). 收到首字节的时间。 Content Download. 浏览器接收响应数据的时间。 performance api上面这些资源数据是根据js的性能api计算的。window.performance.getEntries() 获取资源加载时间列表。每个performanceResourceTiming大概如下： connectEnd：浏览器与服务器完成建立用以检索资源的网络连接的时间戳 connectStart：浏览器与服务器开始建立用以检索资源的网络连接的时间戳 damainLookupEnd：浏览器完成资源的域名解析的时间戳 damainLookupStart：浏览器开始进行资源的域名解析的时间戳 duration：资源请求从开始到结束的时间差 entryType：PerformanceEntry对象的类型，该对象封装一个单一的性能指标作为性能表的一部分，此类型是frame, mark, measure, navigation, resource,server的其中一个。 fetchStart：浏览器开始获取资源的时间戳 initiatorType：资源文件的类型 name：资源的url redirectEnd：接收到重定向资源的最后一个响应字节的时间戳 redirectStart：启动重定向以获取资源的开始时间戳 requestStart：浏览器从服务器请求资源的开始时间戳 responseEnd：浏览器接收到资源最后一个字节的时间戳，或者关闭传输连接的时间戳 responseStart：浏览器接收到服务器的响应的第一个字节的时间戳 secureConnectionStart：浏览器开始握手协议，以保护当前连接的安全性，握手开始的时间 startTime：浏览器开始获取资源前的时间戳(整个过程的开始时间) workerStart：如果当前上下文是”worker”，返回开始获取资源的时间戳，否则返回0(应该是应用于双工通信的) 下面这张图定义了PerformanceResourceTiming 接口的各个时间属性： performance.timing() 获取页面整体的时间参数 这个api可以参考这个非正式的标准规范Resouce timing - w3c old one 该规范定义了一个用于Web应用程序的接口，这个接口可以访问文档需要的资源的完整时序信息。 接口的详细说明这里就不一一介绍了，细节了解需要自己去读标准。 下面只挑和我们相关的内容。 由上面这个图，我们可以获取到chrome网络面板中，timing的相关信息，举个例子： 页面整体的时间参数 （mta应该有用到以下参数） pageloadtime = t.loadEventStart - t.navigationStart, dns = t.domainLookupEnd - t.domainLookupStart, tcp = t.connectEnd - t.connectStart, ttfb = t.responseStart - t.navigationStart; 某个资源的时间参数 var r0 = performance.getEntriesByType(&quot;resource&quot;)[0], loadtime = r0.duration, dns = r0.domainLookupEnd - r0.domainLookupStart, tcp = r0.connectEnd - r0.connectStart, ttfb = r0.responseStart - r0.startTime; 参考还有一些其他的测量时间的问题，请参考performance的资源计时统计其他方法使用，参考初探performance-监控网页与程序性能 如何在chrome devtool中查看网络性能在chrome devtool中，我们可以模拟各种网络环境，可以过滤请求，查看http请求信息，了解dom加载时间，cookie信息，资源的上下游等等。 内容略多，参考这里，chrome developers 官网测量网络性能英文不好的可以看这个：Chrome DevTools 之 Network，网络加载分析利器 如何优化网站加载时间对用户的影响：0.1秒：秒开100-300 ：比较小的可察觉的延迟300-1s：Machine is working1秒：还能接受，但是已经不开心了10秒：什么破玩意，不想看了chrome developer里提到，目标是250ms 优化主要从四个属性入手，以下基本翻译自chrome devtool Queued or stalled requests这两个指标如果时间很长，说明很多资源等待造成的原因：访问同一个域名的请求太多，对于http1.1来说，每个host最多同时支持6个tcp连接。 解决： 域名分片：将资源放在不同的域名中，用来克服浏览器对同一个域名访问的限制，但是不能过多因为dns解析也需要时间 [备注]domain sharding (域名分片)（和cdn的不同域名分片是一种分布方式，是将资源分布在不同的域名中达到克服浏览器访问限制的目的；cdn则是在不同的服务器上托管世界各地的网站资源。） 使用http2.0让重要的请求先发起，不重要的remove或者推迟。 Slow Time To First Byte (TTFB)起因： client与server的连接慢；server响应太慢 解决： 连接慢， 使用cdn，或者换个服务商 如果server慢，优化数据库查询，用缓存，修改server配置等。 Slow content download原因：网络不好；内容过大 解决： 连接慢， 使用cdn，或者换个服务商； 优化请求使数据更少。 以上是关于网络层面的网站优化内容，与前端人员开发技术能力相关性不大，需要一些网络层面以及后台来支持。当我们发现网页加载过慢的时候，可以先从网络这边入手，把网络和连接的基础问题排查后，再从优化自己写的代码入手。","tags":[{"name":"timing","slug":"timing","permalink":"https://misssweety.github.io/tags/timing/"}]},{"title":"高德地图api使用总结","date":"2017-05-18T04:28:44.000Z","path":"2017/05/18/高德地图api使用总结/","text":"常用的高德地图api关于appkey，分为两种，一个是api调用的key，一个是地图服务的key，例如，获取门店信息，search功能等等。 脚本加载&lt;script type=&quot;text/javascript&quot; src=&quot;http://webapi.amap.com/maps?v=1.3&amp;key=您申请的key值&quot;&gt;&lt;/script&gt; 需要把这个脚本加载完成后，才能使用AMap。 可以使用map-div这个组件。 如果搭配react，需要在componentDidMount阶段，调用map-div 中的createMap函数。配套的，最好将该地图实例保存在一个对象中，并设置一个flag作为地图加载完成的标志位，以便react使用。 示例： mapInstance.js let __value = null; export default { getter: () =&gt; __value, setter: (val) =&gt; { __value = val; }, }; --------------------------------------- const mapConfig = { name: &apos;AMap&apos;, initOpts: { zoom: MAP_CONFIG.zoom, zooms: MAP_CONFIG.zooms, }, query: { plugin: &apos;AMap.Geocoder,AMap.CitySearch&apos;, }, }; componentDidMount() { (async () =&gt; { const mapIns = await createMap(mapConfig, &apos;mapComponent&apos;); mapInstance.setter(mapIns); this.props.setMapInstanceFlag(true); // 一些事件监听 mapEventHandler(mapIns, &apos;dragend&apos;, &apos;on&apos;, throttle(this.handleMapScale, 800)); mapEventHandler(mapIns, &apos;click&apos;, &apos;on&apos;, throttle(this.handleMapClick, 800)); ... })(); ... } 创建地图对象需要给出一个div作为地图的容器。 &lt;div id=&quot;container&quot; style=&quot;width:800px; height:500px&quot;&gt;&lt;/div&gt; var map = new AMap.Map(&apos;container&apos;,{ config }) 注意： 如果不加center，地图默认显示用户当前城市范围 config常用基本配置 options 说明 zoom 缩放级别 center 地图中心点坐标[lon, lat] zooms 地图可以缩放的范围 ，数组格式[max, min] zoomEnable 是否可缩放，默认为true dragEnable 是否可拖拽，默认为true mapStyle 地图显示样式，normal（默认样式）、dark（深色样式）、light（浅色样式）、fresh(osm清新风格样式)、blue_night features 地图上显示的元素种类， 默认都显示，支持’bg’（地图背景）、’point’（POI点）、’road’（道路）、’building’（建筑物） 常用的地图实例方法地图常用方法 方法 说明 getZoom()， setZoom() 缩放级别 getCenter(), setCenter() 获取地图中心点坐标[lon, lat] setZoomAndCenter 同时设定缩放级别和中心点坐标 setCity(city:String，callback:Functon) 通过设置城市名称来设置地图显示的中心点 zoomIn 地图放大一级 zoomOut 地图缩小一级 地图常用事件类型 click: 鼠标左键单击 mapmove: 地图平移时触发 movestart: 地图平移开始时触发 moveend: 地图移动结束后触发，包括平移和缩放(经试验，缩放并没有触发moveend)。 zoomchange: 地图缩放级别更改后触发 zoomstart: 缩放开始时触发 zoomend: 缩放停止时触发 dragstart: 开始拖拽地图时触发 dragend: 停止拖拽地图时触发 dragging: 拖拽地图过程中触发 如果地图操作后会有其他操作，一般监听 XXXend 方法。注意：setCity，setCenter等操作不会触发drag相关内容。 关于amap的事件绑定有两种方法： 针对Map、覆盖物等常用类直接使用on， off 方法来实现事件的简单绑定和移除 使用AMap.event命名空间addDomListener(domobj, eventName, handler, context(没用过，不清楚))addListener(obj, eventName, handler, context(没用过，不清楚))removeListener(listener): 可以移除dom和非dom事件。 参考 事件event中的内容 所有的CLICK事件点击位置的经纬度，对应在画布上的横纵坐标，事件target， 事件type 其他类型事件，如moveend，zoomevent中只有事件类型type 针对以上，我们可以对地图事件进行封装，一般需要的是事件发生的zoom，地图范围，点击位置的经纬度。🌰如下: const eventInjector = (ev, mapINS, cb) =&gt; { const bounds = mapINS.getBounds(); const param = { sw: bounds.getSouthWest(), ne: bounds.getNorthEast(), zoom: mapINS.getZoom(), type: ev.type, lng: ev.lnglat ? ev.lnglat.getLng() : &apos;&apos;, lat: ev.lnglat ? ev.lnglat.getLat() : &apos;&apos;, }; if (cb) cb(param); }; const mapEventHandler = (mapINS, type, opt, cb) =&gt; mapINS[opt](type, (ev) =&gt; eventInjector(ev, mapINS, cb)); //使用 mapEventHandler(mapIns, &apos;dragend&apos;, &apos;on&apos;, this.handleMapScale); mapEventHandler(mapIns, &apos;dragend&apos;, &apos;off&apos;,this.handleMapScale); //handleMapScale handleMapScale(ev) { console.log(ev); const { ne, sw, zoom, type } = ev; ... } 之后，如果在地图上发生dragend，event的结果如下： 常用地图基本类型LngLat ： 经纬度坐标，确定地图上的一个点构造函数： AMap.LngLat(lng: 119.78, lat: 39.99);生成一个经纬度为[119.78, 39.99]的地理坐标对象。常用方法： - getLng() 获取经度 - getLat() 获取纬度 - offset(w:2,s:-3) w经度，s纬度，参数为数字。将当前经纬度坐标值变化。经度是越向右越大，所以向右为正。同理，纬度越向上越大，所以向上为正。 - distance(lnglat: LngLat | [lng, lat]) 当前经纬度与传入的经纬度的连线的地面距离 - equals(lnglat:LngLat) Bounds：经纬度范围矩形框AMap.Bounds(southWest:LngLat1, northEast:LngLat2);生成一个东北角是LngLat2，西南角是LngLat1 的矩形地物框。常用方法： - contains(point: LngLat) 给出的经纬度点是否包含在矩形范围内 - getCenter() - getSouthWest() - getNorthEast() 常用覆盖物AMap.Marker 构造：AMap.Marker({ markeroptions }) 常用选项map:marker所在的地图position: LngLat类型，点在地图上的位置offset: 像素类型(-75，-75)，marker距离左上角的偏移content: string/object 这里可以自定义marker显示的内容，图片，svg等都可以。bubble: 将覆盖物的事件冒泡到地图上，默认falsezIndex: 叠加顺序title: 鼠标滑过时，点标记的文字提示。extData: 用户自定义属性draggable: 标记点是否可以拖拽移动 方法略多，这里就不写了，基本对应每个选项都会有个get，set方法。hide，show控制点标记的隐藏，还在map中。setMap比较有用，如果设为null，则在地图上移除当前Marker相关的div。还有一些移动类的应用，目前还没使用过，这里就不详述了，主要有：moveAlong, moveTo, stopMove, pauseMove, resumeMove。 事件与地图对象基本一致，少了个ready。多了一些move的行为，具体可参考 AMap.Polygon 构造：AMap.Polygon({ options }) 常用选项map:marker所在的地图path: 参数为，包含经纬度数组的数组. eg：[ [116.368904, 39.913423], [116.382122, 39.901176], [116.387271, 39.912501], [116.398258, 39.904600] ] bubble: 将覆盖物的事件冒泡到地图上，默认false。 zIndex: 叠加顺序, 默认比marker低。 类似svg的多边形属性: strokeColor，strokeOpacity， strokeWeight， fillColor， fillOpacity， strokeStyle， strokeDasharray。 extData: 自定义属性 方法。对应path，extData， options都会有个get，set方法。hide，show控制多边形的隐藏，多边形还在map中。setMap比较有用，如果设为null，则在地图上移除当前polygon相关的div。getBounds,矩形范围对象，返回Bounds类型。getArea,获取多边形面积。contains(point:LngLat)，点是否在polygon内。 事件很多，常用的又mouseover， click等。具体可参考 AMap.Circle 构造：AMap.Circle({ options }) 常用选项map:marker所在的地图center: LngLat类型，圆心在地图上的位置radius: 半径，number类型，单位是米bubble: 将覆盖物的事件冒泡到地图上，默认falsezIndex: 叠加顺序, 默认比marker低。extData: 用户自定义属性类似svg的多边形属性： 同上polygon 方法。对应center，extData， radius，options都会有个get，set方法。hide，show控制隐藏，还在map中。setMap同上。getBounds，圆外切矩形范围对象，返回Bounds类型。contains(point:LngLat)，点是否在圆内。 事件类型类似polygon 具体可参考 AMap.Polyline 构造：AMap.Marker({ markeroptions }) 常用选项，与polygon差不多。多一些线条相关的内容，具体可参考 方法和事件与polygon差不多 常用图层图层是位于最底层的模块，他可能在地图上的其他物件还没加载完就已经生成了。图层都需要地图以plugin的形式引进。 AMap.Heatmapheatmap是个plugin，需要添加plugin，在回调函数中生成AMap.Heatmap实例。 const heatmap; map.plugin([&quot;AMap.Heatmap&quot;], function() { heatmap = new AMap.Heatmap(map, { radius: 25, //给定半径 opacity: [0, 0.8] }); }); 上面的config，包含radius``gradient``opacity``zooms(支持的缩放级别，不在范围内，就不显示热力图了)渐变可以按照如下设置 gradient: { 0.4: &apos;red&apos;, 0.8: &apos;yellow&apos;, 1: &apos;blue&apos;} 方法与覆盖物的差不多，除了， addDataPoint(lng: Lng, lat: Lat, count: number) setDataSet(data: obj, url:jsonp格式数据的服务地址，urlDataParser:可以传递函数进行数据转化) // 这两个可以配合zoom，不同的zoom，热力图对应的数据集不同。 其中，data格式为： { max: number, data: [ { lng: 116.7, lat: 39.9, count: 10 }, { lng: 116.7, lat: 39.9, count: 10 }], } AMap.CustomLayer同样需要plugin来引入。 给出的属性和方法很少，但是功能强大，需要自己开发，参考实例 一般是自己做一些canvas，然后挂载在map上即可。自定义图层有个render属性？使其等于绘制函数，就可以在地图上绘制出来。 搜索服务支持搜索服务脱离地图使用，即使用搜索服务不再需要先实例化地图。通过AMap.plugin方法，加载需要的服务 AMap.Autocomplete 常用选项：city:输入提示被限定的城市citylimit: 是否强制限制在设置的城市内搜索input:指定一个输入框，内容则作为input的id，在input输入文字后，会自动生成一个下拉选择列表。 search方法，可以结合他的search方法，获取数据，然后自己render样式~~ AutocompleteResult对象： { info： 状态说明, count: 输入提示条数, tips: [ { name: 名称, district: 所属区域, ,adcode: 区域编码}, { name: 名称, district: 所属区域, ,adcode: 区域编码}... ] } 通常autocomplete配合placeSearch进行使用的 AMap.PlaceSearch 常用选项：city:输入提示被限定的城市citylimit: 是否强制限制在设置的城市内搜索type:兴趣点类别，可以通过setType设置pageSize:单页显示结果条数extensions: ‘all’ 返回基本+详细信息panel&amp;renderStyle结果列表的html容器id，或者容器元素，结果列表将在给出的容器中进行展示，自己可以render样式。 可用方法见参考吧 上个search使用示例： html： &lt;img className={styles.searchIcon} src={searchIcon} alt=&quot;search&quot; onClick={() =&gt; this.handleSearch()} /&gt; js: handleSearch() { // this.state.placeSearch是个AMap.Autocomplete实例 this.state.placeSearch.search(this.refs.searchInput.value, this.handleSearchSelect); } handleSearchSelect(search, result) { if (result.info === &apos;OK&apos;) { // mapInstance是个封装了AMap的对象。 const mapIns = mapInstance.getter(); // 自定义搜索结果的marker样式。并绘制在地图上 this.generateSearchMarkers(result.poiList); if (result.poiList.pois.length &gt; 0) { const { lng, lat } = result.poiList.pois[0].location; // 将map的中心定位到获取到的第一个poi的位置上。 mapIns.setCenter([lng, lat]); mapIns.zoomIn(); } } } 如果查到结果searchResult有以下内容： 其他还有好多具体的搜索的服务。由于没有用到，就没看。。。 信息窗体AMap.InfoWindow用于在地图上弹出一个详细信息展示窗体，地图上只允许同时展示1个信息窗体 属性isCustom： 是否自定义窗体，true 则完全按照content中的规定来显示autoMove： 将窗体完全展现在视图中。closeWhenClickMap: 鼠标点击地图后是否关闭信息窗体position: 信息窗体显示位置，类型为经纬度对象 方法事件类似polygon，有一些属性的get，set方法，open，close方法。 定位AMap.CitySearch项目中用到这个api。它主要是根据ip返回对应的城市信息，根据输入ip或自动获取ip来获取城市信息。该api也是个plugin，可以在初始loader地图的时候，就将其配置进去，将脚本加载时的代码。 两个方法：getLocalCity((status, citySearchResult) =&gt; {…})getCityById(ip, (status, citySearchResult) =&gt; {}) 例子： // citysearch部分代码，省略地图实例了，用mapIns代替 citysearch.getLocalCity((status, result) =&gt; { if (status === &apos;complete&apos; &amp;&amp; result.info === &apos;OK&apos;) { if (result &amp;&amp; result.city &amp;&amp; result.bounds) { const city = R.slice(0, -1, result.city); const cindex = R.indexOf(city, R.pluck(&apos;cityName&apos;, cityList)); const ccode = R.pluck(&apos;cityCode&apos;, cityList); if (cindex !== -1 &amp;&amp; city !== &apos;北京&apos;) { mapIns.setCity(city); mapIns.setZoom(11); } } } }); citySearchResult 的属性：city， bounds 位置解析AMap.GeocoderGeocoder是进行地址描述与地理坐标间的相互转换。也就是，给出一个地址名称，转换为地理坐标的经纬度等信息。或者给出一个经纬度，确定这个点的地址名称信息。 相关方法： 获取地理编码：getLocation(address:String, (status:String,result:info/GeocodeResult) =&gt; {}) 逆地理编码：getAddress(location:LngLat|Array.,(status:String,result:info/ReGeocodeResult) =&gt; {})// 最多20个地址数组。 s用的比较多的是逆地理编码，比如自己做一个在地图上点击，然后找出该位置的相关信息。逆地理编码的返回结果属性：想展示什么，就从以下选择吧","tags":[{"name":"js","slug":"js","permalink":"https://misssweety.github.io/tags/js/"},{"name":"地图api","slug":"地图api","permalink":"https://misssweety.github.io/tags/地图api/"},{"name":"总结","slug":"总结","permalink":"https://misssweety.github.io/tags/总结/"}]},{"title":"css3实现3d效果","date":"2017-05-15T08:34:12.000Z","path":"2017/05/15/css3实现3d效果/","text":"css3实现3D效果相关属性 transform: rotateX(…) transfrom-origin: left center; transform-style: preserve-3d; perspective: 200px; perpective-origin: left center; backface-visibility: true; 3d效果基础知识一般是在旋转后才能表现出3d效果，css中规定的旋转规则如下： alt axis rotateX是以屏幕的水平方向为轴旋转，rotateY是以屏幕的垂直方向为轴，rotateZ是以与屏幕平面垂直的方向为轴。其实rotatex rotateY已经能实现3d效果了，但是不是很直观。搭配上perspective，perfect！ perspective含义：透视效果。指定了观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。等同于绘画中的1点透视||平行透视。一个物体如果z-index为正，那么我们在画布中实际看到的就要偏大。如下第一个图。如果一个物体的z-index为负，那么显示在画布视图中，则偏小，如第二个图 alt perspective 两种写法:a：perspective：300px;b：transform: perspective(300px) rotateX(aa); 区别：第一个需要写在一个父级元素上，他规定了这个父级元素的透视点位置，换个角度说，当为元素规定perspective 属性时，其直接子元素会获得透视效果，而不是元素本身。第二个可以直接作用在当前元素上，也可以结合其他transform属性，规定了当前元素的透视点位置，对其他元素无影响。&nbsp;&nbsp;&nbsp;&nbsp;perspective 值越大，3d效果越不明显；越小越明显。想像成镜头到物体的距离，越近越能看出高低起伏，越远线条展示的越平缓。两种写法以及perspective对比，查看示例 -webkit-perspective-origin消失点的位置，语法：-webkit-perspective-origin: xpos yposxpos,ypos 可以选择关键字，left|right|center top|bottom|center 。如果是关键字，则是否对应xy无关紧要，浏览器会自己选择。如果是数值，百分比或者像素，则要按照x，y的顺序写。参考实例 backface-visibilitybackface-visibility 属性定义当元素不面向屏幕时是否可见。有些时候前面的div如果设置了透明度，就会看到后面的对象，这是可以将该属性设为hidden就可以了。默认：visible transform这里主要提和3d有关的几个属性 rotateX( angle ) rotateY( angle ) rotateZ( angle ) translateZ( tz ) scaleZ( sz ) translateZ，scaleZ会将对象在与屏幕平行的方向变化物体。会有失真。 也有综合的写法： translate3d( tx, ty, tz ) scale3d( sx, sy, sz ) rotate3d( rx, ry, rz, angle ) rotate3d这里，前三个规定旋转轴在空间中的方向，比如x轴，就是（1，0，0）rotate3d(1,0,0,90deg) === rotateX(90deg) transform-origin规定变化的中心点。一般都是对象的重心。可以修改成任意的值，以旋转为例: html &lt;div class=&quot;test1&quot;&gt;test&lt;/div&gt; &lt;div class=&quot;test2&quot;&gt;test2&lt;/div&gt; css div { width:200px; height: 200px; background: rgba(255, 0, 0,.5); margin: 20px auto; animation: mymove 3s infinite; } .test1{ transform: perspective(500px) rotateY(0deg); } .test2 { transform-origin: left; transform: perspective(500px) rotateY(0deg); } @keyframes mymove { from {transform: perspective(500px) rotateY(0deg);} to {transform:perspective(500px) rotateY(360deg);} } 表现是：test1将沿着div的宽度的一半为轴旋转。test2则沿着最左边的边框为轴旋转。参考实例 实例一：翻牌效果&lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;card&quot;&gt; &lt;div class=&quot;front&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;back&quot;&gt;2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; //css,设置一个container，他是个具有3d效果的box .container { width: 200px; height: 200px; position: relative; perspective: 800px; border: 1px solid #888; margin: 40px auto; } #card { width: 100%; height: 100%; position: absolute; transform-style: preserve-3d; animation: flip 2s infinite; transform-origin: left center; } #card figure { display: block; width: 100%; height: 100%; position: absolute; text-align: center; color: white; font-size: 40px; line-height: 200px; backface-visibility: hidden; } .front { background: tomato; } .back { background: lightblue; transform: rotateY( 180deg ); } @keyframes flip { 0% { transform: rotateY( 0deg ); } 50% { transform: rotateY( 180deg ) translateX(-100%); } 100% { transform: rotateY( 360deg ) } } container中的card div具有3d效果，如果想让card中的div等也有3d变化效果，可以通过对card设置： transform-style: preserve-3d; 将其父元素的3d透视集成下来，并使所有子元素保持在同一个3d空间中。背面那张牌需要翻到背面去，也就是rotateY( 180deg );参考示例 ###实例二：旋转的正方体参考示例六个div拼凑起来的。分别在xy方向上进行翻转，立到对应的方向。此时在添加一个translateZ才能显现出他们的效果。否则都是堆在zindex为0的位置，什么都看不见. 别的配置及思想同上面的翻牌 ###常见问题：1.设了transfrom-style:preserve-3d为什么还不好使。 这个时候需要查看父元素是否还设了，overflow，filter，clip，isolation，clip-path，mask-image，mask-box-image-source， mix-blend-mode，如果不是默认值的，会将transfrom-style:preserve-3d 失效。原因是前几个属性，会创造一个flatten的box，而preserve-3d是生成stacking context 的。","tags":[{"name":"css","slug":"css","permalink":"https://misssweety.github.io/tags/css/"},{"name":"perspective","slug":"perspective","permalink":"https://misssweety.github.io/tags/perspective/"},{"name":"3D效果","slug":"3D效果","permalink":"https://misssweety.github.io/tags/3D效果/"}]},{"title":"读书笔记-闭包","date":"2017-05-08T03:11:08.000Z","path":"2017/05/08/读书笔记-闭包/","text":"经典闭包闭包是一个函数（引用），即使他是在当前词法作用域之外执行，他也可以记住并访问所在的词法作用域。就是用这个引用来访问。参考 function foo () { const a = 9; const bar = () =&gt; {return a;} return bar; } const aa = foo(); console.log(aa()); 返回9； 解析在foo()执行后，其返回值赋值给变量aa，并执行aa()，其实是通过不同的标识符引用调用了内部函数bar()。bar在其词法作用域外被正常执行了。而且foo函数执行后，通常整个foo内部作用域都被销毁，但是由于bar的存在，是的内部作用域依然存在，组织了垃圾回收。bar() 拥有涵盖foo()内部作用域的闭包，使得该作用域能一直存活。bar()依然持有对该作用域的饮用，这个引用就叫做闭包。 如果将函数当作第一级的值类型进行传递，其实就会有闭包的存在。一些异步或者同步操作中，使用了回调函数，也是在使用闭包。 无处不在 本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax请求、跨窗口通信、Web Workers或者任何其他的异步(或者同步)任务中，只要使用了回调函数，实际上就是在使用闭包. 最常见的考题 for (var i = 1; i&lt;= 5; i++) { setTimeout(() =&gt;console.log(i), 1000*i); } 输出是：五个6 原因：i是全局变量，setTimeout是等待执行。延迟函数的回调会在循环结束时才执行,执行的时候i已经跳出循环，第一个满足的值就是6.所以输出5个6. 修改：将var 改为let。只在当时的循环中生效。可以每秒输出12345 另外一个应用：模块 从方便观察的角度看，一个从函数调用 所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。 实例： function CoolModule() { var something = &quot;cool&quot;; var another = [1, 2, 3]; function doSomething() { console.log( something ); } function doAnother() { console.log( another.join( &quot; ! &quot; ) ); } return { doSomething: doSomething, doAnother: doAnother }; } var foo = CoolModule(); foo.doSomething(); // cool foo.doAnother(); // 1 ! 2 ! 3 上一个示例代码中有一个叫作 CoolModule() 的独立的模块创建器，可以被调用任意多次， 每次调用都会创建一个新的模块实例。如果想实现单例模式：就是将coolmodule 转换为iife，并赋予一个标识符： var foo = (...)(); foo.doSomething(); foo.doAnother(); 结果同上 模块有两个主要特征:(1)为创建内部作用域而调用了一个包装函数;(2)包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。 词法作用域function foo() { console.log( a ); // 2 } function bar() { var a = 3; foo(); } var a = 2; bar(); 输出结果：2。词法作用域，运行bar，到foo的时候，这里的a是全局变量的a，所以为2.","tags":[{"name":"js","slug":"js","permalink":"https://misssweety.github.io/tags/js/"},{"name":"闭包","slug":"闭包","permalink":"https://misssweety.github.io/tags/闭包/"}]},{"title":"linux 目录结构","date":"2017-05-08T02:46:56.000Z","path":"2017/05/08/linux文件目录/","text":"原来学linux的时候，不上心，现在后悔莫及，开始补基础。首先是最基本的目录结构。linux是树状结构 标橘色为重要目录 目录 描述 ／ 根目录，整个文件系统层次结构的根目录，一般只放目录 /bin/ 类似 /usr/bin 可执行的二进制文件的目录，常用的ls，tar，mv， cat等 /boot/ 引导程序文件，放置linux系统启动时用到的一些文件 /dev/ 存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备 /etc/ 系统配置文件存放的目录,不建议在此目录下存放可执行文件，重要的配置文件 /home/ 系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下, 建议单独分区，并设置较大的磁盘空间 /lib/,/usr/lib/, /usr/local/lib/ 系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为/lib/modules /lost+fount/ 系统异常产生错误时，会将一些遗失的片段放置于此目录下，通常这个目录会自动出现在装置目录下。 /mnt/ 临时挂载的文件系统。比如cdrom,u盘等，直接插入光驱无法使用，要先挂载后使用 /opt/ 给主机额外安装软件所摆放的目录, 可选应用软件包。 /proc/ 此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间.比较重要的目录有/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/*等 /root/ 超级权限用户的家目录 /sbin:/usr/sbin:/usr/local/sbin 放置系统管理员使用的可执行命令，如fdisk、shutdown、mount等。sbin目录下的命令，普通用户都执行不了。 /tmp/ 一般用户或正在执行的程序临时存放文件的目录,任何人都可以访问,重要数据不可放置在此目录下,在系统重启时目录中文件不会被保留。 /srv/ 服务启动之后需要访问的数据目录，如www服务需要访问的网页数据存放在/srv/www内 /usr/ 默认软件都会存于该目录下。用于存储只读用户数据的第二层次；包含绝大多数的(多)用户工具和应用程序。 /var/ 变量文件——在正常运行的系统中其内容不断变化的文件，如随时更改的日志文件 /var/log，/var/log/message： 所有的登录文件存放目录，/var/spool/mail： 邮件存放的目录， /var/run: 程序或服务启动 /etc/目录未完待续。。。参考参考二","tags":[{"name":"linux","slug":"linux","permalink":"https://misssweety.github.io/tags/linux/"}]},{"title":"export相关","date":"2017-04-18T03:01:45.000Z","path":"2017/04/18/exports/","text":"exports 和 module.exports 的区别exports 是引用 module.exports 的值。module.exports 被改变的时候，exports不会被改变，而模块导出的时候，真正导出的执行是module.exports，而不是exports。 有以几点需要记住： module.exports 初始值为一个空对象 {}exports 是指向的 module.exports 的引用require() 返回的是 module.exports 而不是 exports如果module.exports 当前没有任何属性的话，exports会把属性收集起来赋给module.exports。如果module.exports 有属性的话, exports中的所有内容都会被忽略。 foo.js exports.a = function(){ console.log(&apos;a&apos;) } module.exports = {a: 2} exports.a = 1 test.js var x = require(&apos;./foo&apos;); console.log(x.a); 输出 ：2 如果：foo.js 为： exports.a = function(){ console.log(&apos;a&apos;) } exports.a = 1 test.js 输出：1 如果：foo.js为： exports.a = function(){ console.log(&apos;a&apos;) } test.js 输出：[Function] 首先，node中的require 引进的是module.exports。。。见第一个实例。如果没有显式的写module.exports，则自动连接exports与module.exports。如果显示的写了module.exports，则会断开module.exports 与 exports 的联系。 应用的话，如果只是导出某个变量或者某个功能，用exports.属性|方法。如果是导出多个属性或方法或使用对象构造方法，module.module 比较好。 export default 和 export 区别1.export与export default均可用于导出常量、函数、文件、模块等2.你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用3.在一个文件或模块中，export、import可以有多个，export default仅有一个4.通过export方式导出，在导入时要加{ }，export default则不需要 引入时：加了default的变量，可以起任意名字，非default的需要与export时的名字相同。 module.exports vs exportcommonjs：module.exports 搭配的引入： requirees6: export 搭配的引入： import 普通js环境下是不支持es6的语法的，如果想这么用，需要用babel等进行转译。 es6 default export 其实是与exports 等价的，只不过 default 只是一个保留的名称，可以想象为，exports 一个属性，属性名为default。所以如果是在node.js环境下，用的export default， 引用的时候用require的话，需要这么写： var bar = require(‘./input’).default; export vs export default这两个在import的时候，前者需要用{} 扩起来，有种解构的感觉。后者不需要{}扩。","tags":[{"name":"node.js","slug":"node-js","permalink":"https://misssweety.github.io/tags/node-js/"},{"name":"js","slug":"js","permalink":"https://misssweety.github.io/tags/js/"}]},{"title":"Visual-Formatting-Model","date":"2017-04-17T04:00:00.000Z","path":"2017/04/17/Visual-Formatting-Model/","text":"1.视觉格式化模型 introduction视觉格式化模型：User Agent 如何在 Visual Media下处理文档树。 视觉格式化模型中，文档树中的每一个元素根据盒模型 Box Model 产生零个或多个盒。这些盒的布局由以下内容控制： 盒的尺寸和类型 定位体系 Positioning Scheme （常规流，浮动和绝对定位） 文档树中元素之间的关系 外部信息（如：视口大小，图片的固有尺寸等） 1.1 视口 viewport连续媒体 Continuous Media 上工作的user agent一般会向用户提供一个viewport（屏幕上的一个窗口或其它可视区域）来帮助用户访问文档。user agent可以在调整视口大小的同时改变文档的布局 1.2 包含块 containing blocksCSS2.1中，许多盒的定位和大小都根据一个名为包含块 Containing Block 的矩形盒的边缘来计算。生成的盒会充当其后代盒的包含块；我们称盒为其后代“创建”了包含块。说“盒的包含块”即是说“盒所处的包含块”，而不是盒所产生的包含块。 2 盒的生成 Controlling Box Generationdisplay指定盒的类型 有几个概念： block-level box: display：block|table|list-item block box: 除了table块盒和可替换元素，其他的都是块容器盒。也是块盒。 block container box: 一个块容器盒要么只包含块级盒，要么创建一个行内格式化上下文 Inline Formatting Context 并只包含行内级盒 Inline-level Boxes。不一定是block的才是，行内也是。所以和块级盒只是一部分有交集。 3 定位体系 Position schemes在css2.1中，一个box有三种机制来布局 normal flow：块级formatting, 行级formatting，相对定位 float：box先按照normal flow放置，然后从流中脱离出来，可能会对后面的排序有影响 absolute position：完全脱离出文档流，对之后的元素没有影响 [脱离文档流] float， absolutely positioned， 根元素。 3.1 position 属性属性： static：top right等并不生效 relative：盒的定位根据常规流计算（盒被成为常规流内定位）。盒相对其常规位置移动。当B盒相对定位，B盒之后的盒定位时就当B没有移动一样来计算。table相关的内盒并没有relative属性 absolute：位置大小通过top，right等定义。脱离文档流了，即便绝对定位盒有外边距，也不同其他任何外边距折叠。 fixed：盒的定位根据 absolute 模型来计算，但除此之外，盒相对某些参照物保持固定。【用户代理不可将固定盒的内容分页显示。注意用户代理可能用其他方法打印不可见内容。参见第13章“页盒外的内容”】 4 常规流 Normal Flow常规流中的盒子都属于某个格式化上下文，要么块格式化上下文BFC，要么行内格式化上下文LFC，总之不能二者得兼。 ###4.1 bfc 浮动 绝对定位元素、 非块盒的块容器（如：行内块 inline-block 、表格单元格 table-cell 以及表格标题 table-caption ） 以及 overflow 属性不为 visible 的块盒（除了该值被传播到视口的情况） 将为其内容创建一个新的块级格式化上下文。 在块格式化上下文中: 盒从包含块顶部一个接一个地垂直摆放。 两个同胞盒间的垂直距离取决于 margin 属性。 同一个块格式化上下文中的相邻块级盒的垂直外边距将折叠。 每个盒的左外边缘紧贴包含块的左边缘。 ###4.2 lfc 盒从包含块顶部一个接一个的水平摆放。盒的垂直对齐方式则不一：可能按底部或者顶部对齐，又或者按它们内容文本的基线对齐。 行盒的宽度取决于包含块以及浮动。 行盒的高总是足以容纳其包含的所有盒，当一个盒（ B ）的高度小于包含它的行盒的高度时， B 的垂直对齐方式由 vertical-align 属性决定。 当一行不能包含所有时，它们会被分配到两个或者多个垂直摆放的行盒中，变成垂直堆叠。行盒的堆叠没有垂直间距（除非有特别声明）并且从不重叠。 一般行内盒超过行盒宽度是，行内盒会被分在多个行盒中。 如果一个行内盒不可切割（比如，行内盒包含的是单个字符或者语言指定的断字规则不允许断字，又或者行内盒的 white-space 属性值为 nowrap 或 pre ），那么该【行内盒将溢出行盒】。 ###4.3 相对定位对于相对定位而言，left 和right使其发生水平位移。而且满足：left = - right。所以如果两个都定义了，则必有一个被忽略。top bottom同理，top胜。 5 浮动 floats浮动盒将被移动至左侧或右侧直至其外侧紧贴包含盒的边缘或另外一个浮动的外边缘。如果存在行盒，浮动盒的顶部外边缘将与行盒的顶部对齐。 float内元素的margin不会与包含他的发生垂直边距折叠。 clear 清除浮动 https://segmentfault.com/a/1190000003096320#articleHeader5 [link]https://www.w3.org/TR/CSS2/visuren.html#block-formatting","tags":[{"name":"css","slug":"css","permalink":"https://misssweety.github.io/tags/css/"}]},{"title":"thinking-with-join","date":"2017-03-09T14:16:48.000Z","path":"2017/03/09/thinking-with-join/","text":"下面这段代码是我们最常用的，为每个数据生成一个circle，调用数据里的x，y来定位。但是我们selectAll的元素，此时并不存在，那d3是如何工作的呢? svg.selectAll(“circle”) .data(data) .enter().append(“circle”) .attr(“cx”, function(d) { return d.x; }) .attr(“cy”, function(d) { return d.y; }) .attr(“r”, 2.5); 在d3中，告诉d3你想要什么，而不是告诉d3怎样做什么。对于上面这个需求，我们要做的就是，我想要circle对应于数据，每个circle对应于一个数据，而不是告诉d3，你应该给我创造一个circle，然后告诉d3选择的circle应该和数据对应好。这个原则就叫做data join Data Enter Update Elements Exit 连接到现有元素的数据点生成update（内部）选择。剩余未绑定数据生成enter选择（左），表示缺少的元素。同样，任何剩余的未绑定元素会生成exit选择（右），表示要删除的元素。 现在，我们可以通过data join 来揭开enter-append序列的谜团了 svg.selectAll(&quot;circle&quot;) 返回一个新的空selection，因为SVG容器是空的，所以该selection的父节点是SVG容器 然后此selection连接到数据数组，生成三个新selection分别表示三种可能的状态：enter，update和exit。由于selection为空，所以update和exit选择为空，而enter selection包含每个新数据的占位符。 update selection通过selection.data返回,而enter和exit selection挂起update selection; selection.enter返回enter selection。 通过在enter selection上调用selection.append，将缺少的元素添加到SVG容器。这会为每个数据点向SVG容器添加一个新圆。 Thinking with joins 意味着在一个selection和数据集中声明一种关系，然后通过enter, update, exit实现这个关系. 但是为什么会这么麻烦呢？为什么不一开始就创建多个元素呢？data join的美丽在于它的泛化。虽然上述代码只处理enter selection,这就可以处理静态可视化了，但是你可以将其扩展为支持动态可视化，只需对update和exit进行少量修改。这意味着您可以对实时数据进行可视化，允许交互式探索，以及在数据集之间平滑过渡！ 看下包含三个状态的例子： var circle = svg.selectAll(“circle”) .data(data);circle.exit().remove();circle.enter().append(“circle”) .attr(“r”, 2.5) .merge(circle) .attr(“cx”, function(d) { return d.x; }) .attr(“cy”, function(d) { return d.y; }); 无论何时运行此代码，它都会重新计算数据连接并保持元素和数据之间的所需对应关系。如果新数据集小于旧数据集，则剩余元素将在退出选择中结束并被删除。如果新数据集较大，剩余数据将在输入选择中结束，并添加新节点。如果新数据集的大小完全相同，那么所有元素都将使用新位置进行更新，并且不会添加或删除任何元素。 thinking with join用连接来思考意味着你的代码更具声明性：你处理这三个状态没有任何分支（if）或迭代（for）。而是描述元素应如何对应数据。如果给定的enter，update或exit selection恰好是空的，则相应的代码是无操作 连接还允许将操作定向到特定状态（如果需要）。例如，你可以在enter而不是update上设置常量属性（例如由“r”属性定义的圆的半径）。通过重新选择元素和最小化DOM更改，您大大提高了渲染性能！同样，您可以将动画过渡指定为特定状态。例如，在entering状态，加入动画圆圈展开 大致翻译自：thinking with join","tags":[{"name":"d3","slug":"d3","permalink":"https://misssweety.github.io/tags/d3/"},{"name":"translate","slug":"translate","permalink":"https://misssweety.github.io/tags/translate/"}]},{"title":"博客搭建","date":"2016-10-27T04:00:00.000Z","path":"2016/10/27/blog-publish/","text":"适用于macOS ###1.需要安装git，npm，node升级本地npm npm install npm@latest -g 如果有权限问题，前面加上sudo就可以了 ###2.安装hexo sudo npm install -g hexo 全局安装了 ###3.hexo管理一个网站 hexo init blog 名字随自己喜欢，这里起的事blog ###4.进入该文件，进行管理 cd blog hexo server //启动你的本地网站，访问localhost:4000，就可以看到雏形了 hexo new &quot;hello world&quot; //生成一个hello world.md文件，新新文章，添加到网站中 ###5.部署到github上 ####git上建立仓库先在自己的库里创建一个新的repo,作为网站的远端库，一般命名为自己的账号名，例如： 我的账号missSweety，新建的repo为missSweety.github.io ####修改hexo配置文件回到hexo中，为了部署到github上，我们需要修改_config.yml文件如下： deploy: type: git repository: https://github.com/MissSweety/MissSweety.github.io.git branch: master ####安装hexo deployer git npm install hexo-deployer-git –save如果不安装这个，deploy的时候会报错的 ####hexo deploy hexo deploy如果没配过ssh，还是会报错的解决方法： ssh-keygen -t rsa -b 4096 -C ‘email’ 按照提示，输入账号，密码，就会生成文件了回到github网站，在setting中把公钥放进去 ssh -T git@github.com 用该指令可以查看是否已经鉴权了 如果以上都好了，这次在用hexo deploy,就会自动push代码，并发布了，可以查看你的网站了 ###大功告成!!!","tags":[{"name":"hexo","slug":"hexo","permalink":"https://misssweety.github.io/tags/hexo/"}]}]